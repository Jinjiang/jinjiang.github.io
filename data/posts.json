{"1":{"title":"Hello World","slug":"hello-world","created":1331993360,"modified":1332423966,"text":"这里就是我囧克斯的新家了，先囧一个：\r\n\r\n    ╔囧╗╔囧╝╚囧╝╚囧╗\r\n    ╔囧╗╔囧╝╚囧╝╚囧╗\r\n    ╔囧╗╔囧╝╚囧╝╚囧╗\r\n    ╔囧╗╔囧╝╚囧╝╚囧╗"},"7":{"title":"网站装修计划","slug":"jiongks-plan","created":1332515063,"modified":1332515085,"text":"写给自己的网站装修计划。\r\n\r\n首先，选个现成的程序。这个已经选好了，就是Typecho了。\r\n\r\n然后，给这个程序做个皮肤，经过了前后设计三个版本之后，我觉得现在这个看着靠谱一些。为了避免以后换了别的皮肤。在此截图留念  \r\n![屏幕快照 2012-03-23 下午10.32.30.png](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2012/03/1377949152.png)\r\n\r\n然后，把我之前分享过的一些demo、ppt等内容汇聚过来。现在基本都照原样拿过来了。不过我觉得还不够，因为之前的幻灯片都是针对webkit设计和开发的，另外url规则还是不够简单明了。回头要做的事情是：把url规则弄得更简单、兼容更多的浏览器。\r\n\r\n然后，了解一些SEO和网站统计的知识，在这里做点尝试，也让自己更认识我的读者。(说实话我在启动这个网站的时候，并不太清楚我的读者是哪些人，喜欢什么，突然觉得这个重要)\r\n\r\n然后，我希望尝试着放一些照片的展示。其实现在即将是视频时代了，拍照上传微博这种事情都快out了。不过我还是想跟风一把，试试看，放一些自己的想法在里面。\r\n\r\n然后，我还希望尝试着做一些后台开发的学习和分享。这也是我转向sae的原因。最开始写博客的时候，我只是奢望一个能够直接写html代码的博客，给文章里做点样式和特效；到后来，我找到了github，通过gh-pages放静态页面；现在，我想通过sae写写php神马的。\r\n\r\n以上是我近期的计划"},"8":{"title":"汇总自己过去的一些HTML5科普文章","slug":"my-html5-articles-in-the-past","created":1332607832,"modified":1332608388,"text":"新网站开张总得找点东西充数，刚好我这阵子集中看了一些w3c关于html5的文档，所以顺道把之前看过的东西汇总了一下。这些内容如果今后继续有积累的话，还会保持更新。\r\n\r\n_另外诸位对哪些html5新特性有科普需求的，不妨留言在下面，我会尽力而为 :-)_\r\n\r\n目前这些内容的最近更新时间是2012年3月\r\n\r\n<!--more-->\r\n\r\n### JavaScript APIs\r\n\r\n* [LocalStorage](http://bulaoge.net/topic.blg?dmn=g3g4&tid=2302783)：一些使用心得\r\n* [IndexedDB(一)](http://bulaoge.net/topic.blg?dmn=g3g4&tid=2329796)、\r\n[(二)](http://bulaoge.net/topic.blg?dmn=g3g4&tid=2330716)、\r\n[(三)](http://bulaoge.net/topic.blg?dmn=g3g4&tid=2335030)、\r\n[(四)](http://bulaoge.net/topic.blg?dmn=g3g4&tid=2336465)\r\n* [File API](http://bulaoge.net/topic.blg?dmn=g3g4&tid=2344378)\r\n* [File Writer API](http://bulaoge.net/topic.blg?dmn=g3g4&tid=2356045)\r\n* [File System API](http://bulaoge.net/topic.blg?dmn=g3g4&tid=2360496)\r\n* [Typed Arrays](http://bulaoge.net/topic.blg?dmn=g3g4&tid=2366365)：另外提及了\r\n  * `XML Http Request Level 2`\r\n* [Web Messaging](http://bulaoge.net/topic.blg?dmn=g3g4&tid=2370767)：包括\r\n  * `WebSocket`\r\n  * `Server-Sent Event`\r\n  * `Cross-Document Messaging`\r\n  * `Channel Messaging`\r\n\r\n### CSS 3\r\n\r\n* [color value](http://bulaoge.net/topic.blg?dmn=g3g4&tid=1999814)颜色值\r\n* [border-radius](http://bulaoge.net/topic.blg?dmn=g3g4&tid=1972499)：圆角矩形\r\n* [Bézier curve](http://bulaoge.net/topic.blg?dmn=g3g4&tid=1982054)：贝赛尔曲线\r\n* [Transform 和 Matrix](http://bulaoge.net/topic.blg?dmn=g3g4&tid=1981197)：几何变换和矩阵支持，不是黑客帝国里的变形金刚……囧\r\n* [Transition](http://bulaoge.net/topic.blg?dmn=g3g4&tid=2016439)：渐进变化\r\n\r\n### 相关demo与ppt\r\n\r\n最后，上述内容还有一些是通过demo和ppt分享给大家的，它们会被汇总出现在[all-demos](/all-demos/)和[all-slides](/all-slides/)这两个页面中。"},"10":{"title":"分享Typecho皮肤：我的字很大","slug":"theme-iambig","created":1332931165,"modified":1332931513,"text":"![截图](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2012/03/1377949152.png)\r\n\r\n没错，就是前面提到过的字很大的皮肤，我给这款皮肤起了个非常土的名字叫：“__我的字很大__”\r\n\r\n有几点说明：\r\n\r\n1. 侧边栏我隐藏掉了，并没有预留合适的位置，因为希望界面简介\r\n2. 搜索栏我隐藏掉了，但预留了位置，就是右上角，在`style.css`文件里去掉`#search {display: none;}`那一段就好\r\n3. 右下角的文字算是版权信息，是通过创建body的一个css伪元素实现的，略有一些技巧，如果大家觉得碍事，当然可以在css文件中去掉\r\n4. 对IE6效果做了简单的降级\r\n\r\n有需要的童鞋可以移步到这里[下载](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2012/03/3450849969.zip)"},"13":{"title":"分享Typecho插件：Markdown 解析器 + 编辑器","slug":"plugin-markdown","created":1332932985,"modified":1341389337,"text":"0. 该插件是在 明城 的“使用 Markdown 解析器”的基础上完善的。\r\n1. 使用 <a href=\"http://daringfireball.net/projects/markdown/\" target=\"_blank\">Markdown 语法</a> 编写和发布文章。\r\n2. 在正文上方加入了简单的格式按钮；\r\n3. tab键自动输入4个空格；\r\n4. 正文下方加入了预览功能；\r\n5. 在侧边栏加入了语法提示。\r\n\r\n下面是三张截图，一个是工具栏，一个是预览区域，一个是语法提示区域\r\n\r\n![工具栏](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2012/03/42147765.png)\r\n\r\n![预览](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2012/03/2658819400.png)\r\n\r\n![语法](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2012/03/2920005189.png)\r\n\r\n有需要的童鞋可以移步到这里[下载](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2012/03/1219206788.zip)，但__特别注意__：一定要放在`/usr/plugins/Markdown`文件夹下，其它命名可能会导致500错误(感谢大家的反馈，我之前没有注意到这个细节)。"},"17":{"title":"用CSS3制作尖角标签按钮样式","slug":"css3-tag-buttons","created":1333100078,"modified":1333102880,"text":"演示地址：[http://jiongks.name/demos/css3-tag/](http://jiongks.name/demos/css3-tag/)\r\n\r\n![CSS 3 tag demo](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2012/03/527861101.png)\r\n\r\n如图的效果。标签有背景色，且左侧有一个三角形，三角形中间有个白色的圆圈。\r\n\r\n* 你一定在想这个效果是背景图切出来的吧——答案是没有用到任何图片\r\n* 那你会不会在想这个效果的html结构很复杂呢——答案是最简单的html结构\r\n\r\n    &lt;p>  \r\n        &lt;a href=\"#\">Tag1&lt;/a>  \r\n        &lt;a href=\"#\">Tag2&lt;/a>  \r\n        &lt;a href=\"#\">Tag3&lt;/a>  \r\n        &lt;a href=\"#\">Tag4&lt;/a>  \r\n        &lt;a href=\"#\">Tag5&lt;/a>  \r\n    &lt;/p>\r\n\r\n之所以可以达到这样的效果，是因为我们运用了一些比较巧妙的技术。接下来告诉你实现方式：\r\n\r\n<!--more-->\r\n\r\n### 结构\r\n\r\n我们通过`a:before`和`a:after`这两个伪元素，通过绝对定位的方式，为`<a>`标签做了扩展：首先把一个伪元素`a:before`当做最左侧的三角形，然后再把另外一个伪元素`a:after`作为中间的小圆点显示到界面中。\r\n\r\n    a {\r\n        display: inline-block;\r\n        position: relative;\r\n    }\r\n    \r\n    a:before,\r\n    a:after {\r\n        position: absulote;\r\n        content: \" \";\r\n    }\r\n\r\n### 左侧的三角形\r\n\r\n三角形的实现方式略带技巧性，其实就是把宽高都设为0，边框宽度设为文本高度的一半。然后将其右边框上色`border-right-color`，其余三面边框颜色全部设为透明`tranaparent`，就可以了。当然，在设定边框宽度之前，我们需要确定文本的高度，这里有一个非常合适的单位：`em`。我们将链接的行高设置为`1.5em`，然后将伪元素的边框设置为`0.75em`即可。\r\n\r\n    a {\r\n        background: #ccc;\r\n        color: green;\r\n        line-height: 1.5;\r\n    }\r\n    \r\n    a:before {\r\n        border: transparent 0.75em solid;\r\n        border-right-color: #ccc;\r\n        top: 0;\r\n        left: -1.5em;\r\n        height: 0;\r\n        width: 0;\r\n    }\r\n\r\n### 左侧三角形中间的小圆点\r\n\r\n这个小圆点同样需要用css3实现，相比之下，它的实现略简单，设置背景为白色、宽高均为`0.5em`、上下边距均为`0.5em`、圆角半径是`0.25em`的矩形。这需要合理的坐标计算和尺寸计算。我们同样选择了通过`em`这个单位来计算。\r\n\r\n\r\n    a:after {\r\n        background: white;\r\n        width: 0.5em;\r\n        height: 0.5em;\r\n        top: 0.5em;\r\n        left: -0.125em;\r\n        border-radius: 0.25em;\r\n    }\r\n\r\n把这些内容凑在一起，会发现横向的距离会有些不合适，那我们再做一点微调：\r\n\r\n    a {\r\n        padding: 0px 10px;\r\n        margin-left: 1em;\r\n    }\r\n\r\n这样看起来样子比较协调了。\r\n\r\n### 鼠标悬停效果\r\n\r\n最后，加入`:hover`效果：\r\n\r\n    a:hover {\r\n        background: gray;\r\n        color: white;\r\n    }\r\n    \r\n    a:hover:before {\r\n        border-right-color: gray;\r\n    }\r\n\r\n这样，就大功告成了！  \r\ndemo: [http://jiongks.name/demos/css3-tag/](http://jiongks.name/demos/css3-tag/)"},"19":{"title":"网站装修笔记20120331","slug":"website-building-diary-20120331","created":1333208898,"modified":1333208898,"text":"今天给我的网站加入了著名的百度统计。对，就是下面这个东西：\r\n\r\n![页脚的百度统计](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2012/03/213230993.png)\r\n\r\n相信这个小家伙会帮我更加了解我的网站的读者。  \r\n虽然就是嵌入了一段脚本，不过幕后的工作不止于此。我在此做个备忘：\r\n\r\n1. 更深入的了解了一下Typecho的插件机制，经过群友的提醒，才发现Typecho源码中有一组辅助插件开发的代码，它们被汇总放在了`/var/Helper.php`中。也弄清楚了Typecho中的Widget机制和命名规律。这让我决定通过插件的方式加入百度统计。\r\n2. 我不在主题`footer.php`中直接加入百度统计，还有一层原因，就是为了保持主题的纯净，让主题可以被其他人也使用同时不被百度统计在内。\r\n3. 通过插件加入百度统计之后，我又想到，可否让这个插件也分享给更多的百度统计的使用者。而不同的使用者，统计码都是不同的，这就需要我们把统计码做成一个插件的参数，而不是写死在插件里。于是又了解了一下插件的参数设置方式，把统计码做成了插件的参数。\r\n4. 最后，我同时研究了一些Typecho的路由机制(Routing)和SAE的Storage服务接口，这为我给我的网站加入更多的单元或板块提供了更多想象空间。\r\n\r\n接下来的计划是把这个插件分享出来，然后重新梳理并设计一下网站的路由规则。\r\n\r\n以上"},"23":{"title":"分享Typecho插件：百度统计助手","slug":"plugin-baidu-tongji","created":1333384060,"modified":1333384161,"text":"1. 百度统计助手\r\n2. 只支持http协议，不支持https协议\r\n3. 在插件的“设置”里把统计代码最后的那串随机码填入保存即可\r\n4. 如果不开启统计，把填入的随机码清空即可\r\n5. 设置成功后页脚会多出一个百度的小图标\r\n\r\n### 使用步骤\r\n\r\n首先我们当然需要有一个百度统计的账号，然后通过这个账号生成我们要统计的统计代码(如下图)：\r\n\r\n![获取百度统计代码](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2012/04/2240219894.png)\r\n\r\n其中有一串随机码，我们把这串随机码记下来。值得注意的是，随机码前面有一个转意后的问号(`%3F`)，不要把这几个字符算入随机码。\r\n\r\n然后在插件设置中填入这串随机码(如下图)，即可正常工作。\r\n\r\n![插件配置界面](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2012/04/1123693821.png)\r\n\r\n有需要的童鞋可以移步到这里[下载](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2012/04/1884967606.zip)"},"26":{"title":"网站装修笔记20120406","slug":"website-building-diary-20120406","created":1333708193,"modified":1334641693,"text":"今天为我的新网站做了两件事情：\r\n\r\n* 第一件事是为我的主题皮肤加入了侧边栏显示，并使用了css3 media queries技术进行了响应式设计，并借鉴了一些metro ui的思路\r\n* 第二件事是加入了友情链接插件，可以在侧边栏显示一些自定义的链接，方便将来和博友们交换链接\r\n\r\n### 友情链接\r\n\r\n先说友情链接插件的事情吧，我在Typecho的插件站找到了一款友情链接的插件，名字就叫[Links](http://typecho.us/plugins/links-for-imhan.html)，非常方便实用。我现在随便放了3个链接，看看样子。大家希望跟我交换链接的，可暂时留言至此，回头我会另外做个交换链接的页面。\r\n\r\n![友情链接示意图](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2012/04/2077996433.png)\r\n\r\n### 响应式侧边栏\r\n\r\n然后是侧边栏，我把最近文章和最近评论两个侧边栏的widget加入了名为`large`的css class。这类widget会在条件允许的情况下占用更大的空间。一般情况下宽度是普通widget的两倍。在一些特殊的界面宽度下，widget的宽度是一样的，大家没有什么分别。\r\n\r\n对于css3 media queries的利用，我这里按窗口宽度分了5档1400px+/1050px+/650px+/400px+/400px-，进行响应式设计。每一档的内容宽度、侧边栏宽度和布局都不太一样。以适应不同的终端。举其中一个例子(1050px~1400px之间)：\r\n\r\n    @media all and (min-width: 1050px) and (max-width: 1400px) {\r\n        #wrapper {\r\n            position: relative;\r\n            padding-right: 280px;\r\n        }\r\n        #sidebar {\r\n            position: absolute;\r\n            width: 260px;\r\n            top: 160px;\r\n            right: 0;\r\n        }\r\n        #sidebar .widget,\r\n        #sidebar .large {\r\n            width: 98%;\r\n        }\r\n    }\r\n\r\n\r\n最终效果如图：\r\n\r\n![响应式设计预览](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2012/04/394641605.jpg)\r\n\r\n这款皮肤我会稍后更新共享在这里。\r\n\r\n另外我最近抽空研究过了SAE Storage，接下来的事情是做一些有趣的侧边栏小控件出来，比如投票、相册、之类的。\r\n\r\n先记下这么多"},"27":{"title":"网站装修笔记20120414","slug":"website-building-diary-20120414","created":1334370384,"modified":1334370859,"text":"这周主要把我的几个HTML5幻灯片做了一下整理，在[这里](/all-slides/)。从这次播放器的实现上看，幻灯片数据的结构约定有所改变，同时适配了更多的浏览器和设备。\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2012/04/694138118.png)\r\n\r\n在这个过程中，我也尝试了更多CSS3的变换效果，让幻灯演示多一点精彩，所以最终我为每个幻灯演示分别使用了不同的幻灯片切换动画。有3d的、有2d的，也有WP7中的Metro风格动画等等。\r\n\r\n另外说到幻灯演示，我正在发起一个这方面的开源项目(估计经常关注我的朋友都已经听腻了)，本月之内会启动。\r\n\r\n接下来我想给网站做一个投票系统，放在侧边栏。"},"29":{"title":"分享bookmarklet一则：随意阅读","slug":"bookmarklet-read-anything","created":1345471240,"modified":1345474017,"text":"这款bookmarklet是我对主流阅读模式智能识别规则的一种吐槽。\r\n\r\n当然，首先，阅读模式本身是一项非常棒的功能！他可以增强文章的阅读体验，统一不同页面的视觉风格。可以让人专注在文章内容中。等等。\r\n而我要吐槽的点，是这个所谓的“智能判断文章内容”的算法。\r\n\r\n### “智能分析”的阅读器\r\n\r\n阅读模式的核心任务之一，就是能够找出我们在各种凌乱广告、装饰物、页眉页脚之中的正文内容。在找内容这件事上，大家不约而同的使用了智能分析的路数。[这里](http://code.google.com/p/arc90labs-readability/source/browse/trunk/js/readability.js)是早期开源的Readability脚本库的核心代码，我们可以看到其中包含着大量用来识别某dom结点是否是正文根结点的算法公示。而这套算法，又是从大量已存在的网页中归纳而来的。\r\n\r\n![Readability](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2012/08/3234165205.png)\r\n\r\n#### 阻力\r\n\r\n既然是归纳的结果，而现如今已存在的网页已经数以亿计五花八门了，那不可避免的会存在判断误差。我们希望把内容识别的准确率提到最高，但会遇到一个问题：就是广告主、站长都有各自的小算盘，他们时刻准备着违背这些智能，降低判别的准确率，不让它正常工作，以谋取自己更高的收益或二次点击率。因此，这一智能的识别规则无法完全公开(Readability随后停止了开放源代码，我猜也有这方面的考量)。\r\n\r\n#### how to enable?\r\n\r\n可黑盒的智能规则又导致了另外一个问题：智能识别如果出现判断误差，对于那些希望支持阅读模式的网站，又无奈于找不到这些计算规则去适配。于是我们又会看到类似“[how to enable safari reader](http://www.google.com/search?q=how-to-enable-safari-reader)”这样的问题满天飞。\r\n\r\n![Google搜索截图：如何激活阅读模式](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2012/08/938520538.png)\r\n\r\n最后阅读模式的识别规则、支持者、反对者扭打在了一起。\r\n\r\n<!--more-->\r\n\r\n### “智能分析”的弊端\r\n\r\n所以，归纳起来，智能识别的劣势有两个：一个是无法100%判断准确，这样无法完全满足用户需求；一个是面临多方面利益的冲突和挑战，这样会阻碍其快速发展和完善。\r\n\r\n### “随意阅读”的理念\r\n\r\n我们希望网页上的任何内容，只要是值得认真看一看的，都可以提供“阅读模式”的体验——就像iOS中屏幕上的任意区域被双击之后都可以智能缩放到合适大小一样。所以我们可以给用户另外一种“阅读模式”，它可以让用户主动选择想阅读的区域，然后把用户选中的区域设定为阅读器的正文。\r\n\r\n__有了这个东西，智能规则的压力会减小；支持者不必担心自己的内容无法很舒服的被用户阅读；挑战者也无计可施。一举三得！__\r\n\r\n### 技术实现\r\n\r\n1. 首先，准备一套易于阅读的css样式。我直接利用了自己blog的主题，同时把文字区域的最大宽度固定在800px。\r\n2. 然后，让用户可以通过鼠标选择页面上的一个box，并高光显示，作为内容根结点的识别。之前我写过一个简单的dom inspector的例子，现在刚好用上了。\r\n3. 接下来要做的，就是把页面上的其它内容“藏起来”，把网页中原有的样式去掉，把我定义好的css样式潜入。\r\n4. 最后，把用到的资源放到网上，把脚本入口做成bookmarklet。大功告成。\r\n\r\n[demo](/demos/dom-inspector/)\r\n\r\n### 改进空间\r\n\r\n随意阅读并无法取代现有的阅读模式，但会让阅读这件事变得更完整。同时，我们可以改进的地方有很多：\r\n\r\n1. 第一，bookmarklet中的alert体验显然是可以优化的。\r\n2. 第二，开始阅读之后，原有的网页都被“覆盖”掉了，如果在阅读过后还想有后续操作，可以考虑把阅读器在新窗口打开。\r\n3. 第三，用户在选择阅读区域的时候，是没有鼠标hover交互效果的，这里我写的dom-inspector不太够用了，没有深入进去。也是一个优化的空间。\r\n4. 第四，我们有很多外延的功能可以加入，比如“超级下一页\u001b”、全屏模式、分享、评论、打印等等。"},"31":{"title":"网站装修笔记20120426","slug":"website-building-diary-20120426","created":1335423322,"modified":1335423322,"text":"按照严计划，给我的网站加上了投票功能。他已经出现在了网站的侧边栏中。当然在[某些media queries](/blog/website-building-diary-20120406/)条件下，这些内容不在侧边，而在网页的最下面。\r\n\r\n这从没有花太多时间在编码上。我直接引入了三方的问卷调查工具：[Wufoo](http://wufoo.com/)。等于嵌入了一个iframe。我会定期更换这里的投票内容，有些投票可能是为了我更了解大家，更好的优化我的网站为大家服务的，我会根据大家的反馈默默做出改变；而方便公开的统计数据和分析结果，我也会公布在这里跟大家分享。\r\n\r\n第一期的投票内容比较“肤浅” 囧\r\n\r\n![您觉得现在囧克斯的皮肤好看吗？](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2012/04/4080396881.png)\r\n\r\n在添加投票功能的时候，我注意到Typecho的一个不足，就是在创建新的侧边栏面板的时候，不免需要修改主题模板的sidebar.php文件，因为Typecho本身并没有给侧边栏预留插件接口，所以不可以生成自定义的侧边栏面板。我觉得改进的方式可以是这样的：\r\n\r\n1. 创建新的配置项，注明要显示的侧边栏面板和排序；\r\n2. 同时封装面板的html结构，不允许自定义面板结构，只允许自定义内容；\r\n3. 然后在Plugin一边加入自定义面板的接口。\r\n\r\n这样主题模板和插件就进一步解耦，开发者就可以在不改动主题模板的情况下调整侧边栏的内容了。\r\n\r\n一点个人心得，不知Typecho是否愿意接纳这个意见。\r\n\r\n以上"},"32":{"title":"学习精髓","slug":"how-to-learn","created":1337588662,"modified":1337618221,"text":"首先，很久没写blog了，最近小忙，今天下午难得清闲，把最近的一些思考写下来。\r\n\r\n如何学习XXX？是一个在我周围经常听到和谈论的话题。\r\n\r\n比如，如何学习JavaScript，如何学习HTML5，如何学习移动开发。我发现，在这个知识爆炸的年代，人们汲取知识的方式确实非常多元化，有人选择看书，有人选择上课，有人选择实践，有人选择逛微博，有人喜欢订阅RSS，有人喜欢跟牛人交流。。。\r\n\r\n从形式上看，他们都各有优劣，我也确实觉得因人而异，因需求而定。同时，学习的内容非常关键，学习的态度也非常关键。\r\n\r\n首先，我觉得最正统的学习，自然是边看书，边实践，理论与实际相结合的。书，最好是比较系统的，优质的，经得起推敲和实践考验的；实践，最好是简明的，直观的，循序渐进的。\r\n\r\n但这样的学习，要想保证效果，势必需要一些整块的时间和精力，需要耐心和专注：这似乎在大学毕业之后，就比较难了。\r\n\r\n我们在高节奏的IT生活中，似乎很难沉住气，于是我们见到了更多“入门级”或“速成”的学习内容，不求深度和广度，但求迅速上手，迈出第一步。再往后，或许生活节奏更快了，人们压力也更大，似乎“速成”都不够快了，人们把之前一本书的东西，浓缩成了一篇文章。。。然后，抽象成“十大要点”。。。最后，变成了一条微博。。。\r\n\r\n请允许我以这样的方式归纳如今主流的学习方法吧。尽管并不完备。\r\n\r\n我记得自己在Web标准化交流会，被裕波第一次建议分享的技术话题，就是[《前端工程师如何学习JavaScript》](http://www.slideshare.net/jinjiang/learning-javascript)，那会儿我的想法是，要因人而异，选择不同的内容和方式，大块的新东西，要“啃骨头”，沉住气，要不得半点马虎；已经有一定基础的情况下，可以选择“吃零食”，日积月累，汇流成河。今天看来，我依然是这么想的，但如果方法不对，会很痛苦，或事倍功半，或无法坚持。\r\n\r\n而学习的另一个要素，则是内容。有的时候，跟同行朋友交流时，会遇到这类的讨论：我记得好像有人说过这样是不行的（不好的）、XXX（某名人或某本书）说这样是最好的方案。可有的时候，这些观点并不绝对，它可能是片面的，或是过时的，甚至是复述的人记错了理解错了，甚至它本来就是错的。当这样的讨论频繁出现时，我觉得出了问题：首先，他们在学习知识的时候，没有足够的基础，导致无法辨别上层知识的真伪；二来，对知识的学习缺乏深究的精神，知其然不知其所以然；第三，没有找到真正的起点。\r\n\r\n导致这些问题的因素可能是多方面的，比如很多基础的材料是英文的，而语言障碍多多少少客观存在；比如我们的视野总是有限的，比如周围的人都是“那样”学来的。可真正的精髓，就这样被错过了，实在可惜。\r\n\r\n作为比较普世的道理，我觉得有几件事值得我们参考：\r\n\r\n首先，要追根溯源，我想得到的途径有三种，看官方文档，读源码，拜读技术发明人或创始人的书籍，这些都是原汁原味的，不经其他人转述，没有信息偏移和衰减的（说道这里，大家应该见人玩过那种“传声筒”的游戏吧，一句话经过五个人传到最后，变成了完全不同的另一个意思，就是这个信息偏移和信息衰减的道理）。\r\n\r\n然后，开放自己的心态，多多参与更广泛交流，避免被狭隘和片面的观点所误导，关于这一点，国内有好多线上线下的技术交流活动，如果大家有心参与，应该足够了（不过，虽然不太严重，但值得指出的是，国内和国际的技术认知还是会有些许偏差，必要的情况下，要走出国门，做跨国交流）。\r\n\r\n所以，还有第三点，英文太TM重要了！而且是基础中的基础！\r\n\r\n有了基础，了解了本源，开阔了视野，然后再不断积累零散琐碎的知识，此乃成才成功之道。我们能有多大作为，一个重要方面，取决于我们做了多少准备，下了多少功夫。\r\n\r\n再说得远一点，技术立本的公司的发展和生存，也需要紧跟趋势，深刻理解行业标准和规范，才有可能真正做到技术领先，甚至技术超前，引领行业趋势和行业标准。\r\n\r\n以此作为2年前“如何学习JavaScript”话题的延伸和二次思考。"},"33":{"title":"听杨东杰弹吉他","slug":"meet-yangdongjie-in-chengdu","created":1337976494,"modified":1337982702,"text":"这是一个灰常活泼并且有怀旧感的标题。\r\n\r\n原本打算记我上周末成都之行的一篇日志，我觉得除了参加HTML5梦工厂成都站的技术交流活动之外，最大的收获，莫过于同杨东杰童鞋的畅谈。另外今天连续在微博上看了两个罗纳尔多和萨内蒂年轻时候的足球集锦，突然觉得这几年间，很多事情在发生着悄然的改变，比如曾经有个美少女组合叫S.H.E，昨天在地铁外看到Ella的一个活动海报，才发觉，这个团早已淡出了我们的视野。我们上大学的时候，有几个舍友特别喜欢挺S.H.E，导致我也比较熟悉他们的歌曲，后来让我对他们真正产生印象的是《Play》那张专辑，觉得它的概念蛮有意思的，整张唱片都是轻松欢快的气氛。于是《听袁惟仁弹吉他》这首歌一闪而过，于是就有了这个标题……\r\n\r\n有点扯远了\r\n\r\n<!--more-->\r\n\r\n### 聊成都\r\n\r\n[杨东杰](http://www.weibo.com/u/1650646635)是前CSDN移动频道的主编，之前见过几次面，但没怎么细聊过。这次我去成都参加活动，他也刚好跑到成都出差了，我们就这样不期而遇。估计后面的东西我会写得有点像采访稿，呵呵，估计杨兄采访过那么多人，被采访的经历不太多吧，另外像这种通篇没什么他的观点都是我自己的观点的采访估计也几乎没有过 :-)\r\n\r\n说起成都，第一感觉是这里的生活压力会相对小一些，其次是成都的美食、美女、美景，然后就是戏称“离方舟比较近”。杨兄对于这三点有多兴奋，去看看他的微博就能感受到了。\r\n\r\n然后是成都的天府软件园，我想说这个软件园足以构成一个独立的城市了。好大一块地，而且是全新的，和成都的其它区域有着明显的界限。关于成都的IT行业有两个特点：一个是很多大的互联网公司都已经开始在这里“圈地”了；另一个是有很多小的创业公司享受到了当地政府的扶持和优惠政策，拥有优越的创业环境。所以总体上感觉，成都的软件业还处在一个比较基础的阶段，未来的潜力和发展空间都是巨大的。\r\n\r\n### 聊互联网\r\n\r\n我想说杨兄在CSDN的视野非常开阔，也有很多独到的见解。这次交谈，我们聊到了很多互联网的话题，诸如国内微博运营、开放平台、移动应用趋势等，受益良多。其中一个话题印象深刻，是和起点中文网有关的，杨兄反复称赞这个网站不得了，通过起点中的文学作品，可以看到很多现状和未来，很多被认为是“高端”的人士，其实都在默默关注起点上的作品。所以这绝对是一个被低估的网站，而盛大也是一个被外界低估的企业。另外，说到这里，确实喜欢看书的中国人太少了，我自己也应该多看点书。\r\n\r\n这里还想插播一则别的事情(越来越不像采访了 - -)，这次在成都还有幸造访了中国电信的基地，他们的天翼空间也正在对HTML5跃跃欲试，跟这边的朋友也聊了很多，发现他们虽然主营业户是电信，但对HTML5非常感兴趣，也非常了解互联网这个圈子。现在真是越来越多的人，越来越多的领域加入到了移动互联网和HTML5当中来了，未来的互联网会更丰富、更精彩、更多元化。\r\n\r\n### 聊个人发展\r\n\r\n还聊到个蛮有趣的话题，就是如何提高英语水平。刚好杨兄经常在WebAppTrend翻译英文的技术文章，我也刚刚出国开了一个W3C的会，都有各自的心得和困惑，聊到很多有趣的经历，不亦乐乎。还有就是如何看待创业这件事，杨兄说，在今天的中国，你去创业，是没有“失败”的——即使公司失败了，对个人而言，一定有很多收获，绝对不算失败。我确实觉得创业这种事不是一般人能做得来的，因为有太多事情要照顾到，相信这样的经历一定会让人快速的成长。所以，他也非常看好成都这个地方的创业者们，看好成都的发展。\r\n\r\n再就是些生活习惯和生活态度的话题，最近“屌丝”这个词非常火，他也说了说自己的屌丝心态之痛，叛逆和对主流的质疑都不足矣导致不好的结果，但关键是要让事情带入一个良性的循环，走向更宽阔的道路。不然这个代价在时间的面前是非常惨痛和巨大的。这是一种“剪刀差”式的变化。\r\n\r\n差不多就是这些了。最后，国王杯比赛快结束了，巴萨遥遥领先，比较无聊。略显无厘头的日志也要结束了。其实关于我们聊天的内容，这里都先点到为止，就不细说了。希望杨兄在未来有更好的发展。希望成都有更好的发展。这也算是我对这次的成都之行有个回顾吧。\r\n\r\n完毕"},"35":{"title":"“思考人生”","slug":"think-about-life","created":1339702437,"modified":1339702810,"text":"前几天欧洲杯，“巴神”巴洛特利一个散步式单刀被后卫回追成功，解说员戏称他停下来思考人生了，一时间“思考人生”变成了个热门词，以至于我们看到谁发呆、低头，都说他们在“思考人生”。其实我最近也在思考人生，也许比他们的严肃一些了。\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2012/06/1876065904.png)\r\n\r\n来北京的第6年，同时也是在傲游的第6年，一转眼小半年快过去了。\r\n\r\n这半年过得算是波澜不惊吧，事情异常多，公司的，家里的，亲戚朋友的，各种活动的，还狗屎运[出了一趟国](http://www.w3.org/QA/2012/06/interview_huawei_maxthon_qihoo.html)。总会有些事情照顾不周，处理不妥，也在意料之中。我只想说：感谢经历，你就自己想办法挺过去吧。\r\n\r\n在这不到6年的时间里，我一直没有停止做一件事，就是不断努力发现自己的问题和不足，并尝试改变它——相信很多人也都会这样。这期间有些改变是令我兴奋的；有些事情是立竿见影的，富有成就感的；还有很多事情，在潜移默化的发生着，你无法通过一两件事情看清楚，但经过长时间的积累，暮然回首，你会发现，它真的变了，有好的也有不好的。\r\n\r\n<!--more-->\r\n\r\n### 毅力不足\r\n\r\n前阵子看《锵锵》，老窦聊起减肥食谱，说有一次问医生道：\r\n\r\n> 究竟有多少人能按这个健康食谱坚持下来呢？\r\n\r\n答曰：\r\n\r\n> 工作上能成事儿的，基本能坚持下来。\r\n\r\n从这个角度讲，我发现今天自己比较满意或比较有成就感的事情，基本也都一直坚持着了。那些自己不满意的地方，平时也确实是三天打鱼两天晒网。这似乎也没什么好讲的。\r\n\r\n### 精益求精\r\n\r\n于是乎又想起自己上大学的时候，跟已毕业多年的一位学长聊天，学长说道：\r\n\r\n> 大学同学多年后聚会会有人问别的老同学：“以前在班上咱俩的差距无非也就是我考个85分，你考个90分，没啥感觉啊？怎么现在两个人的发展差距这么大呢？”。其实这说明了一个问题，你做每件事都用85分要求自己，这会形成习惯，而别人都用90分要求自己，一两次考试确实看不出啥差距，可时间长了，剪刀差的差距就明显了。\r\n\r\n对于人生，我们的态度究竟是多少分呢？对我来说，通过6年的时间，我隐约看到了一些答案。再加上那些没有坚持下来的事情，我觉得自己的生活状态必须有所改变了——如果我还有梦想的话。\r\n\r\n### 打好基础\r\n\r\n何为基础呢？如果学好A可以让你更快的掌握B，那大体上A应该算是B的基础吧。如果希望事半功倍的学习，有的时候似乎不能由着自己的性子，想起什么就去学什么，而是找到那个最大的A。对于现在的我而言，这个最大的A似乎是英语。正如我之前思考[如何学习](http://jiongks.sinaapp.com/blog/how-to-learn/)时想到的那样，英语太TM重要了！\r\n\r\n除此之外，几个基本的计算机学科也是我接下来深入学习的对象。这些东西的价值，在多年后的今天、自己熟悉的领域，可能不太明显了，因为已有大量的经验可供参考。但是在处理更复杂或跟广泛的问题时，才发掘自己搞不定更多事情了，琢磨一个在别人看来入门级别的程序，都要搞很久，这种感觉真是糟透了……\r\n\r\n也许对于一个前端开发来说，为不懂浏览器内核或后台服务器编程而忧伤算是一种强迫症吧。后来我仔细想了想，这些糟糕的感觉之所以出现，是因为给自己定了一个更高的目标吧，这不是什么坏事。每次想到这里，自己又重新振作了起来。\r\n\r\n### 用好时间\r\n\r\n一方面是要把各方面的时间协调好吧，有意识管理自己的事务和行程；另一方面也希望自己可以对事情的轻重缓急始终有一个清醒的认识。我尤其觉得自己在电脑面前管不住自己 囧。这体现在自己不愿意起身做别的事情，有严重的拖延症；还有就是总是没法早睡早起(比如今天)、吃规律的早餐；还有就是总想着开TMD微博、人人网、网易体育和直播吧……\r\n\r\n### 良性循环\r\n\r\n如果一个生活状态可以让自己变得更好，那么就去保持这个状态吧。否则，改变是刻不容缓的。\r\n\r\n### 保持乐观，心无杂念：）\r\n\r\n有句广告语是：“心情好，一切都美好！”。世界总会有纷乱，悲观的人会被击垮，乐观的人会重生。过往云烟，留下来的才是自己的。尽量把问题想的远一些，并坚定信念。\r\n\r\n以上"},"36":{"title":"ZeroClipboard 学习笔记","slug":"zeroclipboard-intro","created":1343508080,"modified":1345473948,"text":"如题，周末抽空学习了一下。\r\n\r\n[ZeroClipboard](https://github.com/jonrohan/ZeroClipboard/)是在桌面电脑的浏览器上，通过flash技术实现“复制到剪切板”功能的一个程序。它的好处是可以兼容所有浏览器，完成剪切板的操作。\r\n\r\n我们在使用的时候主要就用到两个文件：一个是js文件`ZeroClipboard.js`，用来引用在网页中；另一个则是swf文件`ZeroClipboard.swf`，它无需我们在代码里引用，而是被之前的那个`ZeroClipboard.js`二次调用的。\r\n\r\nZeroClipboard的工作原理大概是，在网页的“复制”按钮上层遮罩一个透明的flash，这个flash在被点击之后，会调用其的剪切板处理功能，完成对特定文本的复制。这里有几件事需要我们来完成：\r\n\r\n1. 创建一个透明的flash\r\n2. 将这个flash浮在按钮上层\r\n3. 确定要复制的文本是什么\r\n4. 监听这个透明flash的鼠标点击事件\r\n5. 该flash被点击之后，完成剪切板处理\r\n\r\n对于这几件事，ZeroClipboard分别提供了不同的api，来完成整个需求。\r\n\r\n<!--more-->\r\n\r\n### 创建flash\r\n\r\n创建的过程其实就是一个`var clip = new ZeroClipboard.Client()`的过程，这时`ZeroClipboard.swf`会被载入。值得注意的时，这里的swf文件默认需要放在和网页相同的目录下，且文件名固定。如果我们需要移动这个swf文件的位置或改名，则需要在创建swf文件之前运行：\r\n\r\n    ZeroClipboard.setMoviePath( 'http://YOURSERVER/path/ZeroClipboard.swf' );\r\n    或\r\n    ZeroClipboard.setMoviePath( './src/ZeroClipboard.swf' );\r\n\r\n里面的参数可以是相对地址也可以是绝对地址。\r\n\r\n### 将透明flash浮在按钮上层\r\n\r\n这里有一个很有趣的英文单词：__glue__。我们可以通过下面这个api，将flash和按钮重叠，且浮在按钮之上：\r\n\r\n    clip.glue( 'clip-button-id' );\r\n    或\r\n    clip.glue( document.getElementById('clip-button-id' ));\r\n\r\n即第一个参数为id或dom对象都可以。如果按钮在网页运行中位置发生了变化，flash是不会自动调整位置的，为此我们提供了另一个api可以手动更新flash的位置：\r\n\r\n    clip.reposition();\r\n\r\n#### flash的相对浮动\r\n\r\n这里还提供了一种更巧妙的方式：如果按钮的上层有任何`position:relative`的块状元素，比如div，而按钮和这个块状元素的位置又是相对固定的，那么可以在调用`glue`函数时，将这个div的id作为第二个参数传进去，不过同时`reposition`这个api就失效了。比如：\r\n\r\n    clip.glue( 'clip-button-id', 'clip-container-id' );\r\n\r\n### 设置要复制的文本\r\n\r\n这一步很简单：\r\n\r\n    clip.setText('要复制的文本在这里');\r\n\r\n### 监听事件\r\n\r\n通过addEventListener进行事件绑定，可以绑定的事件有以下几个：\r\n\r\n* `onload`：flash文件加载成功\r\n* `onmousedown`：鼠标在flash上按下\r\n* `onmouseup`：鼠标在flash上释放\r\n* `onmouseover`：鼠标经过flash\r\n* `onmouseout`：鼠标移开flash\r\n* `oncomplete`：剪切板操作完成 (用鼠标点击该flash浮层的时候会触发事件复制到剪切板)\r\n\r\n### 剪切板操作完成之后可以通过api销毁flash\r\n\r\n    clip.destroy();\r\n\r\n[DEMO](http://bowser.effectgames.com/%7Ejhuckaby/zeroclipboard/)  \r\n[更多细节和高阶操作的介绍](https://github.com/jonrohan/ZeroClipboard/blob/master/docs/instructions.md)"},"37":{"title":"国际羽联和中国队之间的恶性循环","slug":"badminton-and-vicious-circle","created":1344107149,"modified":1344107717,"text":"直观的感觉是这次“冷”敦奥运会上，国际上对中国集体发难。这样的感觉起码有这些因素作祟：第一，自从北京奥运会中国在家门口历史上首次拿到金牌第一，国际媒体就开始越来越关注中国；第二，以前我们都陶醉在某些洗脑工具中，听不到国外的声音；第三，称赞中国的声音不够劲爆，我们的舆论也有选择性的把更多偏激的言论带回了国内；第四，新媒体全面占领传统媒体，消息更快速，也更不准确；第五，我们喜欢“拿来”，却不喜欢回馈。\r\n\r\n<img src=\"http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2012/08/1497762744.jpg\" alt=\"144261153.jpg\" />  \r\n图片来自和讯新闻\r\n\r\n话说这次奥运会4对羽毛球选手被判消极比赛取消资格一事，绝对是国际羽联对中国长期以来忍无可忍的一次报复。毫无疑问中国现在在羽毛球这个项目上太过强大，尤其是女双，强大到对手连打败你的信心都没有了。这样的话选手的成绩在淘汰赛制中变得偶然性很大：第一轮就碰中国，名次肯定倒数，晚点碰中国，甚至可以拿奖牌。\r\n\r\n我猜国际羽联把羽毛球由纯淘汰赛改成循环赛加淘汰赛，这也直接导致了这一出闹剧的出现。其实规则的改变就是给那些名次不好的人更多机会，给中国队更多危险。__但我不认为这是一种良性的改变__。\r\n\r\n<!--more-->\r\n\r\n### 首先，奥运精神是更快、更高、更强。\r\n\r\n我们希望在奥运会看到的是全人类的突破，把优秀的成绩变得更优秀，再优秀，不断突破自我，战胜自我。可国际羽联这样的改变只是单纯的为了“照顾弱者”而放慢优秀者的脚步，这同时也放慢了全人类的角度——你觉得人类不可能把羽毛球打得更好了吗？外国打不过中国，应该更多从他们自己身上找原因，想通过规则打败中国，只会让他们变得更加不堪一击。\r\n\r\n### 其次，我们之前也见过一些别的运动，因为有一个个体或队伍太强，而修改规则，限制强者发挥的情况。但都是针对比赛内容的，而不是赛制。\r\n\r\n比如，NBA历史上就多次因为限制个别“变态”球员而[修改规则](http://www.espnstar.com.cn/pub/basketball/2011/0602/224522.htm)，感兴趣的还可以再查查[张伯伦改变了多少NBA规则](http://wenwen.soso.com/z/q106847779.htm)，离我们比较近的则是乒乓球总在改规则：把乒乓球变大变重，发球不能遮挡等等。\r\n\r\n这两者差在哪里呢？改比赛内容的话，也算是让运动员挑战更高的极限，比如三分线变得更远了，就需要你有更精准的投篮才行；可修改赛制，对这项运动本身的发展有何帮助？\r\n\r\n### 第三，我觉得循环赛不适合差距悬殊的较量，循环赛往往是竞争激烈且过程复杂的运动才有的。\r\n\r\n* 比如团队运动，如足篮排三大球，一堆人忙活半天，一场比赛就回家了，直观的感觉去一趟很不值；而且这些运动对抗性强竞争激烈，实力相当，比赛变数多，运气成分也大，所以起码让你小组赛多打几场，检验成色。\r\n* 再比如田径射击游泳举重项目，成绩是很客观的，谁快谁慢一眼就看出来了，没必要总是1v1循环。\r\n* 再有就是网球，就一个或两个人比赛，盘局设计让比赛的悬念和优胜劣汰巧妙的达到平衡，同样是大淘汰赛制。\r\n* 其实羽毛球的运动性质和网球的情况很相似。所以循环赛的安排违背常理。\r\n\r\n### 从上述三点看，国际羽联只能拿出一个合理的解释：不择手段影响中国队。\r\n\r\n以前我们说规则是死的，人是活的。可今天连规则也开始变了，那么请允许我认为：在规则的“怂恿”下，中国、印尼、韩国的这几对选手被迫需要面对这样的尴尬。在这种规则下，给了谁，站在今天中国队的位置，都无法忽视规则与利益之间的矛盾冲突；而印尼和韩国呢，__如果今天刚好是马来西亚选手和中国队交锋，大家觉得马来西亚球员会不会做出同样的事情？我想还是会__，因为__在一个恶劣的体制下，每个人都会成为“共犯”中的一员__。\r\n\r\n我再举个例子：自己遇到红灯却眼瞅着要迟到了，看马路上的人都闯红灯过去了，你心里会不会痒痒的？\r\n\r\n就算不是每个人都会真正去做，至少这是一个正常人都会产生的尴尬。从这个角度讲，造成今天的局面，国际羽联难逃其咎。\r\n\r\n### 当然中国队也长期做得很过分，我同样觉得这也是恶性循环的一部分。\r\n\r\n我们的运动员真的是为了更高、更快、更强的奥运精神在参加奥运会吗？还是国家尊严、个人名利这些跟奥运精神比起来显得低俗下流的东西？索性很长一段时间这两件事对我们来说是完全重合的，所以不怎么深究。__今天国际羽联就给了我们一把尺，在这把尺上，我们的丑陋被人家捉个正着__。就算国际羽联是刻意的，我们也没有经得住“考验”。\r\n\r\n而在金牌至上的长期思想下，即使个人有那么一点冲动和想法，也被大环境打磨掉了。\r\n\r\n另外，当天确实假得太过分了。观众不买账了，事情才闹大的。这也是恶性循环的一部分。\r\n\r\n### 最后，大家一起毁了羽毛球……\r\n\r\n__这样的恶性循环还要在我们的身边上演多少次？！__"},"39":{"title":"HTML5峰会归来","slug":"html5dw-2012","created":1345394051,"modified":1345473989,"text":"这次 [@HTML5梦工场](http://weibo.com/html5dw) 的活动真是太棒了！我们了解企业，了解同行，了解技术，了解趋势，吃喝玩乐，雅俗共赏，天南海北共聚一堂，还有什么活动能跟这样的 [#html5峰会#](http://2012.html5dw.com/) 相媲美呢？！虽然2天脚都站酸了，但真心觉得值！\r\n\r\n### 了解企业\r\n\r\n这次\u001d峰会上，诸多企业都在会场搭建了属于自己的展台：有浏览器，有应用平台、有技术图书出版社，这样不够，后台技术来了，电视来了，物联网来了，广告服务来了，这样还不够，更夸张的是眼镜和糕点也来了。其实仔细想想，中间这部分领域是早晚要和HTML5打交道的，而后面这部分呢，也几乎是每一个前端工程师生活的一部分(你看，干这行的视力都不太好，还经常以庆祝xxx为借口买蛋糕吃)。我们了解形形色色的行业和企业，体验工程师生活的每一部分。\r\n\r\n当然说到企业展台，这也包括我的老东家傲游。今年公司启动了全平台的浏览器研发项目，除了已经有的PC、安卓版本，还陆续发布了Mac、iPad、iPhone版本。所以这次的展台内容很丰富，有些朋友甚至来到展台前把所有的设备都试用一遍，才意尤未尽的离开，这让我们这两天“辛苦站台”的同事们倍感欣慰。\r\n\r\n![傲游浏览器的展台](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2012/08/1544819964.jpg)\r\n\r\n### 了解同行\r\n\r\n我想说第二天的HTML5作品展真棒！一口气看58份优秀作品，结识58组前端精英，感受大家的创意和热情！这次给我印象深刻的，有一个是用Canvas写毛笔字的，可以根据书写的速度模拟出毛笔的力道来，非常神奇；还有一个作品用到了最新的摄像头媒介接口，做出了类似Kinect的游戏体验，他们的作者自豪的说：“我们的目标就是秒杀Kinect！”；另外我非常有幸结识到了HTML5图形库[ichartjs](http://www.ichartjs.cn)的作者，我觉得他的作品像一阵及时雨，刚好填补了图表制作这个HTML5非常大的领域空白。除此之外的其它作品也都各有千秋，看得出他们呕心沥血的投入和付出。\r\n\r\n![H5Slides](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2012/08/186888587.png)\r\n\r\n我也有机会展示了自己参与的一个开源项目：就是[H5Slides](http://h5Slides.com)，我们专门为了这次的峰会搭建了一个供大家试用和体验的网站。不少开发者也对我们的作品产生了浓厚的兴趣。还有些人在网上看到过，现场认出我来了，哈哈好害羞滴说！\r\n\r\n<!--more-->\r\n\r\n### 了解技术\r\n\r\n周六下午的五大专场，安排的都满满当当，我主要参加了其中的两个：浏览器、前端开发。\r\n\r\n浏览器这边对罗志宇和我们公司小红姐姐的分享印象深刻，一个是从底层实现的角度看前端性能，受到了很多启发，尤其是“CSS其实就是个和DOM多度多匹配的数据库”这点我一直没有悟出来，也没想到由此推衍出的性能话题，罗的话一语惊醒了我；另一个则是从应用角度看Web标准，嘿嘿，当然也是因为这是我们自己的声音嘛，小红在介绍我们内核研发工作的同时，也把我自己的工作内容描述的很优美很伟大，听完脸上有光:-)\r\n\r\n前端开发这边看到了会前听 [@adamlu](http://adamlu.com) 推荐给我的鸡尾酒(Cocktails)框架，听口音是一位来自台湾的工程师介绍的，讲得很精彩也很幽默。[@苏震巍](http://weibo.com/jeffreysu1984) 的话题我赶上个尾巴，没听全，小可惜。回头等PPT全公开了我打算挨个儿下载看看。听说还有老外用中文讲技术，这是多么刺激的事情 XD\r\n\r\n### 了解趋势\r\n\r\n这次从TV专场的成功举办可以看出，智能电视已经在为HTML5跃跃欲试了。加上前阵子参加了一个三星的智能电视的沙龙，和现场的朋友们进行了很多的互动，总体的感觉是智能电视的厂商都算是比较传统的厂商，在与HTML5相遇的时候，产生了很多有趣奇妙的火花。投资人、HTML5开发者、软硬件厂商聚在一起的时候，话题总是那么精彩。看到移动互联网这么火热，大家都坐不住了。哈哈\r\n\r\n还有就是大会开场时提到的HTML.next话题，我们应该庆幸自己处在一个Web技术日新月异，高速发展的时代，亲身参与和感受这样的变化。别以为HTML5就是终点了：“成功？我才刚上路呢”\r\n\r\n### 吃喝玩乐，雅俗共赏\r\n\r\n这个太贴心了，会场居然可以办成一个技术与生活的大杂烩，我亲眼看到身为工程师的丈夫带着一家三口来参加周日的嘉年华的。老公在展台展示自己的成就，老婆孩子在玩棋牌，和灰太狼喜洋洋的公仔互动，渴了有乐可，饿了有奥利奥饼干和现做的蛋糕，其乐融融。我之前觉得对于成家的人来说，周末两天不休息来参会太残忍了，现做我就不觉得了，反而双手推荐！\r\n\r\n工程师们也不闲着，除了技术交流，还有机会参加各种抽奖、砸蛋、作品投票、你说我猜之类的游戏。我也不免俗的去砸了一个金蛋，中了一套便利贴。\r\n\r\n### 最后，天南海北共聚一堂\r\n\r\n和太多神交已久的朋友们相见了啊！！！！神飞、李秉骏、苏震巍、IsNull、还有好久不见的winter、老赵、大城小胖、杨东杰、梦工场的几个城市的负责人…… 和大家聊在一起非常开心，同时觉得好多来自武汉、杭州、上海、深圳、广州的优秀作品和精英们的涌现，北京虽然能承办得到这么豪华的峰会，但有很多地方应该和全国各地的朋友虚心请教和学习。收获满满的两天！\r\n\r\n我们还敢期待更精彩更大规模的HTML5峰会吗？[@田爱娜](http://weibo.com/mengyang0398)"},"47":{"title":"微创新=伪创新","slug":"micro-innovation-is-not-the-real-innovation","created":1348864667,"modified":1348865011,"text":"先说一个跟创新无关的事儿：\r\n最近有个刷火车票的插件非常流行，名字我不想提了。朋友发链接给我的时候，我打开一看，吓了一跳，网站风格几乎和傲游2006年的官网一模一样……\r\n\r\n傲游2006年的官网  \r\n<img src=\"http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2012/09/1293548526.png\" alt=\"傲游2006年的官网\" />\r\n\r\n这是今天看到的网页  \r\n<img src=\"http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2012/09/4227819619.png\" alt=\"这是今天看到的网页\" />\r\n\r\n这跟创新毫无关系，但和创新的一个反面话题有关——抄袭。虽然公司的设计和创意被别人照搬过去对我这种在傲游有些年头的人已经不是什么新鲜事了，但是在今年的新网站，还能够抄回2006年，好设计在国内死绝了吗？\r\n\r\n我感觉在我们周围的互联网行业中，创新能力正在急剧群体退化。不论是设计、产品还是技术层面。1.封闭的互联网给山寨版的国外网站带来了__巨大需求__；2.再加上产权保护不给力，让抄袭变成了“__0成本__”。所以抄袭者顺风顺水，不甘心抄的人走起路来就变得相对困难。\r\n\r\n另外，我不太认同微创新这个说法，原因很简单，__如果微小的不同之处也可以看做是创新，那什么又是真正的抄袭呢？__我们今天认为的抄袭，哪个会像做蜡像一样真的做个一模一样的东西出来呢？所以没什么争议，抄了就是抄了。如果微创新被鼓励，就等于抄袭被鼓励。\r\n\r\n设计：“直接把傲游的官网样式抓下来用吧”  \r\n产品：“我们做的东西很简单，就做成跟xxxx一样”，“然后我们再加个xxx，就行了”\r\n\r\n我担心在这样的游戏规则之下，人的创新意识和创新能力会在不知不觉中退化。前段时间参加了互联网大会，本来是去给我们CEO捧场的，只听了其中几个专场。直观的感觉是：大家都在讨论别人，上来就说Facebook今年怎么样，Apple今年怎么样，Google今年怎么样，说得不亦乐乎，好像Facebook、Apple、Google是他们自家的公司；一说到自己，就一两句话结束了。听到最后，觉得讲得最有水平的，同时也是中国互联网最有前途的行业，其实是搞数据分析的，因为他们的工作就是名正言顺的研究别人。\r\n\r\n隔天凌晨，我又见证了苹果iPhone5等一些列产品的发布会。对比甚是明显：\r\n\r\n* __白天的互联网大会上，国内的某些大公司会怎么“做”产品是没悬念的，但大家都在好奇他们接下来会“做”什么产品；__\r\n* __晚上的苹果发布会，他们在做什么产品是没悬念的，但大家都在好奇他们接下来会把这款产品做成什么样。__\r\n\r\n我想这就是对国内互联网怪现象的最好总结了……\r\n\r\n看过听过经历过后，我更坚定了的是，要拥有一颗强大的内心，面对抄袭，不能妥协，坚持创新的思考和行动。"},"48":{"title":"标签？ID？还是CLASS？","slug":"html-or-id-or-class","created":1353962562,"modified":1353963008,"text":"想谈一下几个基本的HTML问题，都是围绕着应该怎样使用HTML。\r\n\r\n### 1. 多用有语义的标签，少用div和span，避免使用没有class的div和span。\r\n\r\n设想一下HTML的世界最初只有div和span这两个标签，其实网页依然可以写得出来。更多标签的出现，其实是为了替代利用率高但不好书写的 `<div class=\"{tagname}\">` 和 `<span class=\"{tagname}\">` 来的。\r\n\r\n想再接着多说一句的是，在HTML5里越来越多常见的div class组合或div id组合被直接命名为了新的标签。理由也是相同的，像header/footer/aside/nav/section/article都是我之前经常使用的class或id。我甚至觉得w3c创造新html标签的工作很简单，定期统计一下最常用的class和id，然后取前几名作为新的标签名就行了。\r\n\r\n上周还有人在微博上感慨那个“史上最牛的HTML代码”：\r\n\r\n    <div class=\"mod\">\r\n        <div class=\"hd\"></div>\r\n        <div class=\"bd\"></div>\r\n    </div>\r\n\r\n再过几年它真的也许会消失的。\r\n\r\n反过来思考也可以，尽量使用有语义的标签名，实在想不出来合适的标签名了，再用div然后起个class或id。这样的思路也不错。\r\n\r\n### 2. 不要滥用class而回避id，该出手时就出手。\r\n\r\n和问题1同理，设想一下HTML的世界最初只有class没有id，其实网页依然可以写得出来，语义依然表达得出来。无非就是会出现很多特殊的class呗。因此，我们也很好理解，id的出现，就是可以和class一起协作，使某些语义即使没有现成的标签可以表示它，但依然可以把一般性和唯一性完美的结合在一起。\r\n\r\n这里驳斥一个观点：“尽量都使用class，因为控制样式的时候class的优先级是同级的，id的优先级更高，它的出现会破坏样式优先级的平衡”。首先我觉得这是一个假命题，所谓的“平衡”是不存在的，也没有必要去刻意维护，通过id来表示的内容一定是相对特殊的，优先级自然高一些，这样的优先级设计是如此的自然。我能够接受的全部是class的适用范围仅是一些底层的css基础样式，如oocss里的基础样式，或很多网站都会有common.css文件或general.css文件，里面的东西尽量用class没问题。\r\n\r\n另一个更重要的理由是，在HTML5里，除了id和class这两个特性可以控制样式之外，还可以通过特性选择器来定义样式，类似E[attr=\"...\"]的写法。我们会发现可以控制样式的方式越来越灵活，选择越来越多。这是Web发展的必然趋势。当其他人已经在用id/class/data-*/tagname对样式展开多重维度攻势的时候，我们实在没有必要把自己还关在class的世界里。\r\n\r\n### 3. 尽量给每个表示布局的class或id换一个站在内容角度的合理的名字。\r\n\r\n比如两列布局的左右侧多半是正文和辅助信息的关系，那么就不建议用class=\"left\"和class=\"right\"而是倾向于class=\"main-content\"和class=\"sidebar\"，或者直接用article和aside。\r\n\r\n在自适应Web设计(responsive web design)如火如荼的今天，页面上的某个元素处在网页什么位置更像是个变量，所以通过位置来定义一个元素显然是会承受很多额外的维护成本和扩展成本。当改变发生的那一天，你发现自己的HTML代码变得文不对题。曾经的left跑到最上面去了，right变成了底部通栏，这都是很正常的变化。\r\n\r\n实在没什么语义的，比如为了给IE加圆角而增设的标签，或清除浮动用的额外的标签，再或者是基础样式的，和具体内容无关的，再用div加表象的class来描述。\r\n\r\n### 4. 尽量避免表示纯样式的class或id。\r\n\r\n比如class=\"f14 red\"。印象中网上有很多拙劣的例子，也有很多深刻批判这种用法的文章，我想说的是，如果你非要这样改样式，那不如直接写内联style来得直观。\r\n\r\n### 最后想说的是……\r\n\r\n互联网是一个快速发展的领域，[它的快速发展甚至让人们忘却了很多传统领域的停滞不前](http://it.sohu.com/20110824/n317169919.shtml)。在这样的领域里工作，勇敢尝试，关注新技术，把握新趋势是如此的重要。不要拒绝新事物，不要被不思进取的人拖累，不要对大千世界失去好奇心和求知欲，方可永葆青春。"},"52":{"title":"【图】八三夭《最后一击》演唱会","slug":"831-last-shot-music-concert","created":1355510372,"modified":1414334770,"text":"翻翻自己的个人曲库，发现华语的好音乐越来越少了。从2011年开始尤为明显\r\n\r\n<img src=\"http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2012/12/327178183.jpg\" />\r\n\r\n早期的音乐很多是“歌红人不红”，因为好歌很多，有机会认住的人就那么几个，现在反过来了……这是一个选秀的年代，新人辈出，一个好声音，让人一个夏天认识了五六十个歌手，可唱的都是老歌。也许八三夭还算不上什么大红大紫的乐团，但是他们的创作和通过演唱会展现出的舞台魅力真是不得了，我觉得这是这个时代的悲哀。\r\n\r\n还有个悲哀，是我第一次听他们的演唱会，可他们却是“最后一击”了。貌似他们来年需要服兵役。<!--more-->\r\n\r\n<img src=\"http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2012/12/83157332.jpg\" />\r\n\r\nAnyway，今天有幸去他们的演唱会，难得在这个忙碌的季节得到如此的视听享受，也让自己的神经得到放松，的的确确爽啊！\r\n\r\n<img src=\"http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2012/12/109174833.jpg\" />\r\n\r\n另外这次拿手机录了两段视频，多少也想检验一下新手机的成色。已上传：\r\n\r\n<div><object id='sinaplayer' width='480' height='370' ><param name='allowScriptAccess' value='always' /><embed pluginspage='http://www.macromedia.com/go/getflashplayer' src='http://video.sina.com.cn/api/outPlayRefer.php?video_id=230483897' type='application/x-shockwave-flash' name='sinaplayer' allowFullScreen='true' allowScriptAccess='always' width='480' height='370'></embed></object></div>\r\n[《东区东区》(iOS用户可点击这里观看)](http://video.sina.com.cn/play/shijiao-1712131295-230483897.html)\r\n\r\n<div><embed src=\"http://player.youku.com/player.php/sid/XNDg4NjY0MTgw/v.swf\" quality=\"high\" width=\"640\" height=\"400\" align=\"middle\" allowScriptAccess=\"sameDomain\" allowFullscreen=\"true\" type=\"application/x-shockwave-flash\"></embed></div>\r\n[Encore +《来去夏威夷》+《终结孤单》(iOS用户可点击这里观看)](http://v.youku.com/v_show/id_XNDg4NjY0MTgw.html)"},"53":{"title":"2012年终毫无正能量的总结","slug":"review-terrible-2012","created":1356983262,"modified":1356983771,"text":"“丰功伟绩”、“甜言蜜语”就不在这里恶心大家了，如果有人问我你幸福吗，我会说我很幸福，以及关于我怎么幸福的长篇大论。但我不会把下面的话也说出来。\r\n\r\n乱七八糟的2012年就这样糊里糊涂的过去了。\r\n\r\n今年发生了不少冠冕堂皇的大事儿，但好像没什么实质性的收获。可能此时此刻的我心思还是在事业上多一些，但无奈力不从心。作为一个有家有老婆的人，不能加班，不能熬夜，工作上几乎没了弹性，想冲冲不起来，有劲儿不能一口气使出来；另外我们的休闲娱乐需求也很旺盛，下馆子看电视电影到处旅游总是好的，可它们基本上填满了我的业余时间，没有充足的时间用心学习这种感觉比什么都糟糕。这些事儿其实也不是我改变不了，更多的是自己也不忍心改变吧。\r\n\r\n我觉得这是我觉得2012糊里糊涂的主要原因。\r\n\r\n第二点原因是我觉得自己变懒了也变邋遢了。搬了家这么久也结婚了这么久，很多早就想请客的人也一直没请到。每到周末就跟自己怕麻烦的心妥协了。洗碗洗衣服倒洗脚水擦地吃早餐之类的事情也越来越不积极了，我最近反思了一下，可能是太想把烂摊子都寄托给老婆来收拾了，家里的脏活累活总要有人做，己所不欲勿施于人，以后还是身先士卒吧。\r\n\r\n在工作上，我比较欣慰的是自己有机会也有勇气接触更广泛的技术领域，让自己的知识面更广，更充实，但达到比较理想的状态是需要时间的。为了能够掌握更广泛的开发技能，我正在重读很多计算机的基本课程。在上学的时候它像是我毕业路上的敌人，我在乎的只是战胜那些题目；如今重读，它们更像是我的朋友，为我弥补一块块盲区，让我面对困难的时候更加自信。真的有点二次启蒙的感觉，我突然觉得这才是真正的编程。我希望在新的一年我可以处于一种低调踏实追求卓越的心态，不要像今年这样疯疯癫癫的，说得多做得少。\r\n\r\n公司这一年的形势很微妙，我觉得全公司现在最纠结的地方在于，我们想做个典型的带有鲜明中国特色的公司，还是一个超凡脱俗的洋气公司。说白了就是一群屌丝和另一群高富帅白富美凑在一起想搞个团队活动，大家一起商量是去吃西餐呢还是吃大排档呢。正在犹豫之时，眼瞅着周围的人眼疾手快，把西餐厅的位子订光了，把大排档也挤了个水泄不通，顿时就都傻眼了，可还是没有相互妥协的迹象。咳，只说这么多了…\r\n\r\n别的都还行。\r\n\r\n2013不能比今年更烂了。"},"69":{"title":"小秀个人的全年摄影作品 (共15张)","slug":"recent-photography-works","created":1357233650,"modified":1357233650,"text":"今年年初家里买了台微单相机，外加一台iPhone，我也算是个曾经摸了摸镜头的人。相比起周遭的摄影发烧友，我觉得自己真的很业余，以至于我自己说出摄影作品这个词的时候都有点心虚：不就是拍了几张照片么。还整的跟是回事儿似的。\r\n\r\n不久之前刚在自己微博上晒了几张自己拍照片时的个人恶趣味，算娱乐一下吧。下面几张是我真的认真挑选过的，如果诸位摄影达人看到觉得拍得太烂，还求轻拍 ^_^\r\n\r\n![车水马龙](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/01/3406089111.jpg)<br>车水马龙<!--more-->\r\n\r\n![多彩地砖](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/01/1956040302.jpg)<br>多彩地砖\r\n\r\n![蓝天·高楼](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/01/1196063017.jpg)<br>蓝天·高楼\r\n\r\n![店铺一角](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/01/3526238752.jpg)<br>店铺一角\r\n\r\n![西湖夜景](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/01/4213143480.jpg)<br>西湖夜景\r\n\r\n![雪花形状的窗花](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/01/2929042459.jpg)\r\n\r\n![厦门夜景](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/01/419019303.jpg)<br>厦门夜景\r\n\r\n![鼓浪屿夜景](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/01/1281312199.jpg)<br>厦门夜景\r\n\r\n### 两款涂鸦，主要不是我拍的好，是我喜欢这个涂鸦的内容\r\n\r\n![512大地震题材的涂鸦](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/01/3139520867.jpg)\r\n\r\n![涂鸦：高数不会离开你](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/01/3230758857.jpg)\r\n\r\n### 两张全景模式\r\n\r\n![晚宴全景](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/01/1124079497.jpg)\r\n\r\n![苏州俯瞰](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/01/2618883672.jpg)\r\n\r\n### 两张适合手机屏保的\r\n\r\n![鼓浪屿一角](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/01/2584894974.jpg)\r\n\r\n![做个幸福的吃货！Yeah！](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/01/428650734.jpg)<br>做个幸福的吃货！Yeah！\r\n\r\n### 最后来张自己的\r\n\r\n![我的自拍像](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/01/2888873282.jpg)<br>照照镜子，看看自己"},"70":{"title":"烟火——写给蛇年的傲游和我","slug":"my-6th-year-with-maxthon","created":1360435446,"modified":1360435446,"text":"> 世界上没有怯懦的高楼<br>\r\n> 没有细水长流的烟火\r\n> \r\n> ——1976《烟火》\r\n\r\n看完春晚正准备要睡觉，看到祥子一条微博：<q>八千块的烟火换来一小时的快乐，多少的代价可以换来一生的幸福。</q>于是我就这样陷入了沉思。\r\n\r\n祥子我恨你……\r\n\r\n此时此刻，估计整个城市，乃至全中国的“一小时的快乐”，都已经告一段落了。这对我来说，也意味着，去年的成绩、收获、经验教训，也停留在这里了；新年的奋斗史，从这一刻，就要开始书写了。\r\n\r\n每到过年的时候，也是让我猛一抬头，想起自己和过去的老师同学又多一整年不见的时候，想起自己在傲游又多待了一年的时候，想起自己和一年前相比又度过了一年美好时光的时候。\r\n\r\n![](http://ww3.sinaimg.cn/large/660d0cdfjw1e1agx3b46nj.jpg)\r\n\r\n来傲游第六年了，去年这个时候的[五周年纪念的情形](http://bulaoge.net/topic.blg?dmn=g3g4&tid=2324366)仿佛还历历在目。我也在此兑现自己一年前的承诺，给自己在傲游的第六年留个“快照”。\r\n\r\n现在小学时期的稳定性记录已经被打破了，人生会不会从此变得没有追求了呢？呵呵\r\n\r\n在我眼里，这一年，自己和公司都发生了很多变化。公司的办公区又一次扩张了，从“两居室小户型”演变成“两套大房子”了；高管走了一批、也来了一批；有些部门拆散了，有些部门合并了，有些部门洗牌了……无非都为的是个活字。我自己呢，团队角色和工作要求也发生了不小的变化，无非为的是能继续走下去。其实这些都不算什么伟大的志向。所以，尽管过程轰轰烈烈，结果其实很惨淡。\r\n\r\n这和我刚来公司时的感受已经截然不同了。刚来傲游的时候，觉得像天堂一样，哪儿都好，各种优越感，每天无忧无虑，技术交流的时候、同学聚会的时候、校园招聘等各种时候，一说自己是傲游的，大家都好待见你；现如今，觉得公司哪儿都有问题，哪儿都做得不好，哪儿都有改进空间。上周一个好朋友的电脑重装系统了，跟我说他把`Program Files/Maxthon`整个文件夹都备份了，问我怎么恢复收藏——聊到最后我们两个都很震惊：他震惊自己最信任的傲游浏览器把他的收藏搞丢了，我震惊他不知道我们有傲游账户和在线收藏。\r\n\r\n烟火固然美丽，但也稍纵即逝。\r\n\r\n去年年初的时候看到过一句话：“即使如日中天的Apple，也一定会有股票下跌的那一天” (如今它已经跌了)。一家公司再好，一份工作再适合你，也会有不如意的地方。其实问题总是会有的，如果每次面对问题的时候都选择逃避，这个问题不会自动消失，反而会永远缠着你。\r\n\r\n我觉得去年一年，是我让自己从理想乐观回归现实的一年。从某种角度将，它让我看清傲游是一个有很多问题的公司，同时这些问题也是大家需要很大的勇气去承认、面对和解决的——这其实对于我，以及每一个傲游人来说，其实非常重要。它比我们去年赚了多少钱、发展了多少用户、打开了多大的市场这些成绩，都更重要。\r\n\r\n![](http://ww4.sinaimg.cn/large/80e3e3d0jw1dyt4cxkk85j.jpg)\r\n\r\n所以，做事不能只看眼前成绩，不然什么也做不成。面对问题，不能逃避，只有勇敢面对，久而久之，养成习惯，就可以战胜一切！\r\n\r\n过去的六年，对我来说，就当是一场烟火表演吧。璀璨、辉煌、这一切的一切，都无法奠定你未来的坦途。幸福的人生，需要的不是一场价值连城的烟火表演，也不是每年一度的烟火表演，而是一个持续的状态，一步一个脚印的存在感和成就感。\r\n\r\n是时候面对久违的挑战了。"},"71":{"title":"[翻译] JSLint 文档","slug":"jslint-docs-zh-cn","created":1361041486,"modified":1361041634,"text":"原文地址：[http://www.jslint.com/lint.html](http://www.jslint.com/lint.html)\r\n\r\n### 什么是`JSLint`？\r\n\r\n`JSLint` 是一个用来查找各种 JavaScript 程序中的问题的 JavaScript 程序。它是一个代码之类工具。\r\n\r\n在[早些年](http://cm.bell-labs.com/cm/cs/who/dmr/chist.html)的 [C 语言](http://en.wikipedia.org/wiki/C_programming_language)中，有些程序的常见错误是主流的编译器无法抓住的。所以出现了一个名叫 [`lint`](http://en.wikipedia.org/wiki/Lint_programming_tool) 的附带程序，可以通过搜索源文件寻找错误。\r\n\r\n随着语言的成熟，其定义的健壮性足以消除一些不安因素，编译器也在问题警告方面越做越好，`lint` 也不再需要了。\r\n\r\n[JavaScript](http://javascript.crockford.com/) 是一个年轻的语言。它原本只是用在网页上完成一些无需劳驾 Java 的小任务。但 JavaScript 是一个强大得惊人的语言，现在它已经在大项目中派上用场了。当项目变得复杂之后，之前从易用角度出发的语言特性就带来了一些麻烦。这是一个为 JavaScript 而生的 `lint` 呼之欲出：它就是 `JSLint`，一个检查 JavaScript 语法、判断 JavaScript 语法有效性的工具。\r\n\r\n`JSLint` 会拿来一段 JavaScript 源代码并对其进行检索。一旦发现问题，它就会返回一则消息，用来描述这个问题以及源代码中的大概位置。发现的问题不一定是，但通常是语法上的错误。`JSLint` 通过一些代码规范来杜绝结构性的问题。这并不证明你的程序是正确的，只是提供另一种发现问题的眼光。\r\n\r\n`JSLint` 定义了一个专业的 JavaScript 的子集，它比 [ECMAScript 标准第三版](http://www.ecma-international.org/publications/standards/Ecma-262.htm)的定义更严格，和 [JavaScript 编码规范](http://javascript.crockford.com/code.html)中的建议相对应。\r\n\r\nJavaScript 是一个粗中有细的语言，它比你想象中的更好。`JSLint` 帮助你回避很多问题，在这个更好的语言中撰写程序。`JSLint` 会拒绝一些浏览器支持的程序，因为浏览器并不关心代码的质量。你应该接受 `JSLint` 的所有建议。\r\n\r\n`JSLint` 在 JavaScript 源代码、HTML 源代码、CSS 源代码或 [JSON](http://www.json.org/) 文本中都可以运行。<!--more-->\r\n\r\n### 全局变量\r\n\r\nJavaScript 的最大问题就是其依赖的全局变量，特别隐含的全局变量。如果一个变量没有被显性的声明 (通常是通过 `var` 语句)，则 JavaScript 会假定这个变量是全局变量。这会掩盖拼写错误等其它问题。\r\n\r\n`JSLint` 希望所有的变量和函数都要在使用或调用之前被声明。这样我们就可以探测隐含着的全局变量。同时，这也让程序的可读性增强了。\r\n\r\n有的时候一个文件会依赖于在别处定义好的全局变量或全局函数。这时你可以通过一个 `var` 语句让 `JSLint` 识别该程序依赖的这些全局函数和对象。\r\n\r\n一个全局声明大概如下所示：\r\n\r\n    var getElementByAttribute, breakCycles, hanoi;\r\n\r\n该声明应该出现在靠近文件最上方的位置，且必须出现在使用这些变量之前。\r\n\r\n同时，我们有必要在一个变量被赋值之前通过 `var` 语句对其进行声明。\r\n\r\n`JSLint` 同样可以识别一段 `/*global*/` 指令，该指令可以为 `JSLint` 注明在该文件中使用但在其它文件中定义好的变量。该指令可以包含一串变量名，用逗号隔开。每个名字可以跟随一个可选的冒号以及 `true` 或 `false`，`true` 表示该变量可以被该文件赋值，而 `false` 则表示该变量不能被赋值 (这是默认行为)。在函数作用域也是如此。\r\n\r\n有些全局变量可以被你预定义。选择*假设为浏览器* (`browser`) 选项可以预定义浏览器提供的标准的全局属性，比如 `document` 和 `addEventListener`。它等同于：\r\n\r\n    /*global clearInterval: false, clearTimeout: false, document: false, event: false, frames: false, history: false, Image: false, location: false, name: false, navigator: false, Option: false, parent: false, screen: false, setInterval: false, setTimeout: false, window: false, XMLHttpRequest: false */\r\n\r\n选择*假设为 Node.js* (`node`) 选项可以预定义 Node.js 环境下的全局变量。它等同于：\r\n\r\n    /*global Buffer: false, clearInterval: false, clearTimeout: false, console: false, exports: false, global: false, module: false, process: false, querystring: false, require: false, setInterval: false, setTimeout: false, __filename: false, __dirname: false */\r\n\r\n选择*假设为 Rhino* (`rhino`) 选项可以预定义 Rhino 环境下的全局属性。它等同于：\r\n\r\n    /*global defineClass: false, deserialize: false, gc: false, help: false, load: false, loadClass: false, print: false, quit: false, readFile: false, readUrl: false, runCommand: false, seal: false, serialize: false, spawn: false, sync: false, toint32: false, version: false */\r\n\r\n选择*假设为 Windows* (`windows`) 选项可以预定义 Microsoft Windows 提供的全局属性。它等同于：\r\n\r\n    /*global ActiveXObject: false, CScript: false, Debug: false, Enumerator: false, System: false, VBArray: false, WScript: false, WSH: false */\r\n\r\n### 分号\r\n\r\nJavaScript 使用近似于 C 语言的语法，它要求使用分号来分割确定的语句。JavaScript 试图通过一个自动插入分号的机制让这些分号变得可有可无。这是比较危险的，因为它可以掩盖你的错误。\r\n\r\n和 C 一样，JavaScript 有 `++` 和 `--` 和 `(` 操作符，这些操作符可以作为前缀或后缀。分号可以用来消除这里的二义性。\r\n\r\n在 JavaScript 中，一个折行可以是一个空格，也可以当做分号使用，两者容易产生混淆。\r\n\r\n`JSLint` 希望除了 `for`、`function`、`if`、`switch`、`try`和`while`，每个语句都以 `;` 结尾。同时 `JSLint` 不希望看到没有必要的分号或空白语句。\r\n\r\n### 逗号\r\n\r\n我们可以用逗号操作符写出极度巧妙的表达式。同时也可以掩盖一些程序上的错误。\r\n\r\n`JSLint` 希望逗号只用来当做分隔符，而不是操作符 (`for` 语句中的初始化部分和自增部分除外)。数组直接量里不希望有被省略的元素，多余的逗号不应该被使用，逗号不应该出现在数组直接量或对象直接量的最后一个元素的后面，因为一些浏览器无法正常识别。\r\n\r\n### 作用域\r\n\r\n在很多语言中，每个块都产生一个作用域，块内产生的变量在块外是看不到的。\r\n\r\n在 JavaScript 中，块并不产生新的作用域，只有函数作用域。在一个函数中任意位置声明的变量都在整个函数中可见。JavaScript 的块混淆了有经验的程序员，并导致了错误的出现，因为用相似的语法做了一个错误的承诺。\r\n\r\n`JSLint` 希望 `function`、`if`、`switch`、`while`、`for`、`do` 和 `try` 语句之外不要产生其它块。\r\n\r\n在有块级作用域的语言里，通常都推荐变量声明在第一次使用的地方。但是因为 JavaScript 没有块级作用域，所以明智的选择就是在函数的最顶端声明所有的函数变量。这里推荐每个函数用单一的一个 `var` 语句完成变量声明。这个要求可以通过 `vars` 选项取消掉。\r\n\r\n### 必要的块\r\n\r\n`JSLint` 希望 `if`、`while`、`do` 和 `for` 语句都由块生成，`{` 也就是说，语句是被大括号包住的 `}`。\r\n\r\nJavaScript 允许一个 `if` 语句这样书写：\r\n\r\n<pre>if (<i>condition</i>) <i>statement</i>;</pre>\r\n\r\n这个格式是公认的：当很多程序员都基于相同的代码工作时，会给整个项目带来很多错误。这也是为什么 `JSLint` 希望如下使用块：\r\n\r\n<pre>if (<i>condition</i>) { <i>statement</i>; }</pre>\r\n\r\n经验告诉我们这个格式更保险一些。\r\n\r\n### 表达式语句\r\n\r\n我们希望一个表达式语句是一个赋值或一个函数/方法调用或 `delete`。其它表达式语句都可能导致错误。\r\n\r\n### `for` `in`\r\n\r\n`for` `in` 语句允许在一个对象的所有属性名内进行循环。[不幸的是，这样的循环也会覆盖到其原型链中所有被继承而来的属性。](http://yuiblog.com/blog/2006/09/26/for-in-intrigue/)其副作用就是当我们只关心数据的时候，它连方法函数也会处理一遍。如果此时该程序没有任何预防措施，那么就会导致失败。\r\n\r\n每个 `for` `in` 语句的主体部分都应该包裹一个起过滤效果的 `if` 语句。该语句可以选择特殊类型或范围的值、或排除函数类型的属性、或排除原型的属性。比如：\r\n\r\n    for (name in object) { if (object.hasOwnProperty(name)) { .... } }\r\n\r\n### `switch`\r\n\r\n一个 `switch` 语句中[常见的错误](http://yuiblog.com/blog/2007/04/25/id-rather-switch-than-fight/)就是忘记在每个条件的结尾写上 `break` 语句，导致程序没有及时跳走。`JSLint` 希望语句的下一个 `case` 之前或 `default` 之前必须有下面三个当中的一个：`break`、`return`、`throw`。\r\n\r\n### `var`\r\n\r\nJavaScript 允许 `var` 在一个函数内的任何位置完成定义。`JSLint` 的要求则会更严格一些。\r\n\r\n`JSLint` 希望一个 `var` 只被声明一次，并且是在使用之前被声明。\r\n\r\n`JSLint` 希望一个 `function` 在使用之前被声明。\r\n\r\n`JSLint` 希望函数的参数不要被声明为变量。\r\n\r\n`JSLint` 不希望 `arguments` 数组被声明为 `var`。\r\n\r\n`JSLint` 不希望一个变量被定义在块中。这是因为 JavaScript 的块并不具有块级作用域。这会造成意料之外的结果。把所有的变量都定义在函数的最顶部。\r\n\r\n### `with`\r\n\r\n`with` 语句的初衷是提供一个访问对象嵌套属性的简写方式。不幸的是，当我们设置新属性时这个行为[非常糟糕](http://yuiblog.com/blog/2006/04/11/with-statement-considered-harmful/)。永远不要使用 `with` 语句。请用一个 `var` 替代之。\r\n\r\n### `=`\r\n\r\n`JSLint` 不希望看到 `if`、`for`、`while` 或 `do` 语句的条件判断中出现赋值语句。这是因为似乎：\r\n\r\n    if (a = b) { ... }\r\n\r\n的本意是：\r\n\r\n    if (a == b) { ... }\r\n\r\n当我们难以从常用语句中察觉出明显的错误时，是很难把程序写对的。\r\n\r\n### `==` 和 `!=`\r\n\r\n`==` 和 `!=` 操作会在比较之前做类型转换。这是不提倡的，因为它导致 `' \\t\\r\\n' == 0` 的结果是 `true`。这会掩盖一些类型错误。`JSLint` 无法依赖 `==` 进行判断，所以最好别再使用  `==` 和 `!=` 了，以后都用更可靠的 `===` 和 `!==` 操作替代之。\r\n\r\n如果你只是在乎一个值是*真的*还是*假的*，那么可以使用简写方式，比如把：\r\n\r\n    (foo != 0)\r\n\r\n替换为：\r\n\r\n    (foo)\r\n\r\n而将：\r\n\r\n    (foo == 0)\r\n\r\n替换为：\r\n\r\n    (!foo)\r\n\r\n我们有一个 `eqeq` 选项，允许使用 `==` 和 `!=`。\r\n\r\n### 标签 (labels)\r\n\r\nJavaScript 允许任何语句拥有标签，标签拥有各自的命名空间。`JSLint` 的要求会更严格。\r\n\r\n`JSLint` 希望标签只出现在响应 `break`、`swtich`、`while`、`do` 和 `for` 的语句上。`JSLint` 希望标签可以同变量和参数区分开来。\r\n\r\n### 无法到达的代码\r\n\r\n`JSLint` 希望一个 `return`、`break`、`continue` 或 `throw` 语句后面都会跟着一个 `}` 或 `case` 或 `default`。\r\n\r\n### 混乱的加号减号\r\n\r\n`JSLint` 希望 `+` 不会紧跟着 `+` 或 `++`，而 `-` 不会紧跟着 `-` 或 `--`。少写一个空格就会把 `+ +` 变成 `++`，这种错误是很难被发现的。为了避免混乱，请善用括号。\r\n\r\n### `++` 和 `--`\r\n\r\n自增操作符 `++` 和自减操作符 `--` 是公认的会鼓励过度使用技巧而导致糟糕的代码。它们是导致病毒和安全威胁的错误构建。同样的，乱用前自增和后自增会产生 off-by-one 的错误，排查这样的错误是极为困难的。我们有一个 `plusplus` 选项来允许使用这些操作符。\r\n\r\n### 位操作符\r\n\r\nJavaScript 没有整数类型 (*)，但是其具备位操作符。位操作符会先把操作对象由浮点数转换回整数，所以这样的位操作效率远不及 C 或其它语言。位操作符极少用在浏览器应用里。与逻辑操作符的相似性也会掩盖一些程序的错误。`bitwise` 选项允许使用 `<<`、`>>`、`>>>`、`~`、`&`、`|` 这些操作符。\r\n\r\n### `eval` 是魔鬼\r\n\r\n`eval` 函数 (及其相似的 `Function`、`setTimeout` 和 `setInterval`) 提供了 JavaScript 编译器的访问形式。这在一些情况下是有必要的，但是在大多数情况下它代表了相当糟糕的代码。`eval` 函数是 JavaScript 最不应该被使用的特性。\r\n\r\n### `void`\r\n\r\n在大多数近似于 C 的语言中，`void` 是一个类型。在 JavaScript 中，`void` 是一个前缀操作符，它总是返回 `undefined`。`JSLint` 不希望看到 `void` 因为它具有迷惑性且没有实质的用处。\r\n\r\n### 正则表达式\r\n\r\n正则表达式写起来既简洁又神秘。`JSLint` 会检测一些可能导致可移植性问题的问题。同时会推荐把具有视觉混淆性质的字符全部转义。\r\n\r\nJavaScript 语法中，正则表达式直接量会多写一对 `/` 字符。为了避免混淆，`JSLint` 希望一个正则表达式字面量的开头是一个 `(` 或 `=` 或 `:` 或 `,` 字符。\r\n\r\n### 构造函数和 `new`\r\n\r\n构造函数是设计为通过 `new` 前缀使用的函数。`new` 前缀基于函数的 `prototype` 创建一个新的对象，并把函数隐性提供的 `this` 参数绑定到那个对象。如果你忽略了 `new` 前缀的使用，则不会有新的对象被创建，而 `this` 则会绑定到全局对象上。这是[非常严重的错误](http://yuiblog.com/blog/2006/11/13/javascript-we-hardly-new-ya/)。\r\n\r\n`JSLint` 强制规范构造函数的函数名大写开头。`JSLint`不希望看到一个函数调用的函数名是大写开头但没有 `new` 前缀。`JSLint` 也不希望看到 `new` 前缀用在一个函数名不是大写开头的函数上。这一要求可以通过 `newcap` 选项关掉。\r\n\r\n`JSLint` 不希望看到 `new Number`、`new String`、`new Boolean` 的包裹形式。\r\n\r\n`JSLint` 不希望看到 `new Object`，用 `{}` 替换之。\r\n\r\n`JSLint` 不希望看到 `new Array`，用 `[]` 替换之。\r\n\r\n### 属性\r\n\r\n因为 JavaScript 是个弱类型动态对象语言，所以不太可能在编译的时候判定一个属性名是否拼写正确。`JSLint` 在这方面提供了一些帮助。\r\n\r\n在其报告的最底端，`JSLint` 显示了一个 `/*properties*/` 指令。它包含了一些名称和字符串直接量，它们是所有使用过的点标记、下标标记和对象直接量中用来命名对象属性的。你可以查阅这个列表来找到拼错的词。这是个比较简单的办法。\r\n\r\n你还可以复制 `/*properties*/` 指令到你的脚本文件的顶端。`JSLint` 会根据这个列表检查所有的属性名。这样，你就可以使用 `JSLint` 检查拼写错误了。\r\n\r\n比如：\r\n\r\n    /*properties charAt, slice */\r\n\r\n### 不安全字符\r\n\r\n有一些字符是不同的浏览器显示起来不一致的，在放入字符串之前必须先转义。\r\n\r\n    \\u0000-\\u001f \\u007f-\\u009f \\u00ad \\u0600-\\u0604 \\u070f \\u17b4 \\u17b5 \\u200c-\\u200f \\u2028-\\u202f \\u2060-\\u206f \\ufeff \\ufff0-\\uffff\r\n\r\n### 不检查的内容\r\n\r\n`JSLint` 不会做流程分析，也不会判断变量在使用之前是否已经被赋值。这是因为变量都有默认值 (`undefined`)，很多应用本身就是这样处理的。\r\n\r\n`JSLint` 不会做任何类型的全局分析，不会尝试判断伴随 `new` 使用的函数是真正的构造函数 (只是遵循大小写规范)，不会检查属性名拼写是否正确 (只是针对 `/*properties*/` 指令进行匹配)。\r\n\r\n### HTML\r\n\r\n`JSLint` 可以处理 HTML 文本。它可以找到包含在 `<script>` ... `</script>` 标签中的 JavaScript 内容。也可以通过 JavaScript 找到 HTML 内容中公认的问题：\r\n\r\n* 所有的标签必须小写。\r\n* 所有的标签必须闭合 (比如 `</p>`)。\r\n* 所有的标签必须正确的嵌套\r\n* 必须用实体 `&lt;` 表示字面量 `>`。\r\n\r\n`JSLint` 比 XHTML 的要求要低，但是比主流浏览器的要求要严格。\r\n\r\n`JSLint` 也会检查 `'</'` 在字符串字面量的出现情况，你应该用 `'<\\/'` 替换之。额外的反斜杠会被 JavaScript 编译器忽略掉，但 HTML 解析器不会。类似的技巧都不是必要的，但就是这样。\r\n\r\n这里有一个 `fragment` 选项，用来检查一个合格的 HTML 片段。如果 `adsafe` 选项也选用，则片段必须是一个遵守 [ADSafe](http://www.adsafe.org/) widget 规则的 `<div>`。\r\n\r\n### CSS\r\n\r\n`JSLint` 可以检查 CSS 文件。它检查 CSS 文件的第一行是不是：\r\n\r\n    @charset \"UTF-8\";\r\n\r\n这个特性是试验性的。请把任何问题或束缚报告出来。这里有一个 `css` 选项，可以容忍一些非标准的使用习惯。\r\n\r\n### 选项\r\n\r\n`JSLint` 提供了很多选项，它们控制了其操作和敏感度。在网页版中，选项是可以通过复选框进行勾选的。\r\n\r\n我们还提供了通过构造 `/*jslint*/` 指令和 `/*properties*/` 指令的方式进行辅助。\r\n\r\n当 `JSLint` 被当做函数调用时，它接受一个 `option` 对象参数，这个参数允许你判定你可接受的 JavaScript 子集。网页版的 `JSLint` 在 [http://www.JSLint.com](http://www.jslint.com)，就是这样工作的。\r\n\r\n选项还可以在 `/*jslint*/` 指令中被定义：\r\n\r\n    /*jslint nomen: true, debug: true, evil: false, vars: true*/\r\n\r\n选项指令起始于 '/*jslint'。注意 `j` 前面没有空格。本规范包含了一系列的键值对，这些键是 `JSLint` 的选项，值是 `true` 或 `false`。`indent` 选项可以取一个数字。一个 `/*jslint*/` 指令优先于 `option` 对象。指令遵照函数作用域。\r\n\r\n(表格略，详见：[http://www.jslint.com/lint.html#options](http://www.jslint.com/lint.html#options))\r\n\r\n### 报告\r\n\r\n如果 `JSLint` 可以完成检查，那么它会生成一个函数报告。其列出下面每个函数：\r\n\r\n* 起始行号。\r\n* 名称。如果是匿名函数，`JSLint` 会“猜”出这个名称。\r\n* 参数。\r\n* *Closure*：被声明的变量和参数之中，被子函数使用的部分。\r\n* *Variables*：被声明并只在该函数中使用的变量。\r\n* *Exceptions*：被 try 语句声明的变量。\r\n* *Unused*：被声明但从未在该函数中使用的变量。这可能意味着一个错误。\r\n* *Outer*：被其它函数声明且在该函数中使用的变量。\r\n* *Global*：在该函数中使用的全局变量。把这个用量降到最少。\r\n* *Label*：该函数中使用的语句标记。\r\n\r\n报告还会包含一个使用过的属性名列表。这里是[`JSLint`的消息列表](http://www.jslint.com/msgs.html)。"},"74":{"title":"编辑器小调查结果","slug":"code-editor-survay","created":1361072427,"modified":1361072468,"text":"我在侧边栏放了一阵子编辑器的小调查，时间过去比较久了，是时候统计一下了，供大家参考：\r\n\r\n我一共放了5个默认选项，使用情况排名依次是：\r\n\r\n1. SublimeText 2\r\n2. Notepad++\r\n3. Dreamweaver\r\n4. EditPlus\r\n5. Vim\r\n\r\n![默认选项的选择情况](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/02/404926186.png)<!--more-->\r\n\r\n为了避免自己孤陋寡闻，把其它主流编辑器遗漏，所以我保留了“其它”这个选项，从结果看，确实有疏漏，其中不乏Eclipse、Emacs、WebStorm、Aptana这样的神器，还看到了一个熟悉的身影Expression Web，那是我之前使用过的一款编辑器，微软出的，还不错：\r\n\r\n![其它编辑器使用情况](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/02/2598919784.png)"},"75":{"title":"巧用 RequireJS Optimizer 给传统的前端项目打包","slug":"build-any-web-project-with-requirejs-optimizer","created":1364582807,"modified":1364584515,"text":"[r.js](https://github.com/jrburke/r.js) 本是 [RequireJS](http://requirejs.org/) 的一个附属产品，支持在 NodeJS、Rhino 等环境下运行 [AMD](http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition) 程序，并且其包含了一个名为 RequireJS Optimizer 的工具，可以为项目完成合并脚本等优化操作。\r\n\r\nr.js 的介绍中明确写道它是 RequireJS 项目的一部分，和 RequireJS 协同工作。但我发现，RequireJS Optimizer 提供了丰富的配置参数，可以让我们完全跳出 AMD 和 RequireJS 程序的束缚，为我们的前端程序服务。\r\n\r\n<!--more-->\r\n\r\n### RequireJS Optimizer 常规用法\r\n\r\n首先，简单介绍一下 RequireJS Optimizer 的“正派”用法 (以 NodeJS 环境为例)：\r\n\r\n事先写好一个配置文件，比如 `config.js`，它是 JSON 格式的，常用属性有：\r\n\r\n    {\r\n        // 程序的根路径\r\n        appDir: \"some/path/trunk\",\r\n        // 脚本的根路径\r\n        // 相对于程序的根路径\r\n        baseUrl: \"./js\",\r\n        // 打包输出到的路径\r\n        dir: \"../some/path/release\",\r\n        // 需要打包合并的js模块，数组形式，可以有多个\r\n        // name 以 baseUrl 为相对路径，无需写 .js 后缀\r\n        // 比如 main 依赖 a 和 b，a 又依赖 c，则 {name: 'main'} 会把 c.js a.js b.js main.js 合并成一个 main.js\r\n        modules: [\r\n            {name: 'main'}\r\n            ...\r\n        ]\r\n        // 通过正则以文件名排除文件/文件夹\r\n        // 比如当前的正则表示排除 .svn、.git 这类的隐藏文件\r\n        fileExclusionRegExp: /^\\./\r\n    }\r\n\r\n然后运行：\r\n\r\n    node r.js -o config.js\r\n\r\n这时 RequireJS Optimizer 就会：\r\n\r\n1. 把配置信息的 `modules` 下的所有模块建立好完整的依赖关系，再把相应的文件打包合并到 `dir` 目录\r\n2. 把所有的 `css` 文件中，使用 `@import` 语法的文件自动打包合并到 `dir` 目录\r\n3. 把其它文件复制到 `dir` 目录，比如图片、附件等等\r\n\r\n我已经把 RequireJS 和 r.js 整套东西用到了 [H5Slides](http://github.com/jinjiang/h5slides/) 上。觉得蛮方便的。\r\n\r\n不过工作中的前端开发工作并不是绝对理想化的，有些旧的项目，并不是 AMD 的模块化开发方式，而是传统的 js 程序，开发一个页面时可能需要一口气引入三到五个 css 文件、十来个 js 文件…… 上线的时候为了减少流量及 HTTP 请求数又需要把代码尽可能重用和合并。这个时候就需要一个方便快捷的打包工具帮助我们了，下面就介绍一下 RequireJS Optimizer 是如何完成这项工作的。\r\n\r\n### 用到的几个关键参数\r\n\r\n说到这里，必须要额外介绍几个 RequireJS Optimizer 的参数了：\r\n\r\n#### modules[i].include\r\n\r\n    modules: [\r\n        {\r\n            name: \"main\",\r\n            include: [\"d\", \"e\"]\r\n        }\r\n    ]\r\n\r\n这里的 include 字段提供了“强制建立依赖关系”的功能，也就是说，即使在 main.js 的代码里没有依赖 d.js 和 e.js，它们也会在合并代码的时候插入到 main.js 的前面\r\n\r\n#### skipModuleInsertion\r\n\r\n在介绍这个参数之前需要说明的是，RequireJS Optimizer 有一个很智能的功能，就是为没有写明 define(...) 函数的模块代码自动将其放入 define(...) 之中。如果我们写明：\r\n\r\n    skipModuleInsertion: true\r\n\r\n则这种处理将会被取消。\r\n\r\n#### onBuildRead\r\n\r\n这个参数可以定义一个函数，在处理每个 js 文件之前，会先对文件的文本内容进行预处理。比如下面这个例子里，我会把 main.js 里的代码全部清除：\r\n\r\n    onBuildRead: function (moduleName, path, contents) {\r\n        if (moduleName === 'main') {\r\n            contents = '/* empty code */';\r\n        }\r\n        return contents;\r\n    }\r\n\r\n### 巧妙应用到传统项目\r\n\r\n这时，我们的资源已经足够了。比如我现在的项目有：\r\n\r\n__1 个 html__\r\n\r\n* index.html\r\n\r\n代码：\r\n\r\n    <!doctype html>\r\n    <html>\r\n        <head>\r\n            <meta charset=\"utf-8\">\r\n            <title>Index</title>\r\n            <link rel=\"stylesheet\" href=\"css/a.css\">\r\n            <link rel=\"stylesheet\" href=\"css/b.css\">\r\n        </head>\r\n        <body>\r\n    \r\n            ...\r\n    \r\n            <script src=\"js/a.js\"></script>\r\n            <script src=\"js/b.js\"></script>\r\n            <script src=\"js/c.js\"></script>\r\n        </body>\r\n    </html>\r\n\r\n__2 个 css__\r\n\r\n* css/a.css\r\n* css/b.css\r\n\r\n__3 个 js__\r\n\r\n* js/a.js\r\n* js/b.js\r\n* js/c.js\r\n\r\n__1 个图片文件夹__\r\n\r\n* images\r\n\r\n#### 合并 css 文件\r\n\r\n新建一个 css 文件，叫 css/main.css，内容为：\r\n\r\n\r\n    @import url(a.css);\r\n    @import url(b.css);\r\n\r\n然后把 index.html 中的 2 个 &lt;link&gt; 标签改成一个\r\n\r\n    <link rel=\"stylesheet\" href=\"css/main.css\">\r\n\r\n#### 合并 js 文件\r\n\r\n合并 js 文件的步骤略复杂些。首先也是新建一个 js 文件，叫 js/main.js：\r\n\r\n    document.write('<script src=\"js/a.js\"></script>');\r\n    document.write('<script src=\"js/b.js\"></script>');\r\n    document.write('<script src=\"js/c.js\"></script>');\r\n\r\n然后把 index.html 中的 3 个 &lt;script&gt; 标签改成一个\r\n\r\n    <script src=\"js/main.js\"></script>\r\n\r\n接下来就是配置打包工具的时间了。\r\n\r\n#### 禁止自动补齐 define(...) 的头尾\r\n\r\n    skipModuleInsertion: true\r\n\r\n#### 强制建立依赖\r\n\r\n    modules: [{name: 'main', include: ['a', 'b', 'c']}]\r\n\r\n这样打包出来的 main.js 是这样的：\r\n\r\n    // code from a.js\r\n    // code from b.js\r\n    // code from c.js\r\n    document.write('<script src=\"js/a.js\"></script>');\r\n    document.write('<script src=\"js/b.js\"></script>');\r\n    document.write('<script src=\"js/c.js\"></script>');\r\n\r\n#### 打包时去掉多余的 js/main.js 的代码\r\n\r\n    onBuildRead: function (moduleName, path, contents) {\r\n        if (moduleName === 'main') {\r\n            contents = '/* empty code */';\r\n        }\r\n        return contents;\r\n    }\r\n\r\n这样的话，打包工具就会把 `document.write(...)` 的代码去掉，得到干净的\r\n\r\n    // code from a.js\r\n    // code from b.js\r\n    // code from c.js\r\n    /* empty code */\r\n\r\n运行 `node r.js -o config.js` 就可以得到一个打包成功的项目了，并且打包前后的代码都可以正常运行\r\n\r\n附件是这个项目例子的源代码：[project.zip](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/03/1894338901.zip)"},"77":{"title":"实践","slug":"do-practice","created":1369155603,"modified":1370167777,"text":"上周末在图灵的技术沙龙分享了自己Node.JS的一些项目实践心得。\r\n\r\nNode.JS这东西说起来也是3年前就听说的东西了，最近一段时间才真正拿它做东西。这种感觉既熟悉又陌生，熟悉在听大家谈过无数次，陌生在自己没怎么亲自动过手。这回的一些尝试和项目实践，让我更多的了解了这门技术，也更好的了解了我自己。\r\n\r\n分享的在线链接在此：[http://t.cn/zHIafSq](http://t.cn/zHIafSq)，这里就不重复其中的内容了。\r\n\r\n![《程序员》201303期封面](http://www.programmer.com.cn/wp-content/uploads/2013/02/QQ截图20130225140912-231x300.jpg)\r\n\r\n我想更多说的是，我们有幸在HTML5快速发展的时代，这里几乎每天都会有新的规范、新的工具、新的库、新的框架、新的理论。玲琅满目，目不暇接。也许我们每天走马灯似的看它们，都不一定看得过来。我感觉自己就长期处于这种状态。可是当这些东西都只是我们眼前的匆匆过客，来不及细细体验、品味其中的内涵，那和从来都没看过相比，有多少实质上的差别呢？\r\n\r\n我觉得这里有两件事情值得考虑：第一，要再多些时间在新技术的关注和尝试上；第二，有选择性的深入其中。\r\n\r\n先说第一点，我们不能始终沉醉在对现有技术或业务的娴熟之中，同时要相信技术和产品、设计、市场、商务一样，可以驱动业务的发展和进步。我们唯有带着这样的信念去工作，去和同事交流，去和领导沟通，去在团队里一起探讨问题，才会令自己有这种空间和时间。凡事都有难处，但总要走出这第一步。\r\n\r\n第二，前端这个词逐渐由html/css/js三门语言和基本ps技巧的集合，变成一个无限宽泛的概念。我们在鼓励全面发展的同时，也不能一把抓，也需要量力而行，循序渐进，找到属于自己的突破口，找到和自身工作最佳的结合点。最关键的是，要有实践的机会。\r\n\r\n人生有时难免会站在命运的十字路口，左右为难。最后发现，真正让自己踏实下来的，往往是这些真材实料的东西。"},"82":{"title":"Connect中间件使用手册","slug":"connect-middleware-manual","created":1370169930,"modified":1370178107,"text":"以下内容大多译自[Connect官网](http://www.senchalabs.org/connect/) 2013-06-02\r\n\r\nConnect是基于Node的中间件框架(middleware framework)，提供超过18种官方中间件以及更多的第三方中间件。\r\n\r\n示例：\r\n\r\n    var app = connect()\r\n      .use(connect.logger('dev'))\r\n      .use(connect.static('public'))\r\n      .use(function(req, res){\r\n        res.end('hello world\\n');\r\n      })\r\n     .listen(3000);\r\n\r\n安装方式：\r\n\r\n    $ npm install connect\r\n\r\n依次介绍官方中间件\r\n\r\n<!--more-->\r\n\r\n### 1. 日志 logger\r\n\r\n服务器请求日志，支持自定义格式，支持传入 `options` 选项对象或 `format` 字符串。\r\n\r\n#### 选项\r\n\r\n* `format` 表示日志格式的字符串，由各种记号(token)组合而成\r\n* `stream` 表示输出到哪里。默认是 `stdout`\r\n* `buffer` 表示缓冲的时间间隔，默认为 1000ms\r\n* `immediate` 是否在请求(request)的时候立即写日志，而不是在回应(response)的时候\r\n\r\n#### 记号(Tokens)\r\n\r\n* :req[header] (如 :req[Accept])\r\n* :res[header] (如 :res[Content-Length])\r\n* :http-version、:response-time、:remote-addr、:date、:method、:url、:referrer、:user-agent、:status\r\n\r\n#### 默认的日志格式(Formats)\r\n\r\n `default` 、 `short` 、 `tiny`\r\n\r\n其中 `default` 代表的格式是：\r\n\r\n    :remote-addr - - [:date] \":method :url HTTP/:http-version\" :status :res[content-length] \":referrer\" \":user-agent\"\r\n\r\n另外还有 `dev` 格式，可以着色输出响应状态，开发时适用。\r\n\r\n#### 其它\r\n\r\n记号和格式都是可以自定义更多的，通过\r\n\r\n* `connect.logger.token(name, function (req, res) {...})` 和\r\n* `connect.logger.format(name, stringOrFunction)`\r\n\r\n更多细节请[移步至此](http://www.senchalabs.org/connect/logger.html)\r\n\r\n### 2. 防止跨域伪造请求 csrf\r\n\r\n默认情况下该中间件会生成一个名为“_csrf”的记号，该记号可以作为请求的状态、表单提交的隐藏属性值或查询字符串等等，并在服务器端与 `req.session._csrf` 属性进行核对。如果核对出错，则会出现403错误。\r\n\r\n默认的 `value` 函数会以此核对 `bodyParser()` 中间件生成的 `req.body` 、 `query()` 生成的 `req.query` 以及名为“X-CSRF-Token”的头信息。\r\n\r\n该中间件需要会话支持，因此必须出现在 `session()` 和 `cookieParse()` 中间件之后。\r\n\r\n默认的 `defaultValue()` 实现如下：\r\n\r\n    function defaultValue(req) {\r\n      return (req.body && req.body._csrf)\r\n        || (req.query && req.query._csrf)\r\n        || (req.headers['x-csrf-token']);\r\n    }\r\n\r\n更多细节请[移步至此](http://www.senchalabs.org/connect/csrf.html)\r\n\r\n### 3. 压缩 compress\r\n\r\nGzip压缩的中间件\r\n\r\n支持的方法都在 `connect.compress.methods` 中，通过 `connect.compress.filter(req, res)` 方法判断文件是否需要压缩，默认压缩Content-Type含json、text或javascript的文件。\r\n\r\n更高级的操作是可以将具体压缩方法的参数通过options参数传进去：\r\n\r\n    connect.compress({\r\n        chunkSize: ..., // default 16*1024\r\n        windowBits: ...,\r\n        level: ..., // 0-9\r\n        memLevel: ..., // 1-9\r\n        strategy: ...\r\n    })\r\n\r\n更多细节请[移步至此](http://www.senchalabs.org/connect/compress.html)\r\n\r\n### 4. HTTP基础认证 basicAuth\r\n\r\n* 提供回调函数 `connect.basicAuth(function (user, pass) {...})` ，如果这个回调函数返回 `true` ，则获得访问权限。\r\n* 提供异步的调用方式 `connect.basicAuth(function (user, pass, callback))`\r\n* 直接有效的单一用户名密码的方式 `connect.basicAuth('username', 'password')`\r\n\r\n更多细节请[移步至此](http://www.senchalabs.org/connect/basicAuth.html)\r\n\r\n### 5. 主体解析器 Body Parser\r\n\r\n可扩展的解析器，对请求的body进行解析。支持_application/json_、_application/x-www-form-urlencoded_、_multipart/form-data_\r\n\r\n其等同于：\r\n\r\n    app.use(connect.json());\r\n    app.use(connect.urlencoded());\r\n    app.use(connect.multipart());\r\n\r\n更多细节请[移步至此](http://www.senchalabs.org/connect/bodyParser.html)\r\n\r\n### 5.1 json\r\n\r\n_application/json_解析器，并将结果放至 `req.body`\r\n\r\n#### 选项\r\n\r\n* `strict` 是否严格解析，当值为 `false` 时，理论上 `JSON.parse()` 能解析的数据都是被允许的\r\n* `reviver` 用作 `JSON.parse()` 方法的第二参数\r\n* `limit` 字节数限制，默认不开启\r\n\r\n更多细节请[移步至此](http://www.senchalabs.org/connect/json.html)\r\n\r\n### 5.2 urlencoded\r\n\r\n_application/x-www-form-urlencoded_解析器，并将结果放至 `req.body`\r\n\r\n#### 选项\r\n\r\n* `limit` 字节数限制，默认不开启\r\n\r\n更多细节请[移步至此](http://www.senchalabs.org/connect/urlencoded.html)\r\n\r\n### 5.3 multipart\r\n\r\n_multipart/form-data_解析器，并将结果放至 `req.body` 和 `req.files`\r\n\r\n#### 选项\r\n\r\n* `limit` 字节数限制，默认不开启\r\n* `defer` 延时处理并不等 `end` 事件触发就调用 `req.form.next()` 展示大表单。该选项在需要绑定 `progress` 事件时可用。\r\n\r\n更多细节请[移步至此](http://www.senchalabs.org/connect/multipart.html)\r\n\r\n### 6. 超时时间 timeout\r\n\r\n用法： `connect.timeout(ms)` 。如果请求超时则指向408错误。\r\n\r\n另， `req` 对象会多一个 `req.clearTimeout()` 方法，用来在必要的情况下取消计时。\r\n\r\n更多细节请[移步至此](http://www.senchalabs.org/connect/timeout.html)\r\n\r\n### 7. Cookie解析器 cookieParser\r\n\r\n解析头中的_Cookie_并将结果放至 `req.cookies` 。你还可以通过 `connect.cookieParser(secret)` 中的 `secret` 参数对cookie进行加密。该密码可以通过 `req.secret` 进行取值。\r\n\r\n更多细节请[移步至此](http://www.senchalabs.org/connect/cookieParser.html)\r\n\r\n### 8. 会话 session\r\n\r\n详情略。\r\n\r\n更多细节请[移步至此](http://www.senchalabs.org/connect/session.html)\r\n\r\n### 9. 基于cookie的会话支持 cookieSession\r\n\r\n    connect.cookieSession({ secret: 'tobo!', cookie: { maxAge: 60 * 60 * 1000 }});\r\n\r\n#### 选项\r\n\r\n* `key` cookie名，默认是 `connect.sess`\r\n* `secret` 密码\r\n* `cookie` 会话cookie的设置，默认是 `{ path: '/', httpOnly: true, maxAge: null }`\r\n* `proxy` 信任反向代理\r\n\r\n#### 清除会话\r\n\r\n    req.session = null;\r\n\r\n更多细节请[移步至此](http://www.senchalabs.org/connect/cookieSession.html)\r\n\r\n### 10. 支持伪造HTTP方法 methodOverride\r\n\r\n当检查到方法重载的时候，把原方法存入 `req.originalMethod` ，检查的字段可以通过参数 `key` 设置，默认为 `_method`\r\n\r\n    connect.methodOverride(key)\r\n\r\n更多细节请[移步至此](http://www.senchalabs.org/connect/methodOverride.html)\r\n\r\n### 11. 响应时间 responseTime\r\n\r\n计算响应时间并展示为 `X-Response-Time` 头\r\n\r\n更多细节请[移步至此](http://www.senchalabs.org/connect/responseTime.html)\r\n\r\n### 12. 静态服务缓存 staticCache\r\n\r\n在内存中建立static中间件的缓存。默认最大缓存对象为128个，每个对象的最大体积是256k，总共大约32mb。\r\n\r\n#### 选项\r\n\r\n* `maxObjects` 最大缓存对象个数，默认128个\r\n* `maxLength` 最大缓存对象体积，默认256kb\r\n\r\n更多细节请[移步至此](http://www.senchalabs.org/connect/staticCache.html)\r\n\r\n### 12.1 静态文件服务 static\r\n\r\n为给定的 `root` 路径提供静态文件服务，例如\r\n\r\n    connect.static(__dirname + '/public', {maxAge: 86400000})\r\n\r\n#### 选项\r\n\r\n* `maxAge` 浏览器缓存时间，默认是 `0`\r\n* `hidden` 是否允许访问隐藏文件，默认是 `false`\r\n* `redirect` 路径是目录时是否在结尾自动加 `/` ，默认是 `true`\r\n\r\n#### MIME表\r\n\r\n展示MIME模块，可读写\r\n\r\n    connect.static.mime\r\n\r\n更多细节请[移步至此](http://www.senchalabs.org/connect/static.html)\r\n\r\n### 13. 目录 directory\r\n\r\n列出目录的文件列表\r\n\r\n#### 选项\r\n\r\n* `hidden` 是否显示点(.)开头的文件，默认是 `false`\r\n* `icons` 是否显示文件图标，默认是 `false`\r\n* `filter` 过滤文件的函数，默认是 `false`\r\n\r\n图标文件在 `lib/public/icons/` 目录中\r\n\r\n#### 其它\r\n\r\n* `connect.directory.html()` 输出html格式的内容\r\n* `connect.directory.json()` 输出json格式的内容\r\n* `connect.directory.plain()` 输出文本格式的内容\r\n\r\n更多细节请[移步至此](http://www.senchalabs.org/connect/directory.html)\r\n\r\n### 14. 虚拟主机 vhost\r\n\r\n例如：\r\n\r\n    connect()\r\n      .use(connect.vhost('foo.com', fooApp))\r\n      .use(connect.vhost('bar.com', barApp))\r\n      .use(connect.vhost('*.com', mainApp))\r\n\r\n更多细节请[移步至此](http://www.senchalabs.org/connect/vhost.html)\r\n\r\n### 15. 站点图标 favicon\r\n\r\n默认图标为 `lib/public/favicon.ico` ，可更改，调用方式：\r\n\r\n    connect.favicon('public/favicion.ico', {maxAge: 86400000})\r\n\r\n#### 选项\r\n\r\n* `maxAge` 过期时间，默认是1天(86400000)\r\n\r\n更多细节请[移步至此](http://www.senchalabs.org/connect/favicon.html)\r\n\r\n### 16. 请求大小限制 limit\r\n\r\n限制请求的body字节数，可传入一个数字或代表容量大小的字符串，比如： `5mb` 、 `200kb` 、 `1gb`\r\n\r\n    connect.limit('5.5mb')\r\n\r\n更多细节请[移步至此](http://www.senchalabs.org/connect/limit.html)\r\n\r\n### 17. 查询字符串 query\r\n\r\n自动解析查询字符串，生成 `req.query`\r\n\r\n更多细节请[移步至此](http://www.senchalabs.org/connect/query.html)\r\n\r\n### 18. 错误处理 errorHandler\r\n\r\n灵活的错误处理机制，开发环境下提供出错信息和栈追踪，回应信息支持纯文本、HTML和JSON\r\n\r\n* 在_text/plain_的情况下回应文本格式的错误信息\r\n* 在_application/json_情况下，回应 `{ \"error\": error }`\r\n* 在允许的情况下回应HTML错误信息\r\n\r\n更多细节请[移步至此](http://www.senchalabs.org/connect/errorHandler.html)\r\n\r\n(完)"},"83":{"title":"用Sass重新整理自己的博客主题样式","slug":"write-my-theme-with-sass","created":1370370190,"modified":1370959474,"text":"![Sass](http://sass-lang.com/images/sass.gif)\r\n\r\n远远关注[Sass](http://sass-lang.com)很久了，今天终于鼓起勇气写了[我的第一个Sass文件](http://jiongks.sinaapp.com/usr/themes/iambig-3d/style.sass)\r\n\r\n### Sass简介\r\n\r\n一种CSS的预处理程序，基于Ruby运行。安装过程和相关的准备工作非常简单：\r\n\r\n0. 当然首先要安装[Ruby](http://www.ruby-lang.org/)\r\n1. `gem install ruby`，必要的环境下需要在命令前加上`sudo`\r\n2. 进入我的博客主题文件夹，运行`sass-convert style.css style.sass`，把我的css文件先转换成sass文件\r\n3. 运行`sass --watch style.sass:style.css`，使得程序自动把`style.sass`文件接下来的任何改动自动同步转换到`style.css`\r\n\r\n这时，新的Sass文件就创建完毕了！^_^ 去碎觉……\r\n\r\n呵呵，开个玩笑。其实这样的Sass文件虽然格式上没有任何问题，但和直接撰写CSS几乎没区别。而Sass除了可以让我们少写几个花括号和分号之外，其实还有很多实用的特性是我们真正需要的。\r\n\r\n无论如何，现在的这个Sass文件是一个整理的基础，接下来，我们就来一步一步整理这个文件，同时也一步一步熟悉Sass的特性。\r\n\r\n<!--more-->\r\n\r\n### Variables: 变量与计算\r\n\r\n我把CSS文件中通用的字体、颜色等等属性值归纳了出来，并找到其中的相关性，比如文本框的边框颜色始终比链接的文字颜色亮一些，即：\r\n\r\n    a {\r\n      color: #0c0;\r\n    }\r\n    \r\n    input:not([type]),\r\n    input[type=\"text\"],\r\n    input[type=\"password\"] {\r\n      border: 2px lime solid;\r\n    }\r\n\r\n在Sass中将其改写为：\r\n\r\n    $color-link: #0c0\r\n    \r\n    a\r\n      color: $color-link\r\n    \r\n    input:not([type]),\r\n    input[type=\"text\"],\r\n    input[type=\"password\"]\r\n      border: 2px lighten($color-link, 10%) solid\r\n\r\n即可，输出的结果不变。\r\n\r\n### Nesting：选择器嵌套\r\n\r\n把嵌套着的选择器添加不同的缩进，同时把重复表达的外层选择器去掉。如：\r\n\r\n    h2 {\r\n      margin: 0.75em 0;\r\n      padding: 0.25em 0.5em;\r\n      background-color: rgba(0, 204, 0, 0.4);\r\n      color: #339933;\r\n    }\r\n    \r\n    h2 strong {\r\n      color: white;\r\n    }\r\n    \r\n    h2 a {\r\n      color: #009900;\r\n    }\r\n    \r\n    h2 a:hover {\r\n      background: yellow;\r\n      color: black;\r\n    }\r\n\r\n可以转换为：\r\n\r\n    h2\r\n      margin: 0.75em 0\r\n      padding: 0.25em 0.5em\r\n      background-color: rgba($color-link, 0.4) // 链接颜色，透明度40%\r\n      color: desaturate($color-link, 50%) // 链接颜色，饱和度减少50%\r\n    \r\n      strong\r\n        color: white\r\n    \r\n      a\r\n        color: darken($color-link, 10%) // 链接颜色，变暗10%\r\n    \r\n        &:hover\r\n          background: $color-mark // 特殊标记的颜色\r\n          color: black\r\n\r\n### Mixin：将可重用的CSS属性值混入不同的CSS规则当中\r\n\r\n这个特性是我花最多时间整理的，整理过后发现整个文件结构真的清晰很多。\r\n\r\n#### 提取出成套的样式\r\n\r\n比如我的博客主题中，3D的标题和按钮就是两套集成度重用性都很高的样式，我创建了`@mixin title-3d`和`@mixin button-3d`两个大的属性集合：\r\n\r\n    @mixin title-3d\r\n      ...\r\n      &::before,\r\n      &::after\r\n        ...\r\n      ...\r\n    \r\n    @mixin button-3d\r\n      ...\r\n      &::before,\r\n      &::after\r\n        ...\r\n      &:hover::before\r\n        ...\r\n      &:hover::after\r\n        ...\r\n      ...\r\n\r\n随后我把这些属性集合应用到了标题和按钮上：\r\n\r\n    h2\r\n      @include title-3d\r\n    \r\n    button,\r\n    input[type=\"button\"],\r\n    input[type=\"submit\"],\r\n    .button-3d\r\n      @include button-3d\r\n\r\n#### 继续归纳和抽象\r\n\r\n整理完上面这两个大的集合之后，我发现，其实3d的标题和按钮样式上其实也有很多想通的地方，于是我进一步抽象出了一些3d模型的通用集合：\r\n\r\n    @mixin short-transform\r\n      -webkit-transition: -webkit-transform 0.3s\r\n    \r\n    @mixin transform-origin-0\r\n      -webkit-transform-origin: 50% 50%\r\n    @mixin transform-origin-1\r\n      left: 0\r\n      top: 0\r\n      -webkit-transform-origin: 0% 0%\r\n    @mixin transform-origin-2\r\n      right: 0\r\n      top: 0\r\n      -webkit-transform-origin: 100% 0%\r\n    @mixin transform-origin-3\r\n      right: 0\r\n      bottom: 0\r\n      -webkit-transform-origin: 100% 100%\r\n    @mixin transform-origin-4\r\n      left: 0\r\n      bottom: 0\r\n      -webkit-transform-origin: 0% 100%\r\n    \r\n    @mixin init-3d\r\n      @include short-transform\r\n      @include transform-origin-0\r\n      -webkit-transform-style: preserve-3d\r\n    \r\n    @mixin p-element\r\n      position: absolute\r\n      content: \"\"\r\n\r\n然后到之前的集合把这些通用集合抽象出来：\r\n\r\n    @mixin title-3d\r\n      @include init-3d\r\n      ...\r\n    \r\n      &::after,\r\n      &::before\r\n        @include p-element\r\n        @include short-transform\r\n        background-color: lighten($color-text, 30%)\r\n    \r\n      &::before\r\n        height: 100%\r\n        width: $button-3d-height*2\r\n        @include transform-origin-1\r\n        ...\r\n    \r\n      &::after\r\n        height: 100%\r\n        width: $button-3d-height*2\r\n        @include transform-origin-2\r\n        ...\r\n\r\n#### 统一封装不同浏览器的CSS前缀\r\n\r\n    @mixin box-sizing($sizing: border-box)\r\n      -moz-box-sizing: $sizing\r\n      box-sizing: $sizing\r\n    \r\n    @mixin transform($value...)\r\n      -webkit-transform: $value\r\n      transform: $value\r\n    \r\n    @mixin transform-origin($value)\r\n      -webkit-transform-origin: $value\r\n      transform-origin: $value\r\n    \r\n    @mixin transform-3d($value: preserve-3d)\r\n      -webkit-transform-style: $value\r\n      transform-style: $value\r\n    \r\n    @mixin transform-perspective($value: 350px)\r\n      -webkit-perspective: $value\r\n      perspective: $value\r\n    \r\n    @mixin transition($value...)\r\n      -webkit-transition: $value\r\n      transition: $value\r\n    \r\n    @mixin transition-transform($duration: 0.3s)\r\n      -webkit-transition: -webkit-transform $duration\r\n      transition: transform $duration\r\n    \r\n    ...\r\n\r\n### Extend：选择器的继承\r\n\r\n其实这个特性和mixin很多时候可以二选一使用，比如这里的`.button-3d`选择器可以不必和`button`、`input[type=\"button\"]`、`input[type=\"submit\"]`写在一起，可以写成：\r\n\r\n    .button-3d\r\n      ...\r\n    \r\n    button,\r\n    input[type=\"button\"],\r\n    input[type=\"submit\"]\r\n      @extend .button-3d\r\n\r\n不过我这里这样写的必要性不太大，所以就没有实际的例子可以分享了。\r\n\r\n### 结语\r\n\r\n最终[我的第一个Sass文件](http://jiongks.sinaapp.com/usr/themes/iambig-3d/style.sass)就这样整理完毕了。(p.s.当然这个文件未来可能还是会有改动，届时可能会和本篇文章描述的内容不符)\r\n\r\n经过上面这几轮代码的整理，这个Sass文件才真的很Sass了。回顾这次整理的过程，先后用到了变量、运算、嵌套、重用属性等Sass的特性，简单明了，而且`sass --watch`命令、`sass-convert`命令可以方便的对文件进行监听和格式转换。我几乎在感觉不到学习成本的情况下提高了开发效率。这里也推荐大家试试看。"},"84":{"title":"秦升拿到红牌之后……","slug":"qin-sheng-effect-in-the-national-team","created":1370963766,"modified":1370964958,"text":"![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/3893919286.jpg)\r\n\r\n* 工体上空飘扬着“傻X”的洪亮口号，晚上天津牌照的车又被砸了不少\r\n* 比赛收视率直线下降——比赛才开始了13分钟，还有80分钟呢\r\n* 赞助商的脸全都绿了，下次国足的比赛就没有再打广告了，不过无非是又有别的厂商挨宰了\r\n* 谭晶从此霉运不断\r\n* 看台上两国外交部长正在谈一个上百亿的项目，荷兰大爷若有所思的说：这个我们回去再考虑考虑…… 对面：恩，下次我们还是改一起看乒乓球吧\r\n* 刘建宏紧紧攥着双拳：完了完了，今天这场球大Boss都在看啊，这种球我该肿么说比较得体呢？肿么办肿么办……\r\n* 小区里：还是很安静的，现在大家看球都不是看彩电了，要么是笔记本电脑，不舍得扔下去，要么是大平板电视，扔不动\r\n\r\n<!--more-->\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/705297956.jpg)\r\n\r\n----\r\n\r\n* 之前荷兰队在踢友谊赛，国足在踢训练赛，裁判在吹国际A级比赛；之后荷兰队在踢训练赛，国足在踢国际A级比赛，裁判在吹友谊赛\r\n* 国家队队友们一脸茫然，以前友谊赛都是中国裁判，都给足面子。再一次国家队的比赛，裁判仍然是中国裁判\r\n* 范加尔赛后接受采访时称自己不开心，被荷兰足协粗卖了，荷兰众将罢训，范佩西代表球员出席了新闻发布会称，这是让我们去送死\r\n* 从此世界上再没有一支球队愿意跟中国队过招，除非他们国家的足协为了金钱利益出卖了他的球队\r\n* 以穆里奇、孔卡为首的外援球员代表联名发表声明，要求足协：\r\n    1. 修改足球规则，国内球员犯规即黄牌，两次犯规直接红牌罚下，累计5次犯规赛季报销，并且该判罚带入下一年的亚冠联赛；\r\n    2. 取消外援名额限制，全外援球队可以免税，国内球员只能进攻不能防守，且只能穿平底鞋；\r\n    3. 外援球员年龄超过28岁还能健康上场的，政府每分钟给500欧元补助\r\n* 各大俱乐部听闻此消息，纷纷抢购秦升，最后上海申花以创纪录的8000万RMB签下了这名才华横溢的屠夫，他和戴琳组成了令人闻风丧胆的秦岭组合\r\n* 德容本想来中超安度职业生涯的晚年，结果第二天他直接宣布退役\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/1411657687.jpg)\r\n\r\n----\r\n\r\n* 范佩西和罗本对视了一下：兄弟，下次有这种五五开的球你就别争了，跳起来躲过去算了，别说我没提醒过你\r\n* 罗本：我们这样不好吧，开场13分钟就把人家给逼疯了，以后人家不请我们来了。于是几个荷兰老乡达成一致默契，只踢门柱，踢到门柱算得分，踢进算丢分，最终凭借斯内德的一记乌龙球，比分定格在了2比2，但是赛后罗本遭到了范佩西的痛斥……\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/3346630100.jpg)\r\n\r\n----\r\n\r\n* 里皮：X，买秦升的钱算是白花了\r\n* 卡马乔：X，我下次再用秦升我就是孙子！p.s.我还有下次么\r\n* 某：明天叫小蔡来我办公室一趟\r\n* 米卢：呵呵\r\n* 阿里汉：呵呵\r\n* 克劳琛：呵呵\r\n* 霍顿：呵呵\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/3138749147.jpg)\r\n\r\n----\r\n\r\n### 最后\r\n\r\n中国队输球之后回到更衣室，卡马乔甩下一句中国国骂就离去了，翻译一时糊涂还翻译成了西班牙国骂，随后也尴尬离去，气氛很凝重，大家都闷不吭声……30秒后，秦升终于忍不住先开口了：“哎呀今天这球输了都算我的，晚上我请客，咱们去三里屯不醉不归！”，顿时更衣室云开雾散，大家又快快乐乐的在一起了^_^\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/2130036830.jpg)\r\n\r\n博君一笑 (配图皆来自于互联网)"},"92":{"title":"细节无微不至，彩屏让人又爱又恨——新老“神机”大对决：Nokia 1050 vs Nokia 1202","slug":"nokia-1050-vs-1202-report","created":1371287556,"modified":1371370084,"text":"### 吐在前面的槽……\r\n\r\n今年，在老罗锤子手机一路跳票、累不死手机活蹦乱跳、魅族手机版本号即将输给小米、iOS被拍扁、Windows Phone在卖萌、安卓在卖身等诸多鸟事相继雷到众生之后，人们无不感叹，手机这个行业还有救吗？站在智能和愚蠢的十字路口，我们该何去何从？囧rz\r\n\r\n就在大家迷茫之时，Nokia发布了它的又一力作——1050！整个业界犹如刮来了一股春风，无不感到清新舒畅。大家纷纷感叹，那个曾经的科技巨人就要王者归来鸟！这个夏天，This summer，最受瞩目的大事件，big event！就是：\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/1458120974.jpg)\r\n\r\nNokia 1050 的发布！！！\r\n\r\n作为一个反智能化手机操作系统的支持者，我很自豪的宣布，经历了前两轮的预定失败之后，我终于在上周成功订到了这款神机——要不要卖得这么好啊 - -\r\n\r\n我之前用的手机是[Nokia 1202](http://baike.baidu.com/view/1969934.htm)，2008年的神机，其实也不算太老，要不是1050发布，它也其实已经是一个非常现代化、非常新款的愚蠢手机了，无奈在这个1050的时代趋势下也不得不接受停产的命运。\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/2984211007.jpg)\r\n\r\n1050基本上继承了1202所有的成员函数和成员变量，小巧大方，简单易用，低碳环保，超长待机，便宜实惠，这已经足以吊起广大消费者的胃口了。然而真正的1050到底表现如何？它能否在1202的光环之下更进一步再创辉煌？带着这些疑问，记者走访了不少xxx，挖掘出了很多珍贵的xxxx，也听到了各种xxxxxxxx……\r\n\r\nOK 马上开始\r\n\r\n### 目录\r\n\r\n1. 开箱/外观\r\n2. 屏幕\r\n3. 主界面\r\n4. 基本功能 (电话/短信/通讯录)\r\n5. 特色功能\r\n6. 实用工具\r\n7. 性能/续航能力\r\n8. 综述\r\n\r\n<!--more-->\r\n\r\n### 开箱/外观\r\n\r\n从体型上看，1050比1202略大了一圈，基本上没有怎么影响便携性，因为它已经真的足够小巧了，放包里、裤子口袋里、憋在身体的各种地方都没有负担。相比之下，1050不论是蓝色还是黑色更时尚一些，尤其是她的背影，但略略略显厚重点点点。\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/1284621649.jpg)\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/4180636176.jpg)\r\n\r\n充电器还是和以前一样，很小巧，绝对耐用耐看\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/3106019371.jpg)\r\n\r\n电池和1202想比，由860mAh减少到了800mAh\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/3694790703.jpg)\r\n\r\n### 屏幕\r\n\r\n毫无疑问，1050到1202最大的变化就是从白屏到彩屏了，1202的屏幕更宽更扁一些，1050则是更方更高一些，1202正常情况下可以显示8x5个汉字，而1050则是在8x5的基础上还能在上面放一行小标题和信号、电量的信息。这样的话，1202之前只能在具体功能页面中隐藏信号、电量信息、然后上面显示一行标题，下面显示左右两个按钮，正文只有3三行；而1050不但可以始终显示信号、电量信息，还可以显示4行正文，这比之前是有提升的。但另一方面，其实屏幕的绝对精度是提高了，所以屏幕高度只有略微的增加，而且宽度还小了一些。这是屏幕上的变化。\r\n\r\n### 主界面\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/549573935.jpg)\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/2719444340.jpg)\r\n\r\n正常情况下，两款手机的主界面基本一样，无非是1050在时钟下面多空了一行，不过主界面的变化还是很明显的：\r\n\r\n#### 待机\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/3960757426.jpg)\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/1838377718.jpg)\r\n\r\n先说待机，1202在待机的时候是关闭背景灯光，并始终显示时钟；而1050由于彩屏的缘故，可能会更耗电一些，所以待机的时候背景灯光和时钟全部都是关掉的。在导致的体验差异是：如果你需要看表，1202在白天可以直接拿起来看，1050则需要按任意键点亮屏幕。我觉得这一点上体验是下降的，当然这也可以理解为彩屏的代价吧\r\n\r\n#### 锁屏\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/93044640.jpg)\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/1387369891.jpg)\r\n\r\n在众多智能手机还在为如何解锁、会不会有专利问题伤透脑筋的时候，Nokia系列愚蠢手机在就完美解决了这个问题：“开锁键->星号键”，pretty simple！什么？怕忘？没关系，系统在必要的时候都有提示的。\r\n\r\n说到提示，这是我想说的一个重点：1202对于解锁的提示是一个非常强的提示，在锁屏状态下，只要你不是在键入“开锁键->星号键”，就会有一个全屏提示说：“要想解锁请按开锁键再按星号键”，但其实我有的时候只是想在光线比较暗的场合看一下时间，这其实是很令人恼火的一件事。1050抓住了这个用户痛点！它在待机状态下只接受开锁键和开机键这两个事件，开机键用来点亮屏幕，这个时候可以直接看表，除非用户再按了别的键，才会出现那个提示。\r\n\r\n#### 快捷键\r\n\r\n1050多了两个非常实用的快捷键！\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/3310827569.jpg)\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/3297825630.jpg)\r\n\r\n1. 星号键上多画了一个时钟和气泡的结合体的图案，长按这个键，系统会自动语音报时。——天呐，有语音功能的愚蠢手机！没想到能愚蠢成这样！！\r\n2. 与之对应的，井号键上多画了一个被划掉的音符，没错，长按这个键，可以快速切换到静音模式。真是太方便了！前一个功能我还不太用得到，这个功能真的是设计得很贴心啊！！\r\n\r\n#### 主菜单\r\n\r\n1050的主菜单相比较1202的主菜单也发生了视觉上的变化\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/1017268432.jpg)\r\n\r\n1202的主菜单是一个图片轮播一样的界面，同时只显示一个命令，外加左右键的提示\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/2942170707.jpg)\r\n\r\n1050的主菜单则为用户提供了两种选择，一种是列表，每屏可以显示两个命令，可以上下翻阅，它的特点是字大看得清楚；另一种则是launchpad一样的图标列表，它的好处是对图形敏感的用户可以快速的找到最下面的命令，不必在列表模式下一直翻到最下面才知道有什么。\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/3218795380.jpg)\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/40495363.jpg)\r\n\r\n### 基本功能\r\n\r\n要说一个手机应该做什么事？这回到一个非常严肃的问题：什么叫智能手机？什么叫愚蠢手机？(此处省略1000字)\r\n\r\n一个手机最应该做好的，当然是电话、短信、通讯录了！1020和1050在这方面做得非常出色，它可以在如此小巧的一亩三分田里做到智能手机才能做到的事。1050更是在1202的基础上做出了多项功能改进。\r\n\r\n#### 电话\r\n\r\n1202和1050的电话功能基本一致，不过在国内这种嘈杂的环境中，这两款神机的嗓门显得有点力不从心。1202的听筒音量根据我多年的使用经验其实是可以的，1050的听筒音量比1202更小一些，我有的时候索性打开免提模式了，那个音量在人多嘈杂的环境中是刚好的。但这两款手机有个不太好的地方是周围的人同样会听得很清楚，尤其是1202，貌似声音是直接通过扬声器传出来的，没有特别的听筒发音，所以手机正反面发出去的音量差不多，有一定的隐私问题。如果有什么私密事宜要在电话里谈，建议选好地方。\r\n\r\n#### 短信\r\n\r\n这个就值得多说一说了，1050在短信上的改进还是很贴心的。\r\n\r\n__首先是由于屏幕由3行正文变成了4行正文__，在输入短信的时候有了更多的预览空间，这是很明显的一个改进。\r\n\r\n__第二，在选择发送人时加入了一个最近发出人的列表界面。__\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/3296032181.jpg)\r\n\r\n之前只有两个选择：\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/1581698311.jpg)\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/4271129285.jpg)\r\n\r\n1. 输入手机号->右键发送，要么\r\n2. 左键进入通讯录->选择联系人->右键发送。\r\n\r\n现在的流程变成：\r\n\r\n1. 选择最近发出人->左键发送\r\n2. 选择输入号码->输入手机号->右键发送\r\n3. 选择输入号码->左键进入通讯录->选择联系人->右键发送\r\n\r\n这样的话，发给常发的人变得更快捷了。我个人的使用经验是90%的短信都是直接在这个列表里选的。真的省了很多时间。\r\n\r\n不过我在这里还有一点点改进的建议，因为选择联系人发送的步骤其实由3步操作变成了4步操作，我建议把选择联系人的选项直接放在选择最近发出人列表的最上面作为默认选项，选择输入号码放在第二选项或最下面，保持3步操作\r\n\r\n__第三，一键回复短信。__\r\n\r\n在Nokia的键盘设计理念里，每一个按键都有很鲜明的特色和传统。说到这里不得不系统的介绍一下：\r\n\r\n* 上方控制区\r\n    * 两侧功能键\r\n        * 左侧两个按键：永远表示确认、前进、接听电话等含义，且左下比左上的思想感情更强烈，我们暂定它们分别是确认键和接听键(因为上面画了接听电话的图案)\r\n        * 右侧两个按键：永远表示取消、退出、挂断电话、关机等含义，同理右下比右上的表意更直接，我们暂停它们分别是取消键和挂断键(因为上面画了挂断电话和电源的图案)\r\n    * 中间方向键\r\n* 下方数字区\r\n    * 0-9数字键\r\n    * 左下方星号键：特殊字符输入、键盘锁组合键之一等\r\n    * 右下方井号键：输入法切换等\r\n\r\n介绍这个是因为在最新的设计里，发送短信如果按下确认键，会打开菜单，提供发送等各种功能选择，然后才跳入我们刚才介绍的发送短信的流程；如果按下接听键，可以直接来到这个流程。\r\n\r\n而更贴心的是，如果我是在回复一则短信而不是发送一条新短信，这时按下接听键，系统会直接把短信发出去——没错就直接发给来短信的这个号码。怎么样，是不是感觉很贴心呢 ^_^\r\n\r\n__第四，支持调整短信文字大小。__\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/3420771039.jpg)\r\n\r\n你也许不会相信，这种简朴的屏幕居然还能调“分辨率”？！没错，1050支持三种文字大小——汉字！如果你眼神不好，可以选择最大字号，如果你想看到更多内容，可以选择最小字号。老少皆宜！感受一下\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/626708193.jpg)\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/1270387034.jpg)\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/3454995005.jpg)\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/2900024459.jpg)\r\n\r\n其实除此之外，1202也已经有很多优质的特性了，1050也同样支持——这就是传承！有底蕴的科技公司！！\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/3091628759.jpg)\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/1915016688.jpg)\r\n\r\n* 比如这个免打扰列表，可以屏蔽各种垃圾短信：怎么样！别以为只有智能机会做到这一点\r\n* 比如这个经典的中文输入法，说实话我至今觉得Nokia的中文输入法是手机里最好的输入法，你可以很快让自己的打字速度达到一个很高的境界，不管是拼音输入还是笔画输入。而且它的智能匹配足够精准，反应速度也飞快，按键触感也很舒服。神马叫在键盘上跳舞的感觉！用过Nokia就知道了\r\n* 当然了，还是要客观的说，这里同样有一些不足。但其实有的时候作为一名用户，它不一定是坏事。比如它不支持彩信。我擦！我太喜欢这个不足了！！！\r\n* 还有就是从打字速度上看，1050比1202略略略卡了一点点，但依然在“流畅”的范围内\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/2526348236.jpg)\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/16178673.jpg)\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/3390359229.jpg)\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/2784130009.jpg)\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/267723737.jpg)\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/2754428720.jpg)\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/785031628.jpg)\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/2901927375.jpg)\r\n\r\n#### 通讯录\r\n\r\nNokia的通讯录管理也是很经典的，我有点不打算多介绍了，我只想说一点：把通讯录存在SIM卡上！秒杀一切所谓的云同步，它们全都是炒概念，想挖你的数据，像Siri一样。如果三方服务你都信不过，那这个绝对是最实用最可靠的！\r\n\r\n### 特色功能\r\n\r\n说到这里，先大笑三声：哈~哈~哈~哈~\r\n\r\n#### 同步时间\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/1490480284.jpg)\r\n\r\n在1202里有一个软肋，就是它不计时间，只要电池拔下来，再装上，就要重新设定时间。它们真是会压缩成本啊 - -\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/1853389973.jpg)\r\n\r\n1050不光解决了这一顽疾，而且支持“自动更新日期和时间”，你能想象吗？这是多么先进的理念！\r\n\r\n#### 日历直接显示农历\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/3275043154.jpg)\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/1296841095.jpg)\r\n\r\n1050做到了！10个字：贴心！\r\n\r\n而且绑定备忘录、支持公历农历快速查询——这是1202和1050都具备的\r\n\r\n#### 情景模式\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/2692030712.jpg)\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/3308503579.jpg)\r\n\r\n1202和1050都支持情景模式，按下挂断键，就会看到这个选项列表\r\n\r\n刚才介绍了，在1050中，还支持长按井号键快速切换到静音模式，其实是对这个功能的一个进化\r\n\r\n#### 主题切换\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/704865510.jpg)\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/4094213667.jpg)<br>\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/1170576262.jpg)\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/1677694698.jpg)\r\n\r\n没错！1050有主题切换哦，只需简单的2-3步操作——这可是iOS需要在6和7之间升级/降级才做得到的事情哦！\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/3015748822.jpg)\r\n\r\none more thing：你还可以修改配色方案的细节！天呐，这是神马神机呢！200块的手机可以如此DIY，我三观都改变了！！\r\n\r\n#### 铃声\r\n\r\n1050的手机铃声有点不如1202了，可能是我个人品味的问题吧，Nokia的默认手机铃声其实旋律是很经典的，但是音色一直在变化，从最早的蜂鸣声开始。1202是钢琴音色，自己听着很舒服，而1050换了个说不上来的音色，我个人还是比较喜欢钢琴音色的那个版本。无奈之下我换了另外一个铃声，不过也算不错了，Nokia的铃声选择可比iOS的丰富多了，并且震动可以根据铃声的节奏震动。这个特性连HTML5都还没讨论出结论呢。\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/2523663893.jpg)\r\n\r\n再有就是有个小乐趣消失了，就是自创铃声。1202是支持的，1050把这个功能去掉了。不过平心而论，我很少用这个，所以不太在乎了。不知道大家是不是这种音乐发烧友，如果是的话，建议还是不要升级新版本了，1202也不错。\r\n\r\n### 实用工具\r\n\r\n我觉得nokia推出的各种“实用工具”虽然在我看来是不务正业，但这是对智能手机最大的讽刺。你们烧硬件、烧系统、烧应用、各种烧，不就是做了这点事么？\r\n\r\n#### 手电筒\r\n\r\n苹果从上周的iOS7开始才意识到手机可以用来当手电，我觉得这好讽刺，因为他们没有重新定义手电，而是在视图定义手机的时候不小心做成了手电。我觉得Nokia才是重新定义了手电，它诚意十足，它不是闪光灯的副产品，而是真的有意配了个灯泡给你当手电啊亲！！Tim-Cock你不觉得惭愧吗？\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/3235219319.jpg)\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/690782628.jpg)\r\n\r\n在临床作业中，我们发现，1050的手电筒效果比1202的光线更集中，发光效果更好，更符合手电筒的使用需求。细节！细节！！\r\n\r\n#### 单位转换\r\n\r\n足球场上人墙的距离为嘛是9.15米呢？iPhone用户该怎么办？打开Safari，在搜索框里艰难的输入问题，然后在一系列的网络不给力之后，比赛结束了，你还在思考人生。\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/627546625.jpg)\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/2907468223.jpg)<br>\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/2580395044.jpg)\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/3991995477.jpg)\r\n\r\n看看Nokia是什么态度！内嵌各种单位转换，无需网络。\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/702563673.jpg)\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/3936051895.jpg)\r\n\r\n你也许会说，就那么几个写死的单位换算，一点都不高级。错！我要拿截图和亲身经历告诉你Nokia的单位转换是有API的！！只要你知道公式，想换算什么都可以！！\r\n\r\n#### 记账\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/3209615051.jpg)\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/619834395.jpg)\r\n\r\nOMG！别挖财了，看看Nokia是怎么给你提供解决方案的。\r\n\r\n#### 游戏\r\n\r\n我很想把Nokia手机里的游戏秀给你们看，真的。早就不是神马贪吃蛇数独之辈了。It's AMAZING！It's SO GREAT！That is FANTASTIC！UNBELIEVABLE！我觉得这个应该是一个真正的诺基亚用户独享的东西，所以，想即刻拥有来自诺基亚的经典游戏么？还在等什么！赶紧去排队预购吧！！\r\n\r\n#### 收音机\r\n\r\n我要崩溃了……连这个都有\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/2461671507.jpg)\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/3471174416.jpg)\r\n\r\n美中不足是需要耳机啊，要是能功放就更完美了，不然这绝对是在地铁里公交车上秀给那些iOS安卓屌丝们的最佳利器！！\r\n\r\n#### 捷径\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/06/1099386446.jpg)\r\n\r\n常用功能的快捷方式都在这里了，可以自由定制，比如我就把收件箱、闹钟、未接电话和已接来电放到了这里\r\n\r\n#### 砸核桃\r\n\r\n这个我没测，愚蠢手机也是手机啊！不能浪费的好吧。诸位大神谁帮忙测一下呗，绝对的业界良心！\r\n\r\n#### 小结\r\n\r\n我觉得Nokia要是够聪明，就适可而止吧，做成这样刚刚好。这些功能也不用做太多，做个意思，输出一下自己的价值观就足够了。另外该操作系统不提供截屏功能，这给它的市场传播带来了一定的困难。希望将来Nokia可以支持截图上传微博的功能，这个就真心碉堡了，毕竟Nokia还是一家老牌的有实力的科技公司。\r\n\r\n### 性能/续航能力\r\n\r\n从总体的性能情况看，就像之前介绍到的，1050比1202各方面响应速度，在同样合理的范围内，要略慢一些，有两种可能，一种可能是彩屏拖慢了速度，另一种可能就是Nokia其实也在成本和性能之间找寻平衡。从这一点上讲，1202的硬件配置其实是很奢侈的，1202才是一台真正的超值高性能主机。难怪它会停产啊，我为曾经用过这样的神机而骄傲！所以，1050不但可以比1202做得更好用，甚至在商业利益上也超越了前作。\r\n\r\n从续航能力看，实际实用时间没有理论待机时间35天那么长，充一次电差不多可以正常使用1周，和1202差不多。但实际上它的电池容量从860mAh降到了800mAh。我们不得不再次感叹，Nokia在传说中如此成熟的直板机制造业，还能不断突破自我，勇往直前！换个图标把UI拍平了神马的就敢说自己突破自我绝对是百事可乐喝多了有木有\r\n\r\n### 综述\r\n\r\n综上所述。Nokia 1050的最大变化来自于彩屏，其实细细想来，整款手机的一些列变化其实都是围绕着屏幕展开的。作为一个环保主义者，我其实觉得彩屏是个很奢侈的改变，它几乎违背了Nokia科技以人为本的办学理念。但是它由此带来的改进和便捷却是感同身受的。另外可以看出来Nokia在什么是手机、手机应该是什么样子、手机的未来在哪里这三个问题上有着非常睿智的独到见解。这家老牌的手机厂商、曾经的移动终端霸主，在经历了一段短暂的迷茫之后，终于找到了正确的发展方向。从前两轮预购都被秒光的态势来看，我们有理由相信，1050将引领一波轰轰烈烈的反智能化手机的热潮，并有理由期待Nokia的未来带给我们的更多惊喜。\r\n\r\n完"},"153":{"title":"精气神儿","slug":"i-am-working-hard","created":1374586722,"modified":1374587731,"text":"“国足打出了精气神儿”\r\n\r\n相关新闻：[东亚杯-王永珀2球孙可建功 中国两球落后3-3日本](http://cs.sports.163.com/match/report/2702.html)\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2013/07/2059864972.jpg)\r\n\r\n当我再一次看到这样的标题的时候，我就知道，言外之意是国足的状况一定非常糟糕。\r\n\r\n精气神儿是个什么东西？我觉得是一种最基本的态度，它只是个精神层面的很虚的过程。我举个例子，当你一无所有的时候，你只能说：哦，至少我还有节操。——这就是拿精气神儿说事儿的节奏。\r\n\r\n国足说我们努力了，大家说其实人家从上到下还是很努力的，这一点我们还是要认可的……好吧你们确实真的很努力，但为时已晚。而且国足真的很差，现在才知道努力有个屁用？未雨绸缪的事情怎么从来没见足协做过？\r\n\r\n以前国足被叫作头球队，叫热身赛之王，如今头球也没了，热身赛也能输个精光，连博彩公司的小伙伴们都惊呆了。\r\n以前几年赢不了韩国就说恐韩，如今15年不胜日本了，也没人造出个什么恐日了，因为觉得跟人家比不自量力，丢不起那人。\r\n以前国足98年，当时还叫东亚四强赛，国足在日本的主场2比0羞辱对手，范志毅还踢飞丢了一个点球，不然就是3比0的大胜（对，两边都是成人队，而且都是男足）。如今在一片铺天盖地的唾骂声中，国足才开始努力，开始打出精气神儿，勉强在最后时刻，逼平了日本二线队。\r\n\r\n国足的努力掩盖不了一个事实，那就是战绩糟糕，排名持续下滑，多年无缘各项国际大赛。\r\n这有什么可高兴的？\r\n\r\n所以请别扯淡！拿成绩说话！！\r\n\r\n看看今天的国足，还剩下什么？答：“只剩下两滴冰冷的泪水：一滴化斗酒添一份麻醉；一滴沉落于岁月的潮水。”\r\n\r\n好。我这里对国足的吐槽完毕。\r\n\r\n其实我没想太多聊国足。\r\n\r\n接下来，请把“国足”二字换成你看到“其实很努力”之后首先联想到的事物，然后把上面全文的“国足”二字换掉重读一遍。相信你会很有乐趣和感悟。"},"171":{"title":"Chrome开发者工具中评估性能的五大新特性","slug":"devtools-five-performance-features","created":1379500623,"modified":1386730326,"text":"摘自：[Chrome DevTools Revolutions 2013](http://www.html5rocks.com/en/tutorials/developertools/revolutions2013/)\r\n\r\n本次开发者工具的改进中有几项新特性是针对性能的：\r\n\r\n* 持续绘制模式\r\n* 显示绘制矩形及其层的边框\r\n* 每秒帧数的测量仪\r\n* 找到强制同步布局(layout thrashing)\r\n* 对象分配跟踪\r\n\r\n<!--more-->\r\n\r\n### 持续绘制模式\r\n\r\n持续绘制模式是开发者工具设置中的一个选项(**渲染**>**开启持续页面绘制**)，这个选项可以帮助你识别单个元素或CSS样式的渲染开销。\r\n\r\n通常Chrome只在响应一个布局或样式的变化时绘制屏幕，并且只是绘制屏幕中需要更新的区域。当你开启持续页面绘制选项时，整个屏幕都会不断的重绘。一个置顶的界面会展示Chrome在绘制页面时所花费的时间，以及近期绘制时间的分布图。穿过整个直方图的那条横线代表16.6毫秒标记线。\r\n\r\n![置顶的绘制时间界面](http://1-ps.googleusercontent.com/x/s.html5rocks-hrd.appspot.com/www.html5rocks.com/en/tutorials/developertools/revolutions2013/xpaint-times.png.pagespeed.ic.4GHJaoT9je.webp)\r\n\r\n这样做的好处是你可以走遍DOM树中的元素面板，隐藏单个元素(隐藏当前选中元素的快捷键是H)或关闭一个元素的CSS样式。通过留意页面绘制时间的变化，你可以看到单个元素或样式为页面渲染所增加的“负担”。如果隐藏一个元素使得绘制时间明显下降，那么你要重点关照一下这个元素的样式或构造了。\r\n\r\n开启持续绘制模式的方法：\r\n\r\n1. 打开开发者工具的设置\r\n2. 打开**常规**选项卡，在**渲染**中，打开**开启持续页面重绘**\r\n\r\n注意：如果你看不到这个设置项，请打开**about:flags**，打开**在所有页面中使用GPU合成**，并重启Chrome。\r\n\r\n更多信息，请移步至：[用开发者工具的持续绘制模式进行长绘制时间的性能分析](http://updates.html5rocks.com/2013/02/Profiling-Long-Paint-Times-with-DevTools-Continuous-Painting-Mode)\r\n\r\n### 显示绘制矩形及其层的边框\r\n\r\n另一个开发者工具的选项是展示正在被绘制的矩形区域(设置>渲染>展示绘制矩形)。比如，在下面这个屏幕截图中，一个矩形正在被绘制，在这里，CSS悬停效果被应用到了紫色图形中。\r\n\r\n![网站展示绘制中的矩形](http://1-ps.googleusercontent.com/x/s.html5rocks-hrd.appspot.com/www.html5rocks.com/en/tutorials/developertools/revolutions2013/xpaint-rect-1.png.pagespeed.ic.vrXLmQcKHF.webp)\r\n\r\n你得回避导致整个界面被重绘的设计实践与开发实践。比如，在下面这个屏幕截图中，用户正在滚动页面。一个绘制矩形覆盖在了滚动条上，另有一个绘制矩形覆盖在了整个页面的剩余部分。它的罪魁祸首是body元素的背景图片。该背景图片是fixed定位的，它要求Chrome每次滚动页面的时候都得重绘整个页面。\r\n\r\n![网站展示全屏幕的重绘](http://1-ps.googleusercontent.com/x/s.html5rocks-hrd.appspot.com/www.html5rocks.com/en/tutorials/developertools/revolutions2013/xpaint-rect-2.png.pagespeed.ic.G7rwOiDpvh.webp)\r\n\r\n### 每秒帧数测量仪\r\n\r\n**每秒帧数测量仪**显示了页面当前的帧率、最小帧率和最大帧率、一个展示帧率随时间变化的条形图、以及不同帧率分布的直方图。\r\n\r\n![每秒帧数测量仪](http://1-ps.googleusercontent.com/x/s.html5rocks-hrd.appspot.com/www.html5rocks.com/en/tutorials/developertools/revolutions2013/xfps-meter.png.pagespeed.ic.s2bF1Y3FUT.webp)\r\n\r\n开启每秒帧数测量仪的方法：\r\n\r\n1. 打开开发者工具的设置\r\n2. 打开**常规**选项卡\r\n3. 在**渲染**中，打开*强制加速合成*以及**显示每秒帧数测量仪**\r\n\r\n你可以通过打开**about:flags**，然后开启**每秒帧数计数器**并重启Chrome，来强制每秒帧数测量仪始终显示。\r\n\r\n### 寻找强制同步布局(layout thrashing)\r\n\r\n为了最大化渲染性能，Chrome通常会在应用程序中批处理布局变化请求，并制定一个日程来异步计算和渲染这些变化请求。尽管如此，当一个应用程序获取依赖于布局的属性值的时候(比如offsetHeight或offsetWidth)，Chrome会强制立刻同步渲染页面布局。我们称之为强制同步布局。这会明显的降低渲染的性能，在大DOM树中重复运行时尤为明显。这种情形也被称之为“layout thrashing”。\r\n\r\n当我们检测到一个强制同步布局的时候，时间线记录中会有警告，它会在相应的时间线记录边上显示一个黄色的警告图标。鼠标悬停在这些记录上会看到无效的布局的代码堆栈记录、以及造成强制布局的代码堆栈记录。\r\n\r\n![时间线视图中的强制同步布局弹泡](http://1-ps.googleusercontent.com/x/s.html5rocks-hrd.appspot.com/www.html5rocks.com/en/tutorials/developertools/revolutions2013/xforced-sync-layout-popup.png.pagespeed.ic.fvGqEI6wkY.webp)\r\n\r\n该弹泡同时展示了需要布局的结点数量、重新布局的树的尺寸、布局的范围和布局的根。\r\n\r\n更多信息，请移步至：[时间线Demo：诊断强制同步布局](https://developers.google.com/chrome-developer-tools/docs/demos/too-much-layout/)\r\n\r\n### 对象分配跟踪\r\n\r\n对象分配跟踪是一个新型的内存描述资料，它可以实时展示内容分配的情况。当你开始分配跟踪时，开发者工具实时持续生成堆的快照。堆分配的描述资料展示了对象在哪里被创建，且识别被保留的路径。\r\n\r\n![堆分配描述资料的视图](http://www.html5rocks.com/en/tutorials/developertools/revolutions2013/allocation-tracker.png)\r\n\r\n跟踪对象分配的方法：\r\n\r\n1. 打开开发者工具，点击**描述资料**选项卡\r\n2. 选择**记录堆分配**然后点击**开始**\r\n3. 当你完成数据的收集之后，点击**停止记录堆描述信息**(描述资料面板左下角的红色的圆)。"},"172":{"title":"视觉差，走起！","slug":"parallax","created":1379841077,"modified":1386730331,"text":"翻译自：[http://www.html5rocks.com/en/tutorials/speed/parallax/](http://www.html5rocks.com/en/tutorials/speed/parallax/)\r\n\r\n### 简介\r\n\r\n现在满大街都是视觉差(parallax)网站了，我们随便看几个：\r\n\r\n* [Old Pulteney Row to the Pole](http://www.rowtothepole.com/)\r\n* [Adidas Snowboarding](http://www.adidas.com/com/apps/snowboarding/)\r\n* [BBC News - James Bond: Cars, catchphrases and kisses](http://www.bbc.co.uk/news/entertainment-arts-20026367)\r\n\r\n也许你对这玩意儿还不太熟，视觉差其实就是它的视觉结构会随着页面的滚动而变化。通常情况下页面里的元素会根据页面的滚动位置而缩放、旋转或移动。\r\n\r\n![一个视觉差页面的demo](http://www.html5rocks.com/static/demos/parallax/parallax.jpg)  \r\n我们的视觉差demo的完整效果\r\n\r\n不管你喜不喜欢视觉差网站，有一件事毫无疑问，它是一个性能的黑洞。因为当页面滚动时，浏览器的优化都倾向于新内容随滚动而出现于屏幕的最上方或最下方的情况。一般来说，内容改变得越少浏览器性能越高。而对于一个视觉差网站来说，在页面滚动时，好多元素都在发生改变，大多数情况下整个页面的大块可视元素都在发生变化，所以浏览器不得不重绘整个页面。\r\n\r\n我们有理由这样归纳一个视觉差的网站：\r\n\r\n* 背景元素会在你向上或向下滚动页面时改变位置、旋转或缩放。\r\n* 页面内容，如文字或小的图片，在页面滚动时会按照传统的方式进行上下移动。\r\n\r\n建议大家先阅读我们之前介绍过的[滚动性能](http://www.html5rocks.com/en/tutorials/speed/scrolling/)来改进你的app的响应速度。本篇文章是基于那篇文章所写的。\r\n\r\n所以文字是如果你在建立一个视觉差网站，那么你是否受困于高昂的重绘开销？有没有别的改进建议使得性能最大化？让我们看看这几个方案：\r\n\r\n<!--more-->\r\n\r\n### 方案1：使用DOM元素和绝对定位\r\n\r\n这是很多人默认采取的方案。页面里有一大堆元素，任何时候只要触发滚动事件，这些元素就会进行各种变换来完成视觉上的更新。我已经用这个方式写好了一个[demo页面](http://www.html5rocks.com/static/demos/parallax/demo-1a/demo.html)。\r\n\r\n如果你打开开发者工具的时间线的帧模式的话，滚动页面，你会发现各种全屏重绘，这个代价是很高的。如果你滚动多一些，你会发现在一个单个帧里出现了好多滚动事件，每个事件都会触发布局操作。\r\n\r\n![Chrome开发者工具中未优化过的滚动事件](http://www.html5rocks.com/static/demos/parallax/paints.png)  \r\n开发者工具展示了一个单个帧里的大块绘制以及多个由事件触发的布局操作\r\n\r\n需要铭记的要点是为了达到60fps(匹配传统显示器60赫兹的刷新频率)，我们需要在16毫秒之内搞定一切。在这个版本中我们使得每次滚动事件都造成了视觉上的变化。但是我们之前的文章[用requestAnimationFrame做出更经济实惠的动画](http://www.html5rocks.com/en/tutorials/speed/animations/)和[滚动性能](http://www.html5rocks.com/en/tutorials/speed/scrolling/)已经讨论过，这样做和浏览器的更新机制并不相符，所以我们要么会错过帧，要么会在同一帧里做了多余的工作。这样的网站无法给人一种纯天然不刺激的感觉，用户就会不爽。\r\n\r\n让我们把更新界面的代码从滚动事件里拿出来，放到`requestAnimationFrame`的回调函数里吧，滚动事件只是简单的不惑滚动的值。我们的[第二个demo页面](http://www.html5rocks.com/static/demos/parallax/demo-1b/demo.html)在此。\r\n\r\n如果你重复滚动测试，你可能会注意到一个轻微的改进，尽管不算明显。原因是因滚动而触发的布局操作并不总是代价昂贵了，但在其他用例中它很可能是。现在至少我们把布局操作限制在了每帧一次。\r\n\r\n![Chrome开发者工具中反跳动之后的滚动事件](http://www.html5rocks.com/static/demos/parallax/paints-raf.png)  \r\n开发者工具展示了一个单个帧里的大块绘制以及多个由事件触发的布局操作\r\n\r\n现在我们可以每帧绑定一个也可以绑定一百个滚动事件，但我们只记录`requestAnimationFrame`回调函数运行时最近的值并更新到视图上。这里的重点是之前每次滚动事件触发时都强制更新视图，现在则是请求浏览器提供一个合适的窗口来做这件事。怎么样？不错吧！\r\n\r\n这个方式的主要问题在于，不论`requestAnimationFrame`与否，整个页面基本上是一个层。通过移动周围的这些可视元素，我们需要大块的重绘。通俗地讲，绘制是一个阻塞操作(虽然这已经在[改变](http://www.chromium.org/developers/design-documents/impl-side-painting))，也就是说浏览器无法做任何其它的工作，我们经常会超出每帧16毫秒的预算，页面还是无法纯天然不刺激。\r\n\r\n### 方案2：使用DOM元素和3D变换\r\n\r\n不同于绝对定位的另一个方案是我们可以将元素应用到3D变换当中。在这种情形下，我们将这些应用3D变换的元素视为一个新的层，并且在WebKit浏览器中，它通常会导致一个硬件层面的转变。在方案1种，相比之下，我们有一个大的重绘的层，这个层的任何改变都会在CPU中绘制和组合。\r\n\r\n也就是说，在这个方案中，一切变得不一样了：我们为应用3D变换的任何元素提供一个潜在的层。如果我们从这一点出发进行元素的变换那么我们无需重绘这个层，而GPU可以处理这些元素的移动并组合成最后的页面。\r\n\r\n这里有[另一个demo](http://www.html5rocks.com/static/demos/parallax/demo-2/demo.html)展示了3D变换的使用。如果你滚动页面你将会发现效果得到了大幅度的改善。\r\n\r\n人们多次使用`-webkit-transform: translateZ(0);`做hack并看到惊人的性能提升，但今天看来有几个问题：\r\n\r\n1. 这并不是跨浏览器兼容的\r\n2. 它强制浏览器为每个元素创建一个新的层。大量的层同样会带来性能瓶颈。所以请尽量少用。\r\n3. 有些WebKit ports是禁用这个的。\r\n\r\n如果你谨慎使用3D变换的话，这确实是一个临时解决方案！理想化的讲，我们可以在2D变换时看到和3D同样的渲染特性。浏览器正在以惊人的速度一步一步发展，所以希望这就是我们将会看到的。\r\n\r\n最后，你应该针对性的避免绘制任何你可以在页面内简单移动的元素。举个视觉差网站通用的例子，固定div的高度并改变齐背景的位置来提供视觉差效果。不行的是这个元素需要在每次运动的时候都进行重绘，这会带来性能的损耗。取而代之的是，如果可以，你应该创建元素(有必要的话将其包裹在一个`overflow: hidden`的div中)并对齐进行简单的移动。\r\n\r\n### 方案3：使用固定位置的canvas或WebGL\r\n\r\n我们考虑的终极方案，就是使用一个固定位置的canvas放在页面最底层，把我们想要绘制的各种变换图形都画在里面。一眼看上去这并不像是最优方案，但是这个方案确实有它的一些优势：\r\n\r\n* 我们不再需要组合工作了，只需要一个canvas元素就行了\r\n* 我们通过*硬件加速*高效处理一张大位图\r\n* Canvas2D API善于处理我们需要的各种变换，开发和维护都变得很容易。\r\n\r\n使用canvas元素给了我们一个新的层，但是仅此*一个*层，而在方案2种，我们实际是为*每个*应用3D变换的元素都创建了一个新的层。所以我们需要组合所有的层到一起，这是一个会增长的工作量。鉴于不同浏览器对变换的不同实现，这同时也是跨浏览器兼容性最好的方案。\r\n\r\n如果你看看基于这个方案的[这个demo](http://www.html5rocks.com/static/demos/parallax/demo-3/demo.html)，在开发者工具里测试一下，你会发现性能非常好。这个方案我们简单的使用了canvas的`drawImage` API调用，并且我们将其背景图片和每个色块都绘制在屏幕上正确的位置。\r\n\r\n    /**\r\n     * Updates and draws in the underlying visual elements to the canvas.\r\n     */\r\n    function updateElements () {\r\n    \r\n      var relativeY = lastScrollY / h;\r\n    \r\n      // Fill the canvas up\r\n      context.fillStyle = \"#1e2124\";\r\n      context.fillRect(0, 0, canvas.width, canvas.height);\r\n    \r\n      // Draw the background\r\n      context.drawImage(bg, 0, pos(0, -3600, relativeY, 0));\r\n    \r\n      // Draw each of the blobs in turn\r\n      context.drawImage(blob1, 484, pos(254, -4400, relativeY, 0));\r\n      context.drawImage(blob2, 84, pos(954, -5400, relativeY, 0));\r\n      context.drawImage(blob3, 584, pos(1054, -3900, relativeY, 0));\r\n      context.drawImage(blob4, 44, pos(1400, -6900, relativeY, 0));\r\n      context.drawImage(blob5, -40, pos(1730, -5900, relativeY, 0));\r\n      context.drawImage(blob6, 325, pos(2860, -7900, relativeY, 0));\r\n      context.drawImage(blob7, 725, pos(2550, -4900, relativeY, 0));\r\n      context.drawImage(blob8, 570, pos(2300, -3700, relativeY, 0));\r\n      context.drawImage(blob9, 640, pos(3700, -9000, relativeY, 0));\r\n    \r\n      // Allow another rAF call to be scheduled\r\n      ticking = false;\r\n    }\r\n    \r\n    /**\r\n     * Calculates a relative disposition given the page’s scroll\r\n     * range normalized from 0 to 1\r\n     * @param {number} base The starting value.\r\n     * @param {number} range The amount of pixels it can move.\r\n     * @param {number} relY The normalized scroll value.\r\n     * @param {number} offset A base normalized value from which to start the scroll behavior.\r\n     * @returns {number} The updated position value.\r\n     */\r\n    function pos(base, range, relY, offset) {\r\n      return base + limit(0, 1, relY - offset) * range;\r\n    }\r\n    \r\n    /**\r\n     * Clamps a number to a range.\r\n     * @param {number} min The minimum value.\r\n     * @param {number} max The maximum value.\r\n     * @param {number} value The value to limit.\r\n     * @returns {number} The clamped value.\r\n     */\r\n    function limit(min, max, value) {\r\n      return Math.max(min, Math.min(max, value));\r\n    }\r\n\r\n当你处理大图片(或其它可方便绘制到canvas中的元素)的时候，这个方案效果不错，但是处理大块文字的时候这个方案会遇到更多的挑战，但还是可以根据你的网站的情况成为最合适的方案。如果你不得不在canvas里处理文本，你可以使用`fillText` API方法，但是它的可访问性会打折扣(你把文字转成了位图！)并且你不得不处理文字的折行等一些列细节。如果你可以避免它，你真的应该，也更有可能更好的使用上面的变换方案。\r\n\r\n既然我们尽可能往远了想，那么没有理由断定视觉差的工作应该在一个canvas元素内完成。如果浏览器支持的话，我们可以使用WebGL。这里的关键在于WebGL有最直接的显卡API调用方式，也是你最有可能达到60fps的方式，尤其在网站效果比较复杂的时候。\r\n\r\n你立刻觉得使用WebGL有点过于夸张了，或者WebGL尚未被广泛的支持，但是如果你使用类似[Three.js](https://github.com/mrdoob/three.js/)的工具，你总是可以降级到使用canvas元素同时你的代码被抽象为了一致且友好的形态。所有我们需要的是使用[Modernizr](http://modernizr.com/)检查相关的API支持情况：\r\n\r\n    // check for WebGL support, otherwise switch to canvas\r\n    if (Modernizr.webgl) {\r\n      renderer = new THREE.WebGLRenderer();\r\n    } else if (Modernizr.canvas) {\r\n      renderer = new THREE.CanvasRenderer();\r\n    }\r\n\r\n然后使用Three.js的API替换掉我们对上下文的处理。这里的[demo](http://www.html5rocks.com/static/demos/parallax/demo-4/demo.html)同时支持了两个渲染方式，假设你的浏览器也会如此！\r\n\r\n作为这个方案的最终思考，如果你不会在页面里放太多额外的元素的话，你可以总是[使用canvas作为背景元素](http://updates.html5rocks.com/2012/12/Canvas-driven-background-images)，这Firefox和基于WebKit的浏览器中都可以。很明显这确实不是无处不在的，所以我们平时使用的时候要小心谨慎。\r\n\r\n### 取决于你们的实际情况\r\n\r\n开发者默认更多使用绝对定位的元素实现视觉差的主要原因其实就是其特性的支持程度。这在某种程度上是幻觉，因为老的目标浏览器很可能提供的是一个极其糟糕的渲染体验。甚至在今天的现代浏览器中，使用绝对定位元素还是无法保障好的性能。\r\n\r\n3D变换为你提供了直接操作DOM元素的能力，并可以达到不错的帧率。成功的关键就是在你简单的移动周围元素时避免了绘制。一定记住，WebKit浏览器在这个过程中创建了层，但这和其它浏览器并不相关，所以要在提交方案之前一定要测试确认。\r\n\r\n如果你只是定位于顶级浏览器，且可以通过canvas渲染网站，拿canvas可能是你最好的选择。当然如果你使用[Three.js](https://github.com/mrdoob/three.js/)，你应该可以根据你需要的支持情况选择在不同的渲染方式之间进行切换。\r\n\r\n### 总结\r\n\r\n我们已经评估了几个视觉差网站的实现方案，从决定定位元素到使用固定位置的canvas。当然，你需要的实现方式，依赖于你希望达到的特定的设计效果，但有这几个可选方案总是好的。\r\n\r\n还是那句话，不论你用哪个方案：别妄加猜测，试试就知道了。"},"173":{"title":"JavaScript V8性能小贴士","slug":"v8-javascript-performance-tips","created":1380454333,"modified":1386730336,"text":"译自：[Performance Tips for JavaScript in V8](http://www.html5rocks.com/en/tutorials/speed/v8/)\r\n\r\n### 简介\r\n\r\n关于如何巧妙提高V8 JavaScript性能的话题，Daniel Clifford在Google I/O上做了[一次非常精彩的分享](http://www.youtube.com/watch?v=UJPdhx5zTaw)。Daniel鼓励我们“追求更快”，认真的分析C++和JavaScript之间的性能差距，根据JavaScript的工作原理撰写代码。在Daniel的分享中，有一个核心要点的归纳，我们也会根据性能指导的变化保持对这篇文章的更新。\r\n\r\n### 最重要的建议\r\n\r\n最重要的是要把任何性能建议放在特定的情境当中。性能建议是附加的东西，有时一开始就特别注意深层的建议反而会对我们造成干扰。你需要从一个综合的角度看待你的Web应用的性能——在关注这些性能建议之前，你应该找[PageSpeed](https://developers.google.com/speed/pagespeed/)之类的工具大概分析一下你的代码，也算是跑个分先。这会防止你过度优化。\r\n\r\n对Web应用的性能优化，几个原则性的建议是：\r\n\r\n* 首先，未雨绸缪\r\n* 然后，找到症结\r\n* 最后，修复它\r\n\r\n为了完成这几个步骤，理解V8如何优化JS是一件很重要的事情，这样你就可以根据其对JS运行时的设计撰写代码。同样重要的是掌握一些帮得上忙的工具。Daniel也交代了一些开发者工具的用法，它们刚好抓住了一些V8引擎设计上最重要的部分。\r\n\r\nOK。开始V8小贴士。\r\n\r\n<!--more-->\r\n\r\n### 隐藏类\r\n\r\nJavaScript限制编译时的类型信息：类型可以在运行时被改变，可想而知这导致JS类型在编译时代价昂贵。那么你一定会问：JavaScript的性能有机会和C++相提并论吗？尽管如此，V8在运行时隐藏了内部创建对象的类型，隐藏类相同的对象可以使用相同的生成码以达到优化的目的。\r\n\r\n比如：\r\n\r\n    function Point(x, y) {\r\n      this.x = x;\r\n      this.y = y;\r\n    }\r\n    \r\n    var p1 = new Point(11, 22);\r\n    var p2 = new Point(33, 44);\r\n    // At this point, p1 and p2 have a shared hidden class\r\n    // 这里的p1和p2拥有共享的隐藏类\r\n    p2.z = 55;\r\n    // warning! p1 and p2 now have different hidden classes!\r\n    // 注意！这时p1和p2的隐藏类已经不同了！\r\n\r\n在我们为p2添加“z”这个成员之前，p1和p2一直共享相同的内部隐藏类——所以V8可以生成一段单独版本的优化汇编码，这段代码可以同时封装p1和p2的JavaScript代码。我们越避免隐藏类的派生，就会获得越高的性能。\r\n\r\n#### 结论\r\n\r\n* 在构造函数里初始化所有对象的成员(所以这些实例之后不会改变其隐藏类)\r\n* 总是以相同的次序初始化对象成员\r\n\r\n### 数字\r\n\r\n当类型可以改变时，V8使用标记来高效的标识其值。V8通过其值来推断你会以什么类型的数字来对待它。因为这些类型可以动态改变，所以一旦V8完成了推断，就会通过标记高效完成值的标识。不过有的时候改变类型标记还是比较消耗性能的，我们最好保持数字的类型始终不变。通常标识为有符号的31位整数是最优的。\r\n\r\n比如：\r\n\r\n    var i = 42; // 这是一个31位有符号整数\r\n    var j = 4.2; // 这是一个双精度浮点数\r\n\r\n#### 结论\r\n\r\n* 尽量使用可以用31位有符号整数表示的数。\r\n\r\n### 数组\r\n\r\n为了掌控大而稀疏的数组，V8内部有两种数组存储方式：\r\n\r\n* 快速元素：对于紧凑型关键字集合，进行线性存储\r\n* 字典元素：对于其它情况，使用哈希表\r\n\r\n最好别导致数组存储方式在两者之间切换。\r\n\r\n#### 结论\r\n\r\n* 使用从0开始连续的数组关键字\r\n* 别预分配大数组(比如大于64K个元素)到其最大尺寸，令其尺寸顺其自然发展就好\r\n* 别删除数组里的元素，尤其是数字数组\r\n* 别加载未初始化或已删除的元素：\r\n\r\n　\r\n\r\n    a = new Array();\r\n    for (var b = 0; b < 10; b++) {\r\n      a[0] |= b;  // 杯具！\r\n    }\r\n    //vs.\r\n    a = new Array();\r\n    a[0] = 0;\r\n    for (var b = 0; b < 10; b++) {\r\n      a[0] |= b;  // 比上面快2倍\r\n    }\r\n\r\n同样的，双精度数组会更快——数组的隐藏类会根据元素类型而定，而只包含双精度的数组会被拆箱(unbox)，这导致隐藏类的变化。对数组不经意的封装就可能因为装箱/拆箱(boxing/unboxing)而导致额外的开销。比如：\r\n\r\n    var a = new Array();\r\n    a[0] = 77; // 分配\r\n    a[1] = 88;\r\n    a[2] = 0.5; // 分配，转换\r\n    a[3] = true; // 分配，转换\r\n\r\n下面的写法效率更高：\r\n\r\n    var a = [77, 88, 0.5, true];\r\n\r\n因为第一个例子是一个一个分配赋值的，并且对a[2]的赋值导致数组被拆箱为了双精度。但是对a[3]的赋值又将数组重新装箱回了任意值(数字或对象)。第二种写法时，编译器一次性知道了所有元素的字面上的类型，隐藏隐藏类可以直接确定。\r\n\r\n#### 结论\r\n\r\n* 初始化小额定长数组时，用字面量进行初始化\r\n* 小数组(小于64k)在使用之前先预分配正确的尺寸\r\n* 请勿在数字数组中存放非数字的值(对象)\r\n* 如果通过非字面量进行初始化小数组时，切勿触发类型的重新转换\r\n\r\n### JavaScript编译\r\n\r\n尽管JavaScript是个非常动态的语言，且原本的实现是解释性的，但现代的JavaScript运行时引擎都会进行编译。V8(Chrome的JavaScript)有两个不同的运行时(JIT)编译器：\r\n\r\n* “完全”编译器，可以为任何JavaScript生成优秀的代码\r\n* 优化编译器，可以为大部分JavaScript生成伟大(汗一下自己的翻译)的代码，但会更耗时\r\n\r\n### 完全编译器\r\n\r\n在V8中，完全编译器会以最快的速度运行在任何代码上，快速生成优秀但不伟大的代码。该编译器在编译时几乎不做任何有关类型的假设——它预测类型在运行时会发生改变。完全编译器的生成码通过内联缓存(ICs)在程序运行时提炼类型相关的知识，以便将来改进和优化。\r\n\r\n内联缓存的目的是，通过缓存依赖类型的代码进行操作，更有效率的掌控类型。当代吗运行时，它会先验证对类型的假设，然后使用内联缓存快速执行操作。这也意味着可以接受多种类型的操作会变得效率低下。\r\n\r\n#### 结论\r\n\r\n* 单态操作优于多态操作\r\n\r\n如果一个操作的输入总是相同类型的，则其为单态操作。否则，操作调用时的某个参数可以跨越不同的类型，那就是多态操作。比如add()的第二个调用就触发了多态操作：\r\n\r\n    function add(x, y) {\r\n      return x + y;\r\n    }\r\n    \r\n    add(1, 2);     // add中的+操作是单态操作\r\n    add(\"a\", \"b\"); // add中的+操作变成了多态操作\r\n\r\n### 优化编译器\r\n\r\nV8有一个和完全编译器并行的优化编译器，它会重编那些最“热门”(即被调用多次)的函数。优化编译器通过类型反馈来使得编译过的代码更快——事实上它就是使用了我们之前谈到的ICs的类型信息！\r\n\r\n在优化编译器里，操作都是内联的(直接出现在被调用的地方)。它加速了执行(拿内存空间换来的)，同时也进行了各种优化。单态操作的函数和构造函数可以整个内联起来(这是V8中单态操作的有一个好处)。\r\n\r\n你可以使用单独的“d8”版本的V8引擎来获取优化记录：\r\n\r\n    d8 --trace-opt primes.js\r\n\r\n(其会把被优化的函数名输出出来)\r\n\r\n不是所有的函数都可以被优化，有些特性会阻止优化编译器运行一个已知函数(bail-out)。目前优化编译器会排除有try/catch的代码块的函数。\r\n\r\n#### 结论\r\n\r\n* 如果存在try/catch代码快，则将性能敏感的代码放到一个嵌套的函数中：\r\n\r\n　\r\n\r\n    function perf_sentitive() {\r\n     // 把性能敏感的工作放置于此\r\n    }\r\n    \r\n    try {\r\n     perf_sentitive()\r\n    } catch (e) {\r\n     // 在此处理异常\r\n    }\r\n\r\n这个建议可能会在未来发生改变，因为我们会在优化编译器里开启try/catch代码块。你可以通过使用上述的d8选项“--trace-opt”得到更多有关这些函数的信息来检验优化编译器如何排除这些函数。\r\n\r\n    d8 --trace-opt primes.js\r\n\r\n### 取消优化\r\n\r\n最终，编译器的性能优化是有针对性的——有时它的变现并不好，我们就不得不回退。“取消优化”的过程实际上就是把优化过的代码扔掉，恢复执行完全编译器的代码。重优化可能稍后再打开，但是短期内性能会下降。尤其是取消优化的发生会导致其函数的变量的隐藏类的变化。\r\n\r\n#### 结论\r\n\r\n* 回避在优化过后函数内隐藏类改变\r\n\r\n你可以像其它优化一样，通过V8的一个日志标识来取消优化。\r\n\r\n    d8 --trace-deopt primes.js\r\n\r\n### 其它V8工具\r\n\r\n顺便提一下，你还可以在Chrome启动时传递V8跟踪选项：\r\n\r\n    \"/Applications/Google Chrome.app/Contents/MacOS/Google Chrome\" --js-flags=\"--trace-opt --trace-deopt\"\r\n\r\n额外使用开发者工具分析，你可以使用d8进行分析：\r\n\r\n    % out/ia32.release/d8 primes.js --prof\r\n\r\n它通过内建的采样分析器，对每毫秒进行采样，并写入v8.log。\r\n\r\n### 回到摘要……\r\n\r\n重要的是认识和理解V8引擎如何处理你的代码，进而为优化JavaScript做好准备。再次强调我们的基础建议：\r\n\r\n* 首先，未雨绸缪\r\n* 然后，找到症结\r\n* 最后，修复它\r\n\r\n这意味着你应该通过PageSpeed之类的工具先确定你的JavaScript中的问题，在收集指标之前尽可能减少至纯粹的JavaScript(没有DOM)，然后通过指标来定位瓶颈所在，评估重要程度。希望Daniel的分享会帮助你更好的理解V8如何运行JavaScript——但是也要确保专注于优化你自身的算法！\r\n\r\n### 参考资料\r\n\r\n* [YouTube上的Daniel分享](http://www.youtube.com/watch?v=UJPdhx5zTaw)\r\n* [Deck上的Danial的幻灯演示](http://v8-io12.appspot.com/)\r\n* [V8工程师Vyacheslav Egorov的“我要基于V8优化我们的JS应用”清单](http://mrale.ph/blog/2011/12/18/v8-optimization-checklist.html)"},"174":{"title":"通过HTML5 Canvas API调节图像的亮度和颜色","slug":"color-matrix-filters-using-the-html5-canvas","created":1381479329,"modified":1386730342,"text":"译自：[Adjusting Image Brightness and Color Using the HTML5 Canvas API](http://www.storminthecastle.com/2013/10/06/color-matrix-filters-using-the-html5-canvas/)\r\n\r\n你曾否需要调节一张图片的亮度？或者增强红色通道让它变得温暖一些？\r\n\r\n![](http://www.storminthecastle.com/wp-content/uploads/2013/04/filtered.jpg)\r\n\r\n这是我之前两篇文章“[如何通过HTML5 Canvas处理图片酷效](http://www.storminthecastle.com/2013/04/06/how-you-can-do-cool-image-effects-using-html5-canvas/)”和“[如何创建一个HTML5的大头贴应用](http://www.storminthecastle.com/2013/10/06/color-matrix-filters-using-the-html5-canvas/how-you-can-build-an-html5-photobooth-app/)”的后续。在之前的那些文章里，我提供了一些可分离的颜色滤镜代码：灰度、灰褐色、红色、变亮、变暗等。这些滤镜都是经典的颜色滤镜，每个像素点的颜色都是独立运算的，互不影响。我们的可以将其建模成一个单独数据驱动的称为颜色矩阵滤镜(Color Matrix Filter)的东西。这一概念将会遍布本文。这种滤镜将会以一个包含权重(即系数)的颜色矩阵作为输入，并决定输出的颜色组件(color component)如何和输入的颜色组建相对应。\r\n\r\n<!--more-->\r\n\r\n这个应用实例允许你在一个表格里编辑颜色矩阵，并立即把矩阵应用到当前加载的图片中。下图的表格展示了灰褐色滤镜的矩阵：\r\n\r\n![sepia](http://www.storminthecastle.com/wp-content/uploads/2013/05/sepia.png)\r\n\r\n通过这个例子，每个像素的新红色组件`r’`都将会根据给定的`r`、`g`、`b`、`a`进行如下计算：\r\n\r\n    r' = 0.393r + 0.769g + 0.189b + 0\r\n\r\n作为每个颜色组件值额外的系数`i`被加载了表格的最后，用来变量或变暗最终的计算值。同理新的`g’`、`b’`、`a’`也进行相似的计算。下面的代码展示了等同于灰褐色颜色矩阵的JavaScript数组：\r\n\r\n    var sepiaMatrix = \r\n    [\r\n      0.393, 0.769, 0.189, 0, 0,\r\n      0.349, 0.686, 0.168, 0, 0,\r\n      0.272, 0.534, 0.131, 0, 0,\r\n          0,     0,     0, 1, 0,\r\n    ];\r\n\r\n下面这段代码展示了等同于灰度特效矩阵的JavaScript数组：\r\n\r\n    var grayscaleMatrix = \r\n    [\r\n      0.33, 0.34, 0.33, 0, 0,\r\n      0.33, 0.34, 0.33, 0, 0,\r\n      0.33, 0.34, 0.33, 0, 0,\r\n         0,    0,    0, 1, 0,\r\n    ];\r\n\r\n颜色矩阵滤镜的代码如下：\r\n\r\n    colorMatrixFilter = function (pixels, m) {\r\n      var d = pixels.data;\r\n      for (var i = 0; i < d.length; i += 4) {\r\n        var r = d[i];\r\n        var g = d[i + 1];\r\n        var b = d[i + 2]; \r\n        var a = d[i + 3];\r\n\r\n        d[i]   = r * m[0] + g * m[1] + b * m[2] + a * m[3] + m[4];\r\n        d[i+1] = r * m[5] + g * m[6] + b * m[7] + a * m[8] + m[9];\r\n        d[i+2] = r * m[10]+ g * m[11]+ b * m[12]+ a * m[13]+ m[14];\r\n        d[i+3] = r * m[15]+ g * m[16]+ b * m[17]+ a * m[18]+ m[19]; \r\n      }\r\n      return pixels;\r\n    };\r\n\r\n我希望你已经乐在其中了。颜色矩阵提供了一个应用颜色滤镜的强大通用工具。\r\n\r\n[demo](http://www.storminthecastle.com/projects/colormatriximage/) & [源码](http://www.storminthecastle.com/projects/colormatriximage/colormatriximage.zip)"},"175":{"title":"语义化版本管理","slug":"semantic-versioning","created":1385910318,"modified":1386730352,"text":"译自：[语义化版本管理](http://semver.org/) 2.0.0\r\n\r\n### 摘要\r\n\r\n对于一个给定的版本号 MAJOR.MINOR.PATCH (主、次、补丁)，其变化的规律是：\r\n\r\n1. MAJOR version (主版本) 会在 API 发生不可向下兼容的改变时增大。\r\n2. MINOR version (次版本) 会在有向下兼容的新功能加入时增大。\r\n3. PATCH version (补丁版本) 会在bug以向下兼容的方式被修复时增大。\r\n\r\n我们还可以根据预发布、构建元数据 (build metadata) 的实际需求，在 MAJOR.MINOR.PATCH 格式之上扩展出额外的标记。\r\n\r\n### 介绍\r\n\r\n在软件管理领域，存在一个叫做“dependency hell (依赖地狱)”的坑。随着系统越变越大，你集成了越多的软件包，也越发觉得，有一天，你会陷入绝望。\r\n\r\n对于有很多依赖关系的系统来说，发布新版本的软件包会迅速变成一场噩梦。如果依赖性规定得太紧，你会陷入 version lock (版本锁，即每次软件包的升级无法产生新的版本)。如果依赖性规定得太松，你会不可避免的面对 version promiscuity (版本泛滥，假设未来版本是需要考虑兼容性的)。当 version lock 和 version promiscuity 让你的项目无法安全而又轻松的向前推进时，这就是所谓的 dependency hell。\r\n\r\n作为一种解决问题的办法，我提出了一套简单的规则和要求来表明版本号该如何确定和增加。这套规则基于但不仅限用于已经广泛存在的开源闭源软件的一般实践。为了让这个系统工作起来，你首先需要声明一个公有的 API，它可以由文档组成或在代码层面强制实现，且必须是清晰准确的。一旦你标识了你的公有 API，你就可以通过不同的版本号的增加来交流 API 的各种改变。设想一个形如 X.Y.Z 的版本，不影响 API 的 bug 修复会增大补丁版本，向下兼容的 API 增加或改变会增大次版本，而不兼容的 API 改变会增大主版本。\r\n\r\n我把这套系统称作“语义化版本管理”。在这套系统之下，版本号及其改变传递了代码背后的含义，以及每个相邻版本之间的变化。\r\n\r\n<!--more-->\r\n\r\n### 语义化版本管理规范 (SemVer)\r\n\r\n原文中的关键字 \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" (必须、禁止、要求、应该、不应该、推荐、可以、可选的) 在 RFC 2119 中有相应的解释和描述。\r\n\r\n1. 使用语义化版本管理的软件必须声明一个公有 API。该 API 可声明于代码或文档中，并且精确而全面。\r\n2. 一个普通的版本号必须遵循 X.Y.Z 的格式，其中 X、Y、Z 都是非负整数，禁止包含前置的 0。X 是主版本，Y 是次版本，Z 是补丁版本。每个元素必须以数字形式变大。比如：1.9.0 -> 1.10.0 -> 1.11.0。\r\n3. 一旦版本化的软件包被发布，那么该版本的内容就禁止被更改了。今后的任何变化都必须通过新版本的发布而产生。\r\n4. 主版本 0 (0.Y.Z) 表示初始开发阶段。在这个阶段任何事情都是可以更改的，公有 API 不应该被认为是稳定的。\r\n5. 1.0.0 版本定义了公有 API。从该版本往后，版本号的增加取决于发布的公有 API 及其变化。\r\n6. 只有当向下兼容的 bug 修复被引入时，补丁版本 Z (x.y.Z | x > 0) 必须被增大——bug 修复的定义是通过内部改变修复错误的特性。\r\n7. 如果新的向下兼容的功能被引入公有 API、如果任何公有 API 功能被废弃，次版本 Y (x.Y.z | x > 0) 必须被增大。如果显著的新功能或改进通过私有代码被引入，次版本可以被增大。次版本的被增大可以包括补丁级别的变化。当次版本被增大时，补丁版本必须被重置为 0。\r\n8. 如果任何不向下兼容的变化被引入时，主版本 X (X.y.z | X > 0) 必须被增大。主版本的被增大可以包括次级别和补丁级别的变化，当主版本被增大时，次版本和补丁版本必须被重置为 0。\r\n9. 一个预发布版本可以表示为在补丁版本之后加上一个连字符，再加上一系列由点分隔开的标识符。标识符必须仅由 ACSII 字母数字和连字符组成 [0-9A-Za-z-]。标识符禁止为空。数字标识符禁止有前置的 0。预发布版本比相应的普通版本重要性更低。一个预发布版本意味着该版本不稳定，也许没有满足相应版本既定的兼容性需求。比如：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92。\r\n10. 构建元数据可以表示为在补丁版本或预发布版本之后加上一个加号，再加上一系列由点分隔开的标识符。标识符必须仅由 ASCII 字母数字和连字符组成 [0-9A-Za-z-]。标识符禁止为空。构建元数据应该在决定版本重要性的时候被忽略。也就是说，如果两个版本只有构建元数据不一样，那么它们的重要性是一样的。比如：1.0.0-alpha+01、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85。\r\n11. 重要性用于版本之间在排序时的比较。重要性的计算必须分别通过主、次、补丁、预发布标识符进行 (构建元数据并不参与重要性比较)。重要性取决于下面从左到右依次比较时出现的第一个不一样的标识符：主、次、补丁版本，都是数字形式的比较。比如：1.0.0 > 2.0.0 > 2.1.0 > 2.1.1。当主、次、补丁都相同的时候，预发布版本比普通版本重要性低。比如：1.0.0-alpha < 1.0.0。两个主、次、补丁版本相同的预发布版本之间的重要性必须取决于比较每个用点分隔出的标识符，按如下形式从左到右比较出的第一个不同的标识符：纯数字的标识符用数字形式进行比较，带有字母或连字符的标识符用 ASCII 文本形式进行比较。数字标识符重要性低于非数字标识符。如果公有的字段都相同，则字段多的预发布版本重要性高于字段少的。比如：1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc。\r\n\r\n### 为什么要使用语义化版本管理？\r\n\r\n这并不是什么新的或革命性的东西。事实上你的做事习惯可能已经很接近它了。但问题是“接近”是不够的。如果不接受一些正式的规范，版本号对依赖性管理是没有实际意义的。基于上述想法，给定名词和定义，它就变得易于交流。一旦这些意图变得清晰，灵活 (且不过分的) 的依赖性规范就会最终产生。\r\n\r\n一个简单的例子就可以向人们展示语义化版本管理会使依赖地狱成为历史。想像一个叫做“消防车”的库，它需要一个名叫“梯子”的经过语义化版本管理的软件包。当消防车被创建时，梯子的版本是 3.1.0。因为消防车使用一些在 3.1.0 被首次引入的功能，你可以安全的制定梯子的依赖关系为大于 3.1.0 且小于 4.0.0。现在当梯子的版本 3.1.1 和 3.2.0 可用时，你可以把它们发布到你的软件包管理系统之中并很清楚它们可以和现存的依赖性软件和平共处。\r\n\r\n作为一个有责任感的开发者，你一定想要验证任何被公示的软件包的功能升级。在现实世界中这是一个混乱的地方，我们对此需要警惕但又无能为力。我们能做的就是让语义化版本管理提供给你一个清晰的路线，去发布和升级软件包，无需在依赖性软件包的不同版本中翻滚，省去你的时间和烦恼。\r\n\r\n如果这一切是你所渴望的，你需要做的就是声明你开始遵循上述规则来进行语义化的版本管理。在你的 README 中附带这个网站的链接，让其他人了解这个规则，并从中获益。\r\n\r\n### 问答时间\r\n\r\n* 我应该如何处理 0.y.z 的初始化开发阶段呢？\r\n\r\n最简单的事情就是当你开始初始化开发时，从 0.1.0 开始，然后在后续的发布过程中不断增加次版本。\r\n\r\n* 我怎么知道什么时候发布 1.0.0？\r\n\r\n如果你的软件已经用到了产品环境，它可能应该已经是 1.0.0 了。如果你有一个稳定的用户依赖的 API，它应该是 1.0.0 了。如果你担心很多向下兼容的问题，它可能应该已经是 1.0.0 了。\r\n\r\n* 这和快速开发快速迭代的理念是否有冲突？\r\n\r\n主版本 0 是快速开发时期。如果你每天都在改变 API 你应该还处在 0.y.z 或一个独立的开发分支中，这是为下一个主版本服务的。\r\n\r\n* 如果最小的向下不兼容的公有 API 改变都会导致新的主版本，那么我岂不是很快就做到 42.0.0 了？\r\n\r\n这是一个开发责任感和长远意识的问题。不兼容的改变不应该很轻松就被引入到一个被大量依赖的软件当中。这必定导致升级的代价昂贵。改变主版本才可以发布不兼容的改变也在变相的促使你思考这一变化带来的影响及其投入产出比。\r\n\r\n* 写出整个 API 的文档是一项艰巨的工作！\r\n\r\n作为一名开发者，撰写软件文档以供其他人使用是你的责任。管理软件复杂度是保障一个项目高效运作的及其重要的部分，如果没人知道如何使用你的软件，什么方法使用起来比较安全，项目将会变得很困难。长期来看，语义化版本管理以及一个被良好定义的公有 API 能够保障每个人每件事都运转顺利。\r\n\r\n* 如果我在此版本中不小心发布了一个不向下兼容的改变，我该怎么办？\r\n\r\n当你意识到你打破了语义化版本管理规范之后，立即修复这个问题并且发布一个新的次版本去修复此问题并恢复向下兼容性。甚至在这个周期里，不要接受任何其它版本的发布。如果方便合适的话，记录下出错的版本并向你的用户告知这一问题以便他们警惕这个出错的版本。\r\n\r\n* 如果我更新了我自己的依赖性但是没有改变公有 API，我该怎么做？\r\n\r\n这回被认为是兼容的，因为它并没有影响到公有 API。软件显式依赖你的软件包相同的依赖，应该有自身的以来规范，作者自然会注意任何冲突。决定这个改变是一个补丁级别还是次级别，取决于你把依赖关系的改变用在了修复一个bug上还是用在了引入新功能上。我通常会在后期期待额外的代码，很明显这是一个次级别的增大。\r\n\r\n* 如果我不经意改变了公有 API，而且它并没有遵循版本号的改变 (比如把补丁发布引入到了一个错误的主版本)，我该怎么办？\r\n\r\n做出做合理的判断。如果你有一大群用户，因为有意把行为改回到公有 API 会收到剧烈的影响，那么最好发布一个主版本，尽管实际的改动也许只是发布一个补丁。记住，语义化版本管理就是通过版本号的变化传递信息。如果这些改变对用户很重要，就用版本号去通知他们。\r\n\r\n* 我该如何处理废弃的功能？\r\n\r\n废弃已存在的功能是软件开发的一个正常部分。而且它经常需要提前行动。当你废弃部分你的公有 API 时，你应该做两件事：(1) 更新你的文档，让用户知道这一变化，(2) 创建一个此版本发布的任务。当你发布主版本完全移除功能之前，至少要有一个次版本发布，该发布包含废弃的动作，以便让用户可以平稳的过度到新的 API。\r\n\r\n* 语义化版本管理是否存在版本字符串的长度限制？\r\n\r\n没有限制，但要合理使用。比如一个 255 字符的版本字符串就算是有点长了。同样的，规范系统可以实行自己的字符串长度限制。\r\n\r\n### 关于\r\n\r\n语义化版本管理规范由 Gravatars 发明者、Github 的联合创始人 [Tom Preston-Werner](http://tom.preston-werner.com/) 撰写。\r\n如果你想留下宝贵意见，[请来 Github 开一个 issue 吧](https://github.com/mojombo/semver/issues)。\r\n\r\n### License\r\n\r\n[Creative Commons - CC BY 3.0](http://creativecommons.org/licenses/by/3.0/)"},"176":{"title":"撰写可测试的 JavaScript","slug":"writing-testable-javascript","created":1386732538,"modified":1465958748,"text":"译自：[Writing Testable JavaScript - A List Apart](http://alistapart.com/article/writing-testable-javascript)\r\n\r\n这篇文章算是 A List Apart 系列文章中，包括滑动门在内，令我印象最深刻的文章之一。最近有时间翻译了一下，分享给更多人，希望对大家有所帮助！\r\n\r\n----\r\n\r\n__我们已经面对到了这一窘境：一开始我们写的 JavaScript 只有区区几行代码，但是它的代码量一直在增长，我们不断的加参数、加条件。最后，粗 bug 了…… 我们才不得不收拾这个烂摊子。__\r\n\r\n如上所述，今天的客户端代码确实承载了更多的责任，浏览器里的整个应用都越变越复杂。我们发现两个明显的趋势：1、我们没法通过单纯的鼠标定位和点击来检验代码是否正常工作，自动化的测试才会真正让我们放心；2、我们也许应该在撰写代码的时候就考虑到，让它变得可测试。\r\n\r\n神马？我们需要改变自己的编码方式？是的。因为即使我们意识到自动化测试的好，大部分人可能只是写写集成测试(integration tests)罢了。集成测试的侧重点是让整个系统的每一部分和谐共存，但是这并没有告诉我们每个独立的*功能单元*运转起来是否都和我们预期的一样。\r\n\r\n这就是为什么我们要引入单元测试。我们已经准备好经历一段痛苦的*撰写单元测试*的过程了，但最终我们能够*撰写可测试的 JavaScript*。\r\n\r\n<!--more-->\r\n\r\n### 单元与集成：有什么不同？\r\n\r\n撰写集成测试通常是相当直接的：我们单纯的撰写代码，描述用户如何和这个应用进行交互、会得到怎样的结果就好。[Selenium](http://docs.seleniumhq.org/) 是这类浏览器自动化工具中的佼佼者。而 [Capybara](https://github.com/jnicklas/capybara) 可以便于 Ruby 和 Selenium 取得联系。在其它语言中，这类工具也举不胜举。\r\n\r\n下面就是搜索应用的一部分集成测试：\r\n\r\n    def test_search\r\n        fill_in('q', :with => 'cat')\r\n        find('.btn').click\r\n        assert( find('#results li').has_content?('cat'), 'Search results are shown' )\r\n        assert( page.has_no_selector?('#results li.no-results'), 'No results is not shown' )\r\n    end\r\n\r\n集成测试对用户的交互行为感兴趣，而单元测试往往仅专注于一小段代码：\r\n\r\n> 当我伴随特定的输入调用一个函数的时候，我是否收到了我预期中的结果？\r\n\r\n我们按照传统思路撰写的程序是很难进行单元测试的，同时也很难维护、调试和扩展。但是如果我们在撰写代码的时候就考虑到我将来要做单元测试，那么这样的思路不仅会让我们发现测试代码写起来很直接，也会让我们真正写出更优质的代码。\r\n\r\n我们通过一个简单的搜索应用的例子来做个示范：\r\n\r\n![](http://alistapart.com/d/375/app.png)\r\n\r\n当用户搜索时，该应用会向服务器发送一个 XHR (Ajax 请求) 取得相应的搜索结果。并当服务器以 JSON 格式返回数据之后，通过前端模板把结果显示在页面中。用户在搜索结果中点“赞”，这个人的名字就会出现在右侧的点“赞”列表里。\r\n\r\n一个“传统”的 JavaScript 实现大概是这个样子的：\r\n\r\n    // 模板缓存，缓存的内容均为 jqXHR 对象\r\n    var tmplCache = {};\r\n    \r\n    /**\r\n     * 载入模板\r\n     * 从 '/templates/{name}' 载入模板，存入 tmplCache\r\n     * @param  {string} name 模板名称\r\n     * @return {object}      模板请求的 jqXHR 对象\r\n     */\r\n    function loadTemplate (name) {\r\n      if (!tmplCache[name]) {\r\n        tmplCache[name] = $.get('/templates/' + name);\r\n      }\r\n      return tmplCache[name];\r\n    }\r\n    \r\n    /**\r\n     * 页面主要逻辑\r\n     * 1. 支持搜索行为并展示结果\r\n     * 2. 支持点“赞”，被赞过的人会出现在点“赞”列表里\r\n     */\r\n    $(function () {\r\n    \r\n      var resultsList = $('#results');\r\n      var liked = $('#liked');\r\n      var pending = false; // 用来标识之前的搜索是否尚未结束\r\n    \r\n      // 用户搜索行为，表单提交事件\r\n      $('#searchForm').on('submit', function (e) {\r\n        // 屏蔽默认表单事件\r\n        e.preventDefault();\r\n    \r\n        // 如果之前的搜索尚未结束，则不开始新的搜索\r\n        if (pending) { return; }\r\n    \r\n        // 得到要搜索的关键字\r\n        var form = $(this);\r\n        var query = $.trim( form.find('input[name=\"q\"]').val() );\r\n    \r\n        // 如果搜索关键字为空则不进行搜索\r\n        if (!query) { return; }\r\n    \r\n        // 开始新的搜索\r\n        pending = true;\r\n    \r\n        // 发送 XHR\r\n        $.ajax('/data/search.json', {\r\n          data : { q: query },\r\n          dataType : 'json',\r\n          success : function (data) {\r\n            // 得到 people-detailed 模板\r\n            loadTemplate('people-detailed.tmpl').then(function (t) {\r\n              var tmpl = _.template(t);\r\n\r\n              // 通过模板渲染搜索结果\r\n              resultsList.html( tmpl({ people : data.results }) );\r\n\r\n              // 结束本次搜索\r\n              pending = false;\r\n            });\r\n          }\r\n        });\r\n    \r\n        // 在得到服务器响应之前，清空搜索结果，并出现等待提示\r\n        $('<li>', {\r\n          'class' : 'pending',\r\n          html : 'Searching &hellip;'\r\n        }).appendTo( resultsList.empty() );\r\n      });\r\n    \r\n      // 绑定点“赞”的行为，鼠标点击事件\r\n      resultsList.on('click', '.like', function (e) {\r\n        // 屏蔽默认点击事件\r\n        e.preventDefault();\r\n    \r\n        // 找到当前人的名字\r\n        var name = $(this).closest('li').find('h2').text();\r\n    \r\n        // 清除点“赞”列表的占位元素\r\n        liked.find('.no-results').remove();\r\n    \r\n        // 在点“赞”列表加入新的项目\r\n        $('<li>', { text: name }).appendTo(liked);\r\n      });\r\n    \r\n    });\r\n\r\n我的朋友 Adam Sontag 称之为*“自己给自己挖坑”*的代码：展现、数据、用户交互、应用状态全部分散在了每一行代码里。这种代码是很容易进行集成测试的，但几乎不可能针对*功能单元*进行单独的测试。\r\n\r\n单元测试为什么这么难？有四大罪魁祸首：\r\n\r\n* 没有清晰的结构。几乎所有的工作都是在 `$(document).ready()` 回调里进行的，而这一切在一个匿名函数里，它在测试中无法暴露出任何接口。\r\n* 函数太复杂。如果一个函数超过了 10 行，比如提交表单的那个函数，估计大家都觉得它太忙了，一口气做了很多事。\r\n* 隐藏状态还是共享状态。比如，因为 `pending` 在一个闭包里，所以我们没有办法测试在每个步骤中这个状态是否正确。\r\n* 强耦合。比如这里 `$.ajax` 成功的回调函数不应该依赖 DOM 操作。\r\n\r\n### 组织我们的代码\r\n\r\n首当其冲的是把我们代码的逻辑缕一缕，根据职责的不同把整段代码分为几个方面：\r\n\r\n* 展现和交互\r\n* 数据管理和保存\r\n* 应用的状态\r\n* 把上述代码建立并串连起来\r\n\r\n在之前的“传统”实现里，这四类代码是混在一起的，前一行我们还在处理界面展现，后两行就在和服务器通信了。\r\n\r\n![](http://alistapart.com/d/375/code-lines.png)\r\n\r\n我们绝对可以写出集成测试的代码，但我们应该很难写出单元测试了。在功能测试里，我们可以做出诸如“当用户搜索东西的时候，他会看到相应的搜索结果”的断言，但是无法再具体下去了。如果里面出了什么问题，我们还是得追踪进去，找到确切的出错位置。这样的话功能测试其实也没帮上什么忙。\r\n\r\n如果我们反思自己的代码，那不妨从单元测试写起，通过单元测试这个角度，更好的观察，是哪里出了问题。这进而会帮助我们改进代码，让代码变得更易于重用、易于维护、易于扩展。\r\n\r\n我们的新版代码遵循下面几个原则：\r\n\r\n* 根据上述四类职责，列出每个互不相干的行为，并分别用一个对象来表示。对象之前互不依赖，以避免不同的代码混在一起。\r\n* 用可配置的内容代替写死的内容，以避免我们为了测试而复刻整个 HTML 环境。\r\n* 保持对象方法的简单明了。这会把测试工作变得简单易懂。\r\n* 通过构造函数创建对象实例。这让我们可以根据测试的需要复刻每一段代码的内容。\r\n\r\n作为起步，我们有必要搞清楚，该如何把应用分解成不同的部分。我们有三块展现和交互的内容：搜索框、搜索结果和点“赞”列表。\r\n\r\n![](http://alistapart.com/d/375/app-views.png)\r\n\r\n我们还有一块内容是从服务器获取数据的、一块内容是把所有的内容粘合在一起的。\r\n\r\n我们从整个应用最简单的一部分开始吧：点“赞”列表。在原版应用中，这部分代码的职责就是更新点“赞”列表：\r\n\r\n    var liked = $('#liked');\r\n    var resultsList = $('#results');\r\n    \r\n    // ...\r\n    \r\n    resultsList.on('click', '.like', function (e) {\r\n      e.preventDefault();\r\n      var name = $(this).closest('li').find('h2').text();\r\n      liked.find( '.no-results' ).remove();\r\n      $('<li>', { text: name }).appendTo(liked);\r\n    });\r\n\r\n搜索结果这部分是完全和点“赞”列表搅在一起的，并且需要很多 DOM 处理。更好的易于测试的写法是创建一个点“赞”列表的对象，它的职责就是封装点“赞”列表的 DOM 操作。\r\n\r\n    var Likes = function (el) {\r\n      this.el = $(el);\r\n      return this;\r\n    };\r\n    \r\n    Likes.prototype.add = function (name) {\r\n      this.el.find('.no-results').remove();\r\n      $('<li>', { text: name }).appendTo(this.el);\r\n    };\r\n\r\n这段代码提供了创建一个点“赞”列表对象的构造函数。它有 `.add()` 方法，可以在产生新的赞的时候使用。这样我们就可以写很多测试代码来保障它的正常工作了：\r\n\r\n    var ul;\r\n    \r\n    // 设置测试的初始状态：生成一个搜索结果列表\r\n    setup(function(){\r\n      ul = $('<ul><li class=\"no-results\"></li></ul>');\r\n    });\r\n    \r\n    test('测试构造函数', function () {\r\n      var l = new Likes(ul);\r\n      // 断言对象存在\r\n      assert(l);\r\n    });\r\n    \r\n    test('点一个“赞”', function () {\r\n      var l = new Likes(ul);\r\n      l.add('Brendan Eich');\r\n    \r\n      // 断言列表长度为1\r\n      assert.equal(ul.find('li').length, 1);\r\n      // 断言列表第一个元素的 HTML 代码是 'Brendan Eich'\r\n      assert.equal(ul.find('li').first().html(), 'Brendan Eich');\r\n      // 断言占位元素已经不存在了\r\n      assert.equal(ul.find('li.no-results').length, 0);\r\n    });\r\n\r\n怎么样？并不难吧 :-) 我们这里用到了名为 [Mocha](http://visionmedia.github.io/mocha/) 的*测试框架*，以及名为 [Chai](http://chaijs.com/) 的*断言库*。Mocha 提供了 `test` 和 `setup` 函数；而 Chai 提供了 `assert`。测试框架和断言库的选择还有很多，我们出于介绍的目的给大家展示这两款。你可以找到属于适合自己的项目——除了 Mocha 之外，[QUnit](http://qunitjs.com/) 也比较流行。另外 [Intern](http://theintern.io/) 也是一个测试框架，它运用了大量的 promise 方式。\r\n\r\n我们的测试代码是从点“赞”列表这一容器开始的。然后它运行了两个测试：一个是确定点“赞”列表是存在的；另一个是确保 `.add()` 方法达到了我们预期的效果。有这些测试做后盾，我们就可以放心重构点“赞”列表这部分的代码了，即使代码被破坏了，我们也有信心把它修复好。\r\n\r\n我们新应用的代码现在看起来是这样的：\r\n\r\n    var liked = new Likes('#liked'); // 新的点“赞”列表对象\r\n    var resultsList = $('#results');\r\n    \r\n    // ...\r\n    \r\n    resultsList.on('click', '.like', function (e) {\r\n      e.preventDefault();\r\n      var name = $(this).closest('li').find('h2').text();\r\n      liked.add(name); // 新的点“赞”操作的封装\r\n    });\r\n\r\n搜索结果这部分比点“赞”列表更复杂一些，不过我们也该拿它开刀了。和我们为点“赞”列表创建一个 `.add()` 方法一样，我们要创建一个与搜索结果有交互的方法。我们需要一个点“赞”的入口，向整个应用“广播”自己发生了什么变化——比如有人点了个“赞”。\r\n\r\n    // 为每一条搜索结果的点“赞”按钮绑定点击事件\r\n    var SearchResults = function (el) {\r\n      this.el = $(el);\r\n      this.el.on( 'click', '.btn.like', _.bind(this._handleClick, this) );\r\n    };\r\n    \r\n    // 展示搜索结果，获取模板，然后渲染\r\n    SearchResults.prototype.setResults = function (results) {\r\n      var templateRequest = $.get('people-detailed.tmpl');\r\n      templateRequest.then( _.bind(this._populate, this, results) );\r\n    };\r\n    \r\n    // 处理点“赞”\r\n    SearchResults.prototype._handleClick = function (evt) {\r\n      var name = $(evt.target).closest('li.result').attr('data-name');\r\n      $(document).trigger('like', [ name ]);\r\n    };\r\n    \r\n    // 对模板渲染数据的封装\r\n    SearchResults.prototype._populate = function (results, tmpl) {\r\n      var html = _.template(tmpl, { people: results });\r\n      this.el.html(html);\r\n    };\r\n\r\n现在我们旧版应用中管理搜索结果和点“赞”列表之间交互的代码如下：\r\n\r\n    var liked = new Likes('#liked');\r\n    var resultsList = new SearchResults('#results');\r\n    \r\n    // ...\r\n    \r\n    $(document).on('like', function (evt, name) {\r\n      liked.add(name);\r\n    })\r\n\r\n这就更简单更清晰了，因为我们通过 `document` 在各个独立的组件之间进行消息传递，而组件之间是互不依赖的。(值得注意的是，在真正的应用当中，我们会使用一些诸如 [Backbone](http://backbonejs.org/) 或 [RSVP](https://github.com/tildeio/rsvp.js) 库来管理事件。我们出于让例子尽量简单的考虑，使用了 `document` 来触发事件) 我们同时隐藏了很多脏活累活：比如在搜索结果对象里寻找被点“赞”的人，要比放在整个应用的代码里更好。更重要的是，我们现在可以写出保障搜索结果对象正常工作的测试代码了：\r\n\r\n    var ul;\r\n    var data = [ /* 填入假数据 */ ];\r\n    \r\n    // 确保点“赞”列表存在\r\n    setup(function () {\r\n      ul = $('<ul><li class=\"no-results\"></li></ul>');\r\n    });\r\n    \r\n    test('测试构造函数', function () {\r\n      var sr = new SearchResults(ul);\r\n      // 断言对象存在\r\n      assert(sr);\r\n    });\r\n    \r\n    test('测试收到的搜索结果', function () {\r\n      var sr = new SearchResults(ul);\r\n      sr.setResults(data);\r\n    \r\n      // 断言搜索结果占位元素已经不存在\r\n      assert.equal(ul.find('.no-results').length, 0);\r\n      // 断言搜索结果的子元素个数和搜索结果的个数相同\r\n      assert.equal(ul.find('li.result').length, data.length);\r\n      // 断言搜索结果的第一个子元素的 'data-name' 的值和第一个搜索结果相同\r\n      assert.equal(\r\n        ul.find('li.result').first().attr('data-name'),\r\n        data[0].name\r\n      );\r\n    });\r\n    \r\n    test('测试点“赞”按钮', function() {\r\n      var sr = new SearchResults(ul);\r\n      var flag;\r\n      var spy = function () {\r\n        flag = [].slice.call(arguments);\r\n      };\r\n    \r\n      sr.setResults(data);\r\n      $(document).on('like', spy);\r\n    \r\n      ul.find('li').first().find('.like.btn').click();\r\n    \r\n      // 断言 `document` 收到了点“赞”的消息\r\n      assert(flag, '事件被收到了');\r\n      // 断言 `document` 收到的点“赞”消息，其中的名字是第一个搜索结果\r\n      assert.equal(flag[1], data[0].name, '事件里的数据被收到了' );\r\n    });\r\n\r\n和服务器直接的交互是另外一个有趣的话题。原版的代码包括一个 `$.ajax()` 的请求，以及一个直接操作 DOM 的回调函数：\r\n\r\n    $.ajax('/data/search.json', {\r\n      data : { q: query },\r\n      dataType : 'json',\r\n      success : function( data ) {\r\n        loadTemplate('people-detailed.tmpl').then(function(t) {\r\n          var tmpl = _.template( t );\r\n          resultsList.html( tmpl({ people : data.results }) );\r\n          pending = false;\r\n        });\r\n      }\r\n    });\r\n\r\n同样，我们很难为这样的代码撰写测试。因为很多不同的工作同时发生在这一小段代码中。我们可以重新组织一下数据处理的部分：\r\n\r\n    var SearchData = function () { };\r\n    \r\n    SearchData.prototype.fetch = function (query) {\r\n      var dfd;\r\n    \r\n      // 如果搜索关键字为空，则不做任何事，立刻 `promise()`\r\n      if (!query) {\r\n        dfd = $.Deferred();\r\n        dfd.resolve([]);\r\n        return dfd.promise();\r\n      }\r\n    \r\n      // 否则，向服务器请求搜索结果并把在得到结果之后对其数据进行包装\r\n      return $.ajax( '/data/search.json', {\r\n        data : { q: query },\r\n        dataType : 'json'\r\n      }).pipe(function( resp ) {\r\n        return resp.results;\r\n      });\r\n    };\r\n\r\n现在我们改变了获得搜索结果这部分的代码：\r\n\r\n    var resultList = new SearchResults('#results');\r\n    var searchData = new SearchData();\r\n    \r\n    // ...\r\n    \r\n    searchData.fetch(query).then(resultList.setResults);\r\n\r\n我们再一次简化了代码，并通过 `SearchData` 对象抛弃了之前应用程序主函数里杂乱的代码。同时我们已经让搜索接口变得可测试了，尽管现在和服务器通信这里还有事情要做。\r\n\r\n首先我们不是真的要跟服务器通信——不然这又变成集成测试了：诸如我们是有责任感的开发者，我们已经确保服务器一定不会犯错等等，是这样吗？为了替代这些东西，我们应该“mock”(伪造) 与服务器之间的通信。[Sinon](http://sinonjs.org/) 这个库就可以做这件事。第二个障碍是我们的测试应该覆盖非理想环境，比如关键字为空。\r\n\r\n    test('测试构造函数', function () {\r\n      var sd = new SearchData();\r\n      assert(sd);\r\n    });\r\n    \r\n    suite('取数据', function () {\r\n      var xhr, requests;\r\n    \r\n      setup(function () {\r\n        requests = [];\r\n        xhr = sinon.useFakeXMLHttpRequest();\r\n        xhr.onCreate = function (req) {\r\n          requests.push(req);\r\n        };\r\n      });\r\n    \r\n      teardown(function () {\r\n        xhr.restore();\r\n      });\r\n    \r\n      test('通过正确的 URL 获取数据', function () {\r\n        var sd = new SearchData();\r\n        sd.fetch('cat');\r\n    \r\n        assert.equal(requests[0].url, '/data/search.json?q=cat');\r\n      });\r\n    \r\n      test('返回一个 promise', function () {\r\n        var sd = new SearchData();\r\n        var req = sd.fetch('cat');\r\n    \r\n        assert.isFunction(req.then);\r\n      });\r\n    \r\n      test('如果关键字为空则不查询', function () {\r\n        var sd = new SearchData();\r\n        var req = sd.fetch();\r\n        assert.equal(requests.length, 0);\r\n      });\r\n    \r\n      test('如果关键字为空也会有 promise', function () {\r\n        var sd = new SearchData();\r\n        var req = sd.fetch();\r\n    \r\n        assert.isFunction( req.then );\r\n      });\r\n    \r\n      test('关键字为空的 promise 会返回一个空数组', function () {\r\n        var sd = new SearchData();\r\n        var req = sd.fetch();\r\n        var spy = sinon.spy();\r\n    \r\n        req.then(spy);\r\n    \r\n        assert.deepEqual(spy.args[0][0], []);\r\n      });\r\n    \r\n      test('返回与搜索结果相对应的对象', function () {\r\n        var sd = new SearchData();\r\n        var req = sd.fetch('cat');\r\n        var spy = sinon.spy();\r\n\r\n        requests[0].respond(\r\n          200, { 'Content-type': 'text/json' },\r\n          JSON.stringify({ results: [ 1, 2, 3 ] })\r\n        );\r\n    \r\n        req.then(spy);\r\n    \r\n        assert.deepEqual(spy.args[0][0], [ 1, 2, 3 ]);\r\n      });\r\n    });\r\n\r\n出于篇幅的考虑，这里对搜索框的重构及其相关的单元测试就不一一介绍了。完整的代码可以[移步至此](https://github.com/rmurphey/testable-javascript)查阅。\r\n\r\n当我们按照可测试的 JavaScript 的思路重构代码之后，我们最后用下面这段代码开启程序：\r\n\r\n    $(function() {\r\n      var pending = false;\r\n    \r\n      var searchForm = new SearchForm('#searchForm');\r\n      var searchResults = new SearchResults('#results');\r\n      var likes = new Likes('#liked');\r\n      var searchData = new SearchData();\r\n    \r\n      $(document).on('search', function (event, query) {\r\n        if (pending) { return; }\r\n    \r\n        pending = true;\r\n    \r\n        searchData.fetch(query).then(function (results) {\r\n          searchResults.setResults(results);\r\n          pending = false;\r\n        });\r\n    \r\n        searchResults.pending();\r\n      });\r\n    \r\n      $(document).on('like', function (evt, name) {\r\n        likes.add(name);\r\n      });\r\n    });\r\n\r\n比干净整洁的代码更重要的，是我们的代码拥有了更健壮的测试基础作为后盾。这也意味着我们可以放心的重构任意部分的代码而不必担心程序遭到破坏。我们还可以继续为新功能撰写新的测试代码，并确保新的程序可以通过所有的测试。\r\n\r\n### 测试会在宏观上让你变轻松\r\n\r\n看完这些的长篇大论你一定会说：“纳尼？我多写了这么多代码，结果还是做了这么一点事情？”\r\n\r\n关键在于，你做的东西早晚要放到网上的。同样是花时间解决问题，你会选择在浏览器里点来点去？还是自动化测试？还是直接在线上让你的用户做你的小白鼠？无论你写了多少测试，你写好代码，别人一用，多少会发现点 bug。\r\n\r\n至于测试，它可能会花掉你一些额外的时间，但是它到最后真的是为你省下了时间。写测试代码测出一个问题，总比你发布到线上之后才发现有问题要好。如果有一个系统能让你意识到它真的能避免一个 bug 的流出，你一定会心存感激。\r\n\r\n### 额外的资源\r\n\r\n这篇文章只能算是 JavaScript 测试的一点皮毛，但是如果你对此抱有兴趣，那么可以继续移步至：\r\n\r\n* [幻灯演示](http://lanyrd.com/2012/full-frontal/sztqh/) 2012 Full Frontal conference in Brighton, UK\r\n* [Grunt](http://gruntjs.com/) 一个可以进行自动化测试等诸多事情的工具\r\n* [测试驱动的 JavaScript 开发](http://www.amazon.com/dp/0321683919/) 及其 [中文版](http://www.amazon.cn/dp/B0077KA3J4/)"},"177":{"title":"Git 分支的最佳实践","slug":"a-successful-git-branching-model","created":1388591963,"modified":1413366007,"text":"译自：[A successful Git branching model &raquo; nvie.com](http://nvie.com/posts/a-successful-git-branching-model/)\r\n\r\n----\r\n\r\n本文将展示我一年前在自己的项目中成功运用的开发模型。我一直打算把这些东西写出来，但总是没有抽出时间，现在终于写好了。这里介绍的不是任何项目的细节，而是有关分支的策略以及对发布的管理。\r\n\r\n![](http://nvie.com/img/git-model@2x.png)\r\n\r\n在我的演示中，所有的操作都是通过 git 完成的。\r\n\r\n<!--more-->\r\n\r\n### 为什么选择 git ？\r\n\r\n为了了断 git 和中心源代码控制系统的比较和争论，请移步这里看看 [链接1](http://whygitisbetterthanx.com/) [链接2](https://git.wiki.kernel.org/index.php/GitSvnComparsion)。作为一个开发者，我喜欢 git 超过其它任何现有的工具。Git 真正改变了开发者对于合并和分支的认识。在传统的 CVS/SVN 里，合并/分支总是有点令人害怕的(“注意合并冲突，它们会搞死你的”)。\r\n\r\n但是 git 中的这些操作是如此的简单有效，它们真正作为你每天工作流程的一部分。比如，在 CVS/SVN 的书籍里，分支和合并总是最后一个章节的讨论重点(对于高级用户)，而在每一本 git 的书里 [链接1](http://book.git-scm.com/) [链接2](http://pragprog.com/titles/tsgit/pragmatic-version-control-using-git) [链接3](http://github.com/progit/progit)，这些内容已经被包含在第三章(基础)里了。\r\n\r\n因为它的简单直接和重复性，分支和合并不再令人害怕。版本控制工具比其它任何东西都支持分支/合并。\r\n\r\n有关工具就介绍到这里，我们现在进入开发模型这个正题。我要展现的模型本质上无外乎是一个流程的集合，每个团队成员都有必要遵守这些流程，来达到管理软件开发流程的目的。\r\n\r\n\r\n### 分散但也集中\r\n\r\n我们的分支模型中使用良好的代码库的设置方式，是围绕一个真实的中心代码库的。注意，这里的代码库仅仅被看做是一个中心代码库(因为 git 是 DVCS，即分散版本控制系统，从技术层面看，是没有所谓的中心代码库的)。我们习惯于把这个中心代码库命名为 `origin`，这同时也是所有 git 用户的习惯。\r\n\r\n![](http://nvie.com/img/centr-decentr@2x.png)\r\n\r\n每一位开发者都向 `origin` 这个中心结点 pull 和 push。但是除此之外，每一位开发者也可以向其它结点 pull 改变形成子团队。比如，对于两个以上开发者同时开发一项大的新特性来说，为了不必过早向 `origin` 推送开发进度，这就非常有用。在上面的这个例子中，Alice 和 Bob、Alice 和 David、Clair 和 David 都是这样的子团队。\r\n\r\n从技术角度，这无非意味着 Alice 定义一个名为 `Bob` 的 git remote，指向 Bob 的代码库，反之亦然。\r\n\r\n\r\n### 主分支\r\n\r\n![](http://nvie.com/img/main-branches@2x.png)\r\n\r\n该开发模型的核心基本和现有的模型是一样的。中心代码库永远维持着两个主要的分支：\r\n\r\n* `master`\r\n* `develop`\r\n\r\n在 `origin` 上的 `master` 分支和每个 git 用户的保持一致。而和 `master` 分支并行的另一个分支叫做 `develop`。\r\n\r\n我们认为 `origin/master` 是其 `HEAD` 源代码总是代表了*生产环境准备就绪*的状态的主分支。\r\n\r\n我们认为 `origin/develop` 是其 `HEAD` 源代码总是代表了最后一次交付的可以赶上下一次发布的状态的主分支。有人也把它叫做“集成分支”。该源代码还被作为了 nightly build 自动化任务的来源。\r\n\r\n每当 `develop` 分支到达一个稳定的阶段，可以对外发布时，所有的改变都会被合并到 `master` 分支，并打一个发布版本的 tag。具体操作方法我们稍后讨论。\r\n\r\n因此，每次改动被合并到 `master` 的时候，这就是一个*真正的*新的发布产品。我们建议对此进行严格的控制，因此理论上我们可以为每次 `master` 分支的提交都挂一个钩子脚本，向生产环境自动化构建并发布我们的软件。\r\n\r\n\r\n### 支持型分支\r\n\r\n我们的开发模型里，紧接着 `master` 和 `develop` 主分支的，是多种多样的支持型分支。它们的目的是帮助团队成员并行处理每次追踪特性、准备发布、快速修复线上问题等开发任务。和之前的主分支不同，这些分支的生命周期都是有限的，它们最终都会被删除掉。\r\n\r\n我们可能会用到的不同类型的分支有：\r\n\r\n* feature 分支\r\n* release 分支\r\n* hotfix 分支\r\n\r\n每一种分支都有一个特别的目的，并且有严格的规则，诸如哪些分支是它们的起始分支、哪些分支必须是它们合并的目标等。我们快速把它们过一遍。\r\n\r\n这些“特殊”的分支在技术上是没有任何特殊的。分支的类型取决于我们如何*运用*它们。它们完完全全都是普通而又平凡的 git 分支。\r\n\r\n\r\n#### feature 分支\r\n\r\n![](http://nvie.com/img/fb@2x.png)\r\n\r\n* 可能派发自：`develop`\r\n* 必须合并回：`develop`\r\n* 分支命名规范：除了 `master`、`develop`、`release-*` 或 `hotfix-*` 的任何名字\r\n\r\nFeature 分支(有时也被称作 topic 分支)用来开发包括即将发布或远期发布的新的特性。当我们开始开发一个特性的时候，发布合并的目标可能还不太确定。Feature 分支的生命周期会和新特性的开发周期保持同步，但是最终会合并回 `develop` (恩，下次发布的时候把这个新特性带上)或被抛弃(真是一次杯具的尝试啊)。\r\n\r\nFeature 分支通常仅存在于开发者的代码库中，并不出现在 `origin` 里。\r\n\r\n\r\n##### 创建一个 feature 分支\r\n\r\n当开始一个新特性的时候，从 `develop` 分支派发出一个分支\r\n\r\n    $ git checkout -b myfeature develop\r\n    Switched to a new branch \"myfeature\"\r\n\r\n\r\n##### 把完成的特性合并回 develop\r\n\r\n完成的特性可以合并回 `develop` 分支并赶上下一次发布：\r\n\r\n    $ git checkout develop\r\n    Switched to a new branch \"develop\"\r\n    $ git merge --no-ff myfeature\r\n    Updating ea1b82a..05e9557\r\n    (Summary of changes)\r\n    $ git branch -d myfeature\r\n    Deleted branch myfeature (was 05e9557)\r\n    $ git push origin develop\r\n\r\n`-no-ff` 标记使得合并操作总是产生一次新的提交，哪怕合并操作可以快速完成。这个标记避免将 feature 分支和团队协作的所有提交的历史信息混在主分支的其它提交之后。比较一下：\r\n\r\n![](http://nvie.com/img/merge-without-ff@2x.png)\r\n\r\n在右边的例子里，我们不可能从 git 的历史记录中看出来哪些提交实现了这一特性——你可能不得不查看每一笔提交日志。恢复一个完整的特性(比如通过一组提交)在右边变成了一个头疼事情，而如果使用了 `--no-ff` 之后，就变得简单了。\r\n\r\n是的，这会创造一些没有必要的(空的)提交记录，但是得到的是大量的好处。\r\n\r\n不幸的是，我还没有找到一个在 `git merge` 时默认就把 `--no-ff` 标记打上的办法，但这很重要。\r\n\r\n\r\n#### release 分支\r\n\r\n* 可能派发自：`develop`\r\n* 必须合并回：`develop` 和 `master`\r\n* 分支命名规范：`release-*`\r\n\r\nRelease 分支用来支持新的生产环境发布的准备工作。允许在最后阶段产生提交点(dotting i's)和交汇点(crossing t's)。而且允许小幅度的问题修复以及准备发布时的meta数据(比如版本号、发布日期等)。在 `release` 分支做了上述这些工作之后，`develop` 分支会被“翻篇儿”，开始接收下一次发布的新特性。\r\n\r\n我们选择(几近)完成所有预期的开发的时候，作为从 `develop` 派发出 `release` 分支的时机。最起码所有准备构建发布的功能都已经及时合并到了 `develop` 分支。而往后才会发布的功能则不应该合并到 `develop` 分支——他们必须等到 `release` 分支派发出去之后再做合并。\r\n\r\n在一个 `release` 分支的开始，我们就赋予其一个明确的版本号。直到该分支创建之前，`develop` 分支上的描述都是“下一次”release 的改动，但这个“下一次”release 其实也没说清楚是 0.3 release 还是 1.0 release。而在一个 release 分支的开始时这一点就会确定。这将成为有关项目版本号晋升的一个守则。\r\n\r\n\r\n##### 创建一个 release 分支\r\n\r\nRelease 分支派发自 `develop` 分支。比如，我们当前的生产环境发布的版本是 1.1.5，马上有一个 release 要发布了。`develop` 分支已经为“下一次”release 做好了准备，并且我们已经决定把新的版本号定为 1.2 (而不是 1.1.6 或 2.0)。所以我们派发一个 release 分支并以新的版本号为其命名：\r\n\r\n    $ git checkout -b release-1.2 develop\r\n    Switched to a new branch \"release-1.2\"\r\n    $ ./bump-version.sh 1.2\r\n    Files modified successfully, version bumped to 1.2.\r\n    $ git commit -a -m \"Bumped version number to 1.2\"\r\n    [release-1.2 74d9424] Bumped version number to 1.2\r\n    1 files changed, 1 insertions(+), 1 deletions(-)\r\n\r\n创建好并切换到新的分支之后，我们完成对版本号的晋升。这里的 `bump-version.sh` 是一个虚构的用来改变代码库中某些文件以反映新版本的 shell 脚本。(当然你也可以手动完成这些改变——重点是*有些*文件发生了改变)然后，晋升了的版本号会被提交。\r\n\r\n这个新的分支会存在一段时间，直到它确实发布出去了为止。期间可能会有 bug 修复(这比在 `develop` 做更合理)。但我们严格禁止在此开发庞大的新特性，它们应该合并到 `develop` 分支，并放入下次发布。\r\n\r\n\r\n##### 完成一个 release 分支\r\n\r\n当 release 分支真正发布成功之后，还有些事情需要收尾。首先，release 分支会被合并到 `master` (别忘了，`master` 上的每一次提交都代表一个真正的新的发布)；然后，为 `master` 上的这次提交打一个 tag，以便作为版本历史的重要参考；最后，还要把 release 分支产生的改动合并回 `develop`，以便后续的发布同样包含对这些 bug 的修复。\r\n\r\n前两部在 git 下是这样操作的：\r\n\r\n    $ git checkout master\r\n    Switched to branch 'master'\r\n    $ git merge --no-ff release-1.2\r\n    Merge made by recursive\r\n    (Summary of changes)\r\n    $ git tag -a 1.2\r\n\r\n现在发布工作已经完成了，同时 tag 也打好了，用在未来做参考。\r\n\r\n**补充**：你也可以通过 `-s` 或 `-u <key>` 标记打 tag。\r\n\r\n为了保留 release 分支里的改动记录，我们需要把这些改动合并回 `develop`。git 操作如下：\r\n\r\n    $ git checkout develop\r\n    Switched to branch 'develop'\r\n    $ git merge --no-ff release-1.2\r\n    Merge made by recursive.\r\n    (Summary of changes)\r\n\r\n这一步有可能导致冲突的发生(只是有理论上的可能性，因为我们已经改变了版本号)，一旦发现，解决冲突然后提交就好了。\r\n\r\n现在我们真正完成了一个 release 分支，该把它删掉了，因为它的使命已经完成了：\r\n\r\n    $ git branch -d release-1.2\r\n    Deleted branch release-1.2 (was ff452fe).\r\n\r\n\r\n#### hotfix 分支\r\n\r\n![](http://nvie.com/img/hotfix-branches@2x.png)\r\n\r\n* 可能派发自：`master`\r\n* 必须合并回：`develop` 和 `master`\r\n* 分支命名规范：`hotfix-*`\r\n\r\nHotfix 分支和 release 分支非常类似，因为他们都意味着会产生一个新的生产环境的发布，尽管 hotfix 分支不是先前就计划好的。他们在实时的生产环境版本出现意外需要快速响应时，从 `master` 分支相应的 tag 被派发。\r\n\r\n我们这样做的根本原因，是为了让团队其中一个人来快速修复生产环境的问题，其他成员可以按工作计划继续工作下去而不受太大影响。\r\n\r\n\r\n##### 创建一个 hotfix 分支\r\n\r\nHotfix 分支创建自 `master` 分支。例如，假设 1.2 版本是目前的生产环境且出现了一个严重的 bug，但是目前的 `develop` 并不足够稳定。那么我们可以派发出一个 hotfix 分支来开始我们的修复工作：\r\n\r\n    $ git checkout -b hotfix-1.2.1 master\r\n    Switched to a new branch \"hotfix-1.2.1\"\r\n    $ ./bump-version.sh 1.2.1\r\n    Files modified successfully, version bumped to 1.2.1.\r\n    $ git commit -a -m \"Bumped version number to 1.2.1\"\r\n    [hotfix-1.2.1 41e61bb] Bumped version number to 1.2.1\r\n    1 files changed, 1 insertions(+), 1 deletions(-)\r\n\r\n别忘了在派发出分支之后晋升版本号！\r\n\r\n然后，修复 bug，提交改动。通过一个或多个提交都可以。\r\n\r\n    $ git commit -m \"Fixed severe production problem\"\r\n    [hotfix-1.2.1 abbe5d6] Fixed severe production problem\r\n    5 files changed, 32 insertions(+), 17 deletions(-)\r\n\r\n\r\n##### 完成一个 hotfix 分支\r\n\r\n当我们完成之后，对 bug 的修复需要合并回 `master`，同时也需要合并回 `develop`，以保证接下来的发布也都已经解决了这个 bug。这和 release 分支的完成方式是完全一样的。\r\n\r\n首先，更新 `master` 并为本次发布打一个 tag：\r\n\r\n    $ git checkout master\r\n    Switched to branch 'master'\r\n    $ git merge --no-ff hotfix-1.2.1\r\n    Merge made by recursive\r\n    (Summary of changes)\r\n    $ git tag -a 1.2.1\r\n\r\n**补充**：你也可以通过 `-s` 或 `-u <key>` 标记打 tag。\r\n\r\n然后，把已修复的 bug 合并到 `develop`：\r\n\r\n    $ git checkout develop\r\n    Switched to branch 'develop'\r\n    $ git merge --no-ff hotfix-1.2.1\r\n    Merge made by recursive\r\n    (Summary of changes)\r\n\r\n这个规矩的一个额外之处是：*如果此时已经存在了一个 release 分支，那么 hotfix 的改变需要合并到这个 release 分支，而不是 `develop` 分支*。因为把对 bug 的修复合并回 release 分支之后，release 分支最终还是会合并回 `develop` 分支的。(如果在 `develop` 分支中立刻需要对这个 bug 的修复，且等不及 release 分支合并回来，则你还是可以直接合并回 `develop` 分支的，这是绝对没问题的)\r\n\r\n最后，删掉这个临时的分支：\r\n\r\n    $ git branch -d hotfix-1.2.1\r\n    Deleted branch hotfix-1.2.1 (was abbe5d6).\r\n\r\n\r\n\r\n### 摘要\r\n\r\n其实这个分支模型里没有什么新奇的东西。文章开头的那张大图对我们的项目来说非常有用。它非常易于团队成员理解这个优雅有效的模型，并在团队内部达成共识。\r\n\r\n这里还有一份那张大图的 [高清PDF版本](http://nvie.com/files/Git-branching-model.pdf)，你可以把它当做手册放在手边快速浏览。\r\n\r\n**补充**：还有，如果你们需要的话，这里还有一份 [Keynote 版本](http://github.com/downloads/nvie/gitflow/Git-branching-model-src.key.zip)"},"179":{"title":"CSS命名神马的真心难","slug":"naming-css-stuff-is-really-hard","created":1411463921,"modified":1414308224,"text":"译自：[Naming CSS Stuff Is Really Hard](http://seesparkbox.com/foundry/naming_css_stuff_is_really_hard)\r\n\r\n找到的这篇文章算是对我之前写的 [《标签？ID？还是CLASS？》](/blog/html-or-id-or-class/) 的再深入。我当时写那篇文章的时候，就有朋友提出了“非语义化”的 class 命名的问题，我当时确实觉得很纠结，简单的想法是“框架性质的表象 class 我没异议……框架的实质是通过降低灵活性达成更广泛的共识，我们个人不要再创造这样的样式就好了”，但没有想到特别好的“套路”，更多的是在实际情况中再分辨。看过这篇文章，我似乎找到了更好的答案。同时顺着文中提到的 [Nicolas 那篇文章](http://nicolasgallagher.com/about-html-semantics-front-end-architecture/)看下去，也对 OOCSS、BEM 之类的提法有了更多的认同感。特译给大家参考。<!--more-->\r\n\r\n----\r\n\r\n这并不是一篇有关 CSS 架构的文章，也并不是一篇有关命名规范的文章，而关乎我们如何定位元素，关乎命名本身，关乎我们如何把元素及其相关的一段样式连接起来。\r\n\r\n10 个开发者里有 9 个都同意：在撰写 CSS 中命名什么的部分是最难的了。因为我们无法预知未来。一个 class 名可以在今天完美的应景，但是明天设计发生改变了，可能就不适用了。所以我们需要提炼应景的标记和样式。嗷~\r\n\r\n如何面对这一状况呢？那便是让命名尽量显得不太会改的样子。\r\n\r\n我们通常会根据三类情况给定一个 class 名：\r\n\r\n* 功能性 class 名\r\n* 内容性 class 名\r\n* 展示性 class 名\r\n\r\n这几类 class 名是趋向于稳定特质的。如果我们遵循这些命名原则，就会显得更明智，而且我们的 CSS 会更好的适应未来的改变。\r\n\r\n### 功能性 class 名\r\n\r\n    <button class=\"positive-button\">Send Message</button>\r\n\r\n功能性 class 名例如 `positive-button`、`important-text` 或 `selected-tab`。这些元素的样式是基于其功能或含义的。所以其 class 名、样式及这样引用样式的理由，都是强连接的。因此 class 名和样式是相关的。\r\n\r\n因为有这些强连接，所以样式是几乎不会被改变的。如果你真的要改变一个 `positive-button` 的样子，那这个改变也是每个肯定语气的按钮都要改变的。如果你的设计师的想法是改变“肯定语气的按钮”，而不是设置菜单里“增加用户”的按钮，那么这件事就很轻松且易于维护。你考虑的不是哪个独立的页面，而是整个系统。\r\n\r\n功能性的 class 名很棒。只要有这个可能，这应该就是你想要撰写样式的方式。但是功能性的 class 名不是所有情况都适用的。\r\n\r\n设计并不一定都有逻辑性。当我们讨论按钮的时候，给出一个功能性的 class 名是很容易的。大部分情况下其功能和样式也紧密相关。但是我们撰写的其它 99% 的样式都不太容易给出这样的例子。有的时候这个块区域需要一个内阴影，因为这样看起来很漂亮；有的时候图标需要在 hover 的时候长大一点因为这样很 cute；有的时候文本需要是橙色的，好吧，因为它就是橙色的。一个网站不是每个视觉的部分背后都有功能性的理由，这无可厚非。\r\n\r\n所以开发者该怎么应对呢？我们站在了这个十字路口。如果我们不能想出一个合适的功能性 class 名，那么我们不妨基于内容、或者展现给它起个名字。它们也各自暗示着不同的可维护性。\r\n\r\n### 内容性 class 名\r\n\r\n    <button class=\"submit-button\">Send Message</button>\r\n\r\n基于内容的 class 名是描述它们包含的内容的 class 名。如果你曾经见到过类似 `submit-button`、`intro-text` 或 `profile-photo` 的 class 名，那些名字就是基于内容起的。\r\n\r\n这些 class 名感觉很干净。它们让你的内容 (HTML) 和样式 (CSS) 之间保持简洁的分离。理论上，这可以让你完全改版网站的样式和感官而无需触碰到 HTML。[CSS Zen Garden](http://www.csszengarden.com/) 就是这样的。\r\n\r\n现在我们回到最初的问题：“这样做的好处是什么？”\r\n\r\n我从来没有被要求改版一个网站而不触碰 HTML。变化是存在各种可能的。当然一些 HTML 可以作为后台系统的集成成果固定下来，但是随着你对 HTML 的失控，这时你还是需要写一些非理想化的 hacky CSS 来应付设计的变化。想想看，CSS Zen Garden 更多的是一个 CSS 技术演示而不是一个可维护的 CSS 的例子。没有必要一味追求在改版的时候只改 CSS。\r\n\r\n当你开发一个小网站的时候，内容性的 class 名非常好用。而随着你的网站不断成长，它就感觉越来越不合适了。它们并不易于样式重用。如果你的 `login-button` 和 `submit-button` 看起来一样该怎么处理呢？在你的 CSS 架构里该如何展示这些东西？为保持展现样式块，你不得不写一堆用逗号分隔开的选择器，或者通过预处理器展开。这些组织方式对于大型的项目来说都比较困难。\r\n\r\n*除非有更好的方式重用样式块……*\r\n\r\n### 展示性 class 名\r\n\r\n    <button class=\"green-button\">Send Message</button>\r\n\r\n展示性 class 名用诸如 `green-button`、`big-text` 或 `squiggle-border` 的方式描述一个元素。其名字本身就是对样式的描述。\r\n\r\n这些 class 是有助于代码复用的。它们不关心是否用在产品标题上还是名户名或页头。它们只知道这会让文字变大加粗。同时这样的方式还有一个好处是可以优雅的扩展。如你开发一个新组件的时候，你可以把现成的样式贴在你的新标签上。你无须担心在已有的架构中产生并适配新的样式，因为你使用的都是已有的样式。\r\n\r\n展示性 class 名也非常易于自我描述。一个开发者在审查代码的时候，`round-image` 会比 `profile-photo` 更多的推断出这个元素的样子。\r\n\r\n会有争议认为展示性 class 增加了维护成本。因为它模糊了标记和展现之间的界限，很多设计的改变都将会导致 HTML 的改变。如果你预见到了这方面的问题，那么请谨慎的使用。\r\n\r\n### ……但这不是语义化的！\r\n\r\n展示性 class 的名声并不好。尽管很多人回避它们因为它们“不是语义化的”，但这里是存在误区的，也[被 Nicolas Gallagher 质疑](http://nicolasgallagher.com/about-html-semantics-front-end-architecture/)。重要的是区分“语义化的 HTML”和“语义化的 class”。Nicolas 说的非常好：\r\n\r\n> 撰写“语义化的 HTML”的原则是现代化、专业化的前端开发的基础。大部分的语义化都关乎现有的或预期的内容的本质……\r\n> ……不过并不是所有的语义化都需要源自内容的。Class 名可以是“非语义化的”。不管使用什么名字，它们都有意义，都有目的。Class 名的语义化是不同于那些 HTML 元素的。\r\n\r\n如我写的这些，“非语义化”这个词下面是有红色波浪线的。非语义化的 class 名并不是问题。每个 class 名都有背后的意义。在你写 class 名时，不必刻意追求它是最“语义上适合的” class 名，而要创建为开发者和未来的你提供尽量多信息的 class 名。\r\n\r\n### 总结\r\n\r\n功能性 class 名通常是你的最佳选择。当你能够使用它们的时候就尽量使用。如果你无法提取出完全功能性的名字，可以考虑你的项目的本质及其发展。原则上，内容性 class 名更适合小型站点；而展示性 class 名更适合大型站点。\r\n\r\n开发者会很在意这种用法。没有人希望一个项目变得难以维护，但是每个人都有不同的 想法通过 class 名来应对这些特殊情况。这时不妨思考一下我们使用的不同类型 class 名的本质，问问自己这样做是否更好的帮助你的项目达成目标。"},"180":{"title":"由今年D2前端论坛想到的","slug":"thinking-by-d2-forum-2014","created":1414307605,"modified":1414308197,"text":"![第9届D2前端技术论坛](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2014/10/1199434854.png)\r\n\r\n之前参加过 2 次，今年的 [D2](http://d2forum.alibaba-inc.com/) 是我第一次以“自己人”的身份参加的。和往年一样，受益匪浅，但也有了一些不一样的想法。<!--more-->\r\n\r\n纵览这次 D2 的主题\r\n\r\n> * 张可竞：《指尖上的数据》\r\n> * 苏　千：《支付宝前后端分离的思考与实践》\r\n> * 林　楠：《nodejs一小步 前端开发一大步》\r\n> * 祝　犁：《Listen to the buzz of Angular.JS — 阿里云控制台AngularJS实践》\r\n> * 周　杰：《第三方开发前端实践》\r\n> * 不　四：《企业级 NPM 服务在阿里的实践》\r\n> * 贝　勒：《面向多端的蘑菇街前端技术架构》\r\n> * 弘　树：《航旅无线H5技术体系成长之路》\r\n> * 刘　威：《京东前端工业化实践之路》\r\n> * 一　位：《淘宝前端工程与自动化体系》\r\n> * 贺师俊：《透过ES6看JS未来》\r\n> * 邓　钢：《架构与IBM前端》\r\n> * 张克军：《豆瓣的前端发展思路》\r\n\r\n我们不难发现，这次的主题方向有一个很明显的趋势，就是工程体系化和整体架构。大家不约而同的在这里摸索、实践、分享，我觉得这不是一件偶然的事情。我记得自己 2011 年的时候写过[一篇关于当时如火如荼的 HTML5 的文](http://bulaoge.net/topic.blg?tuid=27015&tid=2305412)，我当时的一个观点是：\r\n\r\n> 我觉得HTML5需要更多模式化和工程化的思维，而不仅仅是技术上实现某个效果的可能性……唯有更多更丰富的上层建筑，才会让HTML5真正发挥威力……最后，优秀的规范、工具、函数库、平台、引擎、理念，才会催生真正优秀的HTML5作品甚至是HTML5产业。\r\n\r\n今天，我们已经不光拘泥于一份实用的新规范、一个酷炫的前端效果、一个满足需求设计合理的代码库，想得更远了，站得更高了。或许这一次的“绽放”过后，就是开花结果的时节了。\r\n\r\n同时我也觉得，我们今天已经有了这么大篇幅的主题了。**分享有余，讨论不足**。我认为分享和讨论应该是结合在一起才最有意义的，分享让人身临其境，讨论则会碰撞出更大的火花，产生更大的效应。**我们是否可以在各自的“独门手艺”中找到灵感和认同，进而融合、演进，产生质的飞跃，共同提升到一个更高的高度，最后发现工程与架构的普世真理，这是我由这次 D2 想到的第一件事**。\r\n\r\n第二件事是前端团队。\r\n\r\n大家在技术分享之余聊得最多的应该就是这个话题了。**怎么找工作，怎么招聘，怎么应付老板，怎么带团队**。\r\n\r\n对于前两个问题，我个人的观点是要注重技术基础和学习能力。这两点主要看个人追求和造化，而经验与工程能力是更易于在工作过程中积累和培养的。那么问题也来了：我们假设有一部分，或者说相当一部分人来参加 D2 或业余时间任何别的技术交流会，是为了自我提升而来，我们是否应该更多保留一些技术本身的话题呢？\r\n\r\n我不禁想到一个极端的情况，就是我们每个人的“格局”都很大，看得都很远，规划得也很好，但是真正做起事情来，需要动手了，就手忙脚乱了，这似乎不太好吧。**也许基础的东西是更通用的、直接受益的、可以举一反三的——尽管它不那么光鲜亮丽**。\r\n\r\n我也不相信我们今天纯技术的层面都很好了、也没有值得深入琢磨的玩意儿了。如果我们在这个地方都有长足的进步，我不担心大家找不到合适的工作，老板也不担心找不到合适的人。\r\n\r\n而对于后两个问题，我的感觉是，实际工作中，总会有一些让人觉得脏、累、烦，谁都不想处理的事情。很多团队的问题都出自如何优雅的处置这些“dirty work”。强势的主管向下施加压力，结果员工疲于奔命对主管失去信心；心软的主管仍凭大家随波逐流结果没有业绩员工也失去了信心。似乎是个解不开的锁。这确实是需要很多智慧的。那么问题又来了，**我希望 D2 今后可以有一些关于团队、关于人的主题。我们的技术能搞上去，业绩能搞上去，人，怎么样？**大家不妨一起聊聊看\r\n：）\r\n\r\n所以，我最终想说的是，把大家茶歇、酒会环节，私下交流最多的东西找出来，可以变成我们搬到台面上，认认真真探讨的话题。\r\n\r\n这些，都是我由今年 D2 前端论坛活动所想到的。\r\n\r\n当然最后，D2 也让我重逢了很多老朋友，结实了很多新朋友。期待与大家的再次见面。"},"201":{"title":"小秀个人的13~14年摄影作品 (共19张)","slug":"recent-photography-works-1314","created":1414598010,"modified":1414598010,"text":"2 年前[曾经也发过几张自己拍的照片](/blog/recent-photography-works/)，似乎大家对于我的拍照技术还是蛮宽容的。下面几张同样是我认真挑选过的这 2 年来拍的，同样求轻拍 ^_^\r\n\r\np.s. 这 2 年真的经历了不少事情\r\n\r\n港版风景\r\n\r\n![港版风景](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2014/10/1117334014.jpg)<!--more-->\r\n\r\n唐老鸭\r\n\r\n![唐老鸭](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2014/10/1245117792.jpg)\r\n\r\n春天的气球\r\n\r\n![春天的气球](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2014/10/944947581.jpg)\r\n\r\n旋转木马\r\n\r\n![旋转木马](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2014/10/425654964.jpg)\r\n\r\n快到推车里来\r\n\r\n![快到推车里来](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2014/10/3881338338.jpg)\r\n\r\n山西博物馆\r\n\r\n![山西博物馆](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2014/10/1756526801.jpg)\r\n\r\n索菲亚大教堂\r\n\r\n![索菲亚大教堂](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2014/10/50216099.jpg)\r\n\r\n年轮\r\n\r\n![年轮](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2014/10/145065245.jpg)\r\n\r\n晚霞\r\n\r\n![晚霞](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2014/10/3412909034.jpg)\r\n\r\n杭州生活\r\n\r\n![杭州生活](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2014/10/3157015940.jpg)\r\n\r\n杭州一角\r\n\r\n![杭州一角](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2014/10/2545290598.jpg)\r\n\r\n圣诞\r\n\r\n![圣诞](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2014/10/2626576913.jpg)\r\n\r\n阿里巴巴滨江园区\r\n\r\n![阿里巴巴滨江园区](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2014/10/1448677782.jpg)\r\n\r\n我的世界杯\r\n\r\n![我的世界杯](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2014/10/2963406395.jpg)\r\n\r\n手机屏保 之 淘宝城\r\n\r\n![手机屏保 之 淘宝城](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2014/10/3251135285.jpg)\r\n\r\n手机屏保 之 龙井品茶\r\n\r\n![手机屏保 之 龙井品茶](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2014/10/473912201.jpg)\r\n\r\n虾米音乐节\r\n\r\n![虾米音乐节](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2014/10/1593540102.jpg)\r\n\r\n双11演唱会\r\n\r\n![双11演唱会](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2014/10/2361046485.jpg)\r\n\r\n朋友的婚礼\r\n\r\n![朋友的婚礼](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2014/10/1761698323.jpg)\r\n\r\n"},"202":{"title":"14}, {15","slug":"2014-2015","created":1420050600,"modified":1420082774,"text":"去年年底的时候刚换了工作，刚到杭州，一到杭州就赶上996，匆匆忙忙，年底就稀里糊涂过去了  \r\n紧接着就是忙碌的一整年，忙工作，忙生活，各种忙\r\n\r\n今天晚上，改完了自己名下的最后一个bug，也算是给2014简单收个尾吧，也突然觉得自己有一点时间回顾一下了\r\n\r\n先从13年说起吧，最大的变化就是[我换工作了](http://weibo.com/1712131295/ApUfbAq2a)，也搬家了，从北京搬到了杭州，从此过上了南方人的生活：\r\n\r\n* 夏天更热，冬天屋里更冷，这一点嘛，已经差不多习惯了。无非是多开空调呗……\r\n* 空气更好，雨水更多\r\n* 交通更好，上班路上很畅通，而且有班车坐很方便\r\n* 也赶在限牌之前买到了自己心仪已久的那款车\r\n* 有了车以后，生活确实方便了许多，晚上或者周末出门有了更多选择，近郊出游也很方便，还去了一趟上海、去了一趟宁波、去了一趟横店 (说道横店，我超喜欢秦宫，气势恢宏，有刀枪剑戟的感觉)\r\n* 杭州本来也是个旅游城市，西湖、龙井、西溪湿地，也给平日的生活增添了很多乐趣\r\n* 饮食方面，这边吃海鲜/日料的机会比在北京的时候多多了，相对的火锅和面食少了\r\n* 运动比以前少了，以前在北京常踢球的，来杭州之后几乎没怎么踢，可能是因为自己没找对组织，现在逐渐开始多游泳了\r\n\r\n经过了1年多的时间，我想说，我很喜欢杭州这个地方。\r\n\r\n然后说说工作吧。\r\n\r\n这一年多时间我其实没做太多事情，更多的还是在熟悉环境，熟悉人、熟悉业务、熟悉流程、熟悉沟通方式、熟悉做事风格。阿里确实是个巨大的集团，有超过十年的历史和沉淀。我希望可以帮助团队做得更好，但首当其冲的事情是要先弄清楚游戏规则，努力找到问题的症结，谨慎的提出可实施方案，然后循序渐进的往前走。可以说每一步都要走得小心谨慎，稍有疏漏，可能就前功尽弃了，这一点在阿里可能体现的尤为明显。我想这也正是我之前的工作经验可以体现出价值的地方。\r\n\r\n从工程和管理的角度，我今年主要是以培训或布道的方式为大家分享一些系统而又务实的最佳实践，包括如何高效开会、合作、项目管理、代码管理、时间管理，也包括组织团队讨论编码规范、项目目录结构、文档格式、工具链使用等。希望可以全面的提升团队的工作效率和效果。这些工作会继续延续到2015年。\r\n\r\n团队的技术视野也是一个亟待提高的地方，这同时也和团队每一位同学的职业发展有着密切的联系，这也是在新的一年我希望可以做好的一件事。\r\n\r\n技术上，今年我主要的精力聚焦在了2件事情上：前半年花了一些时间在触摸屏幕操作上，研究了几个手势库，也尝试自己写，不过没有太像样的成果，算是个失败的过程吧，我今天回顾这件事情，主要是没有抓到重点，上来就研究多点复杂操作，也许这些东西在未来可能会显得更有价值，还是决定放一放，什么时候有了更成熟的思路，再考虑拿起来；后半年花了更多时间在 web components 上，还有 polymer 框架，我觉得这是我们看得见的未来，非常值得投入进去看一看，我和几个同事一起做了些实践，也有很多心得。\r\n\r\n在全年技术探索和实践的过程中，我有一个深刻的感悟，是和“造轮子”这件事有关系的，在今天这个技术世界里，与其说“不要重复造轮子”，不如说“造轮子”的和“用轮子”的已经是两种性质的工作了。我们今天很多人选择的工作，首要任务是造汽车而不是造轮子。我觉得这是很多讨论“到底要不要造轮子”的问题的根源。造汽车和造轮子有各自的技术含量，有各自需要认真思考的问题，如果没有认清这个问题，明明是造汽车的，结果觉得造轮子更牛掰而去造轮子，必定没有好结果，或者事倍功半；如果真想造轮子，应该好好找个造轮子的地方，才会造出最好的轮子，不然也只会做个半调子。篇幅有限，这事儿暂不细说了……\r\n\r\n技术方面还有一件事，就是开始组织 W3C 中文兴趣组的技术讨论，我们这一年组织了几次《ig在线talk》，也发起了一些标准翻译，也讨论了一些诸如首屏渲染的提案，还有中文字体和排版的制定，有的时候电话会议的时间已经超了，但是大家还会津津有味的在技术的领域里讨论闲聊，这种感觉是很少有的，相信经历过这些讨论的同学们也感受得到。\r\n\r\n另外自己在2014年初暗自下决心要看10本以上的书——这对于我这种平时没有看书习惯的人来说其实并不容易——这个目标算是已经达成了。这里面《习惯的力量》、《合作的进化》、《反脆弱》、《rework》、《remote》都是令我印象深刻的书，看过之后有非常多的收获。\r\n\r\n2015年，我有这么几个简单的想法：\r\n\r\n* 第一，要有健康的身体。这似乎是我从来没有过的对健康如此重视，也是因为现在工作和生活能够协调的更好的一个结果吧。不要连续熬夜或者休息不够，更重要的是保持运动，控制饮食，眼睛、颈椎、牙齿和肝这4个上班族体检最多出现的问题都要特别注意起来。\r\n* 第二，多花时间陪家人、老同学、周围的朋友，多参与一些社交活动\r\n* 第三，要把自己的编码量降下来，把团队打理好。我也深刻的感觉到，自己应该花更多的时间关怀身边的每一位同事，业务上的、技术上的、心态上的，都有很多值得去做的事情。让团队每一个人更好，比自己一个人更好重要的多。\r\n* 第四，把有限的个人精力集中投入在1件或几件事上\r\n* 第五，看15本书\r\n\r\n到明年这个时候，我会把这篇blog翻出来看看完成的怎么样：）"},"204":{"title":"webcomponents 笔记 之 配置管理","slug":"config-in-webcomponents","created":1427728240,"modified":1427766682,"text":"话说上周末看到[一个吐槽腾讯“内部开源”的微博](http://weibo.com/1712131295/CaM1n2FcY)，后来我想了想，自己那么骚包的在项目还没做完之前，就在 [CSSConf](/slides/css-scoping/) 上说我们将来要开源一个名叫 Zorro 的库。结果好几个月过去了还是没有准备好，也就不敢再笑话别人了……\r\n\r\n我觉得把东西开源出来之前，有几件事要准备好，不然除了自己刷存在感之外，真的没意义。比如：\r\n\r\n1. 是否有了 (或阐述清楚了) 明确的目标和方向，不然找不到合适的合作者和贡献者\r\n2. 是否有了 (或阐述清楚了) 明确的设计哲学和开发原则，不然大家无法形成合力，项目很容易陷入混乱\r\n3. 是否有了最小的可工作版本，不然雪球滚不起来\r\n4. 是否有了充分的文档、demo和测试用例，让大家更直观的了解项目，利用项目，也对项目的质量更有信心\r\n\r\n印象中我见到的优秀的开源项目，基本都在被大家广泛认识之前，都已经把这些事情打理好了——这也是我一直推崇的。  \r\n好吧很惭愧，这几点我还都没有做到……\r\n\r\n不过在这之前，我愿意在此分享一些自己开发中的心得，跟大家一起探讨相关的话题。\r\n\r\n---- 以上是一些比较啰嗦的铺陈 ----\r\n\r\n### 组件分解的方式及其衍变\r\n\r\n在开发大型应用的时候，难免要用到一些组件化的分解方式。比如：把一个相册浏览界面分解成：“相册列表”和“大图预览”两个区域，“相册列表”又由一个个“相册缩略图”组成，每个“相册缩略图”包含了一个“小图片”以及“预览按钮”、“删除按钮”、“排序按钮”等操作按钮……\r\n\r\n而如何管理和划分组件逐渐变成了前端工程里的一门学问。<!--more-->\r\n\r\n![components_1.png](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2015/03/594096967.png)\r\n\r\n最简单的分解方式是树形分解，自上而下。比如刚才的那个相册浏览界面的例子。\r\n\r\n![components_2.png](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2015/03/3435937818.png)\r\n\r\n同时，我们会发现，树形的最末端往往存在着有共性的组件，比如按钮、文本框之类的组件，它们无处不在。这时，就有了所谓的“基础组件”和“业务组件”之分。“基础组件”是共享的，树形结构中的任何一个结点(“业务组件”)都可以直接使用这些“基础组件”。\r\n\r\n![components_3.png](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2015/03/2975873720.png)\r\n\r\n如果程序的结构再复杂，那么就在“业务”和“基础”之间分更多的层，每一层有自己明确的职能范围，同时，较高层的组件可以自由调用较低层的组件。\r\n\r\n![components_4.png](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2015/03/1309938584.png)\r\n\r\n### 组件的配置信息\r\n\r\n配置信息大多是在组件在兼顾通用性抽象和特殊性业务时出现的。好的配置设计可以避免大量重复的组件设计和实现。\r\n\r\n较简单的配置信息通常都是组件本身的一些属性 (properties) 或特性 (attributes)，在 webcomponents ([polymer](http://docs.polymerchina.org/)) 的场景下，就是：\r\n\r\n    <polymer-element name=\"x-person\" attributes=\"name, age, gender, avatar, ...\">  \r\n      ...  \r\n    </polymer-element>\r\n\r\n进一步的，有时候我们需要把上层组件的配置信息带到更下层的组件：\r\n\r\n    <polymer-element name=\"x-person-avatar\" attributes=\"avatar\">  \r\n      ...  \r\n    </polymer-element>\r\n    \r\n    <polymer-element name=\"x-person\" attributes=\"name, age, gender, avatar, ...\">\r\n      <template>\r\n        ...\r\n        <x-person-avatar avatar=\"{{avatar}}\"></x-person-avatar>\r\n        ...\r\n      </template>\r\n      ...\r\n    </polymer-element>\r\n\r\n如果一个程序的组件层次太深，则可能出现下面两个问题：\r\n\r\n1. 会有一些很小的底层组件的配置信息，需要从最外层配置一层一层的“透传”到最底层，每一层组件上都要定义一个配置字段\r\n2. 最外层组件的配置字段往往会被各种七七八八的小组件配置占领\r\n\r\n于是顺着这个思路，我们发现，有一种不太起眼的办法在很早的时候就被忽略掉了——这就是全局配置信息。\r\n\r\n### 什么时候全局配置更合适\r\n\r\n通常情况下，__和整体应用所处环境相关，同时和上层组件无关的配置适合做全局配置__。\r\n\r\n举一个实践中的例子：在开发图片上传组件的时候，我们发现，图片上传组件往往需要一个上传图片的服务器地址，这个地址在固定的用户、固定的应用之中，通常是一致的，只是在不同的应用中，图片可能需要长传到不同的服务器地址。\r\n\r\n这种情况下，通过组件的配置字段一层一层向下传递找到图片上传组件显然是很繁琐的。于是我们想了个简单的办法：\r\n\r\n1. 在页面最外层 (`<body>`里面) 写入一些 `<input type=\"hidden\">` 的标签，注明服务器相关配置\r\n2. 在组件中写一段脚本，查询所有的这样的标签，并且把键值对记录下来——这其中就包括应用自身的图片上传的服务器地址\r\n\r\n_2015-03-31 追加说明：感谢民工哥 [@民工精髓](http://weibo.com/1858846672) 在[微博](http://weibo.com/1858846672/Cb3Pwd0ZO)上的指点。也是因为很多服务器的配置是后端同学决定的，所以我们创造了这种对传统后端配置友好的 `<input type=\"hidden\">` 写法。这样的写法对于后端的友好之处我就不一一列举了。如果是纯前端程序，配置来自前端，确实直接定义全局变量就好，不必这么麻烦。_\r\n\r\n于是整个程序变成了：\r\n\r\n    <polymer-element ...>\r\n      <script>\r\n        Polymer({\r\n          ready: function () {\r\n            var inputList = document.querySelectorAll('input[type=\"hidden\"]');\r\n            ...\r\n          }\r\n        });\r\n      </script>\r\n    </polymer-element>\r\n    ...\r\n    <body>\r\n      <input type=\"hidden\" name=\"uploadUrl\" value=\"/pathToUpload.do\">\r\n      ...\r\n    </body>\r\n\r\n这样不管图片上传组件用在哪里，其它组件都不会因此而产生负担，同时这些配置的管理也变得很清晰——这甚至和前端工程师平时和后端工程师协作的流程是完全吻合的：前端负责写好 components，后端负责把 `<input type=\"hidden\">` 配置好。\r\n\r\n### 如何做好配置管理\r\n\r\n我们顺着上面的思路继续想：如果程序中很多组件都有类似的配置需求，那么：\r\n\r\n1. `<input type=\"hidden\">` 不能被滥用\r\n2. 组件内部的读取配置信息的方式可以抽象出来\r\n\r\n于是，就有了 Zorro 现在的一个组件：`<z-config>`。它的大致功能如下：\r\n\r\n1. 首先它可以快速的提取 `<body>` 最外层的 `<input type=\"hidden\">` 配置信息——这显然是和后端工程师约定过的\r\n2. 其次，它可以被任何组件作为“基础组件”引用\r\n3. 它提供方便的接口，供任何上层组件访问配置信息\r\n\r\n自从有了这个组件，很多配置相关的问题在 webcomponents 中都显得很轻松了。毫不夸张的说前端工程师和后端工程师的关系也因此不像之前那么紧张了。\r\n\r\n### 管理更多的信息\r\n\r\n后来，我们在配置管理的基础上，加入了更多的实用信息。比如：\r\n\r\n* 可以读取 `location.href` 中的字段信息\r\n* 可以像 `localStorage` 一样提供一块全局共享的键值对空间，方便组件之间共享状态信息\r\n* 可以在 `<z-config>` 在被创建时，根据不同的场景设置一些初始化数据等\r\n\r\n__以上这些，构成了今天的 `<z-config>` 组件__\r\n\r\n实现机制并不复杂，这里就暂不贴代码出来了，但终归是会开源的，我保证。\r\n\r\n### 总结\r\n\r\n说回配置管理本身，它实际上是一种信息在程序和组件之间的流通方式。我们基于对 webcomponents 自身特点和形态的理解，加上业务实践中的一些体会，设计了这样的一个标签。希望给大家一些启发，同时也欢迎大家的讨论和观点。"},"209":{"title":"用 Koa 写服务体验","slug":"try-koajs","created":1434887983,"modified":1434898363,"text":"![Koa](http://img2.tbcdn.cn/L1/461/1/5682414ab4dc8dd1b4ff91b0b57f96947c1c1c11)\r\n\r\n晒一下自己用 [Koa](http://koajs.com/) next generation web framework for node.js 写的一个 web 服务\r\n\r\n这个 web 服务主要是做内容的列表展示和搜索的 (可能说得比较抽象，但确实是 web 服务最常需要做的事情) 主要的文件一共就2个：\r\n\r\n- `app.js` 主程序\r\n- `lib/model.js` 数据层\r\n\r\n其中 `model.js` 是和具体业务逻辑相关的，就不多介绍了，这也不是 Koa 的核心；而 `app.js` 的代码可以体现 Koa 的很多优点，也使得代码可以写得非常简练而去清晰——这是我自己都完全没有想到的事情\r\n\r\n<!--more-->\r\n\r\n### 加载资源和相关依赖库\r\n\r\n    // resources\r\n\r\n    var koa = require('koa')\r\n    var app = koa()\r\n\r\n    var logger = require('koa-logger')\r\n    var route = require('koa-route')\r\n\r\n    var fs = require('fs')\r\n    var path = require('path')\r\n    var extname = path.extname\r\n\r\n    var views = require('co-views')\r\n    var render = views('./views', {\r\n      map: { html: 'ejs' }\r\n    })\r\n\r\n    var model = require('./lib/model')\r\n\r\n其中：\r\n\r\n1. `koa` 是最核心的库，`app` 是 `koa` 生成的 web 服务主程序\r\n2. [`koa-logger`](https://www.npmjs.com/package/koa-logger) 和 [`koa-route`](https://www.npmjs.com/package/koa-route) 都是koa官方开发的“中间件”，分别用来打印日志和路由设置，路由设置稍后还会提到\r\n3. `fs` 和 `path` 都是 Node 的官方包，用来进行本地文件和路径相关的处理，辅助性质的\r\n4. [`co-views`](https://www.npmjs.com/package/co-views) 是用来渲染模板的库，而 `render` 是它生成的实例，这个用法也跟传统用法不太一样，稍后会提及\r\n\r\n### Web 服务工作流\r\n\r\n    // workflow\r\n\r\n    app.use(logger())\r\n\r\n    app.use(route.get('/', list))\r\n    app.use(route.get('/page/:page', list))\r\n    app.use(route.get('/search/:keywords', search))\r\n    app.use(route.get('/search/:keywords/:page', search))\r\n\r\n    app.use(function *(next) {\r\n      if (!this.path.match(/^\\/assets\\//)) {\r\n        yield* next\r\n        return\r\n      }\r\n      var path = __dirname + this.path\r\n      var fstat = yield stat(path)\r\n\r\n      if (fstat.isFile()) {\r\n        this.type = extname(path)\r\n        this.body = fs.createReadStream(path)\r\n      }\r\n    })\r\n\r\n    app.use(function *(next) {\r\n      if (this.needRendered) {\r\n        this.body = yield render(this.templateView, {cache: false, data: this.templateModel})\r\n      }\r\n      yield* next\r\n    })\r\n\r\n\r\n    // utils\r\n\r\n    function stat(file) {\r\n      return function (done) {\r\n        fs.stat(file, done)\r\n      }\r\n    }\r\n\r\n这部分代码是用来规划服务器工作流的，从请求被接受到响应被发出，整个过程都在这段代码里一览无余。工作流设计的主要的用法是 `app.use(...)`。里面的参数其实就是一个 generator。\r\n\r\n1. 首先是打开日志\r\n2. 然后是分发路由，这里可以看到，有首页、列表、搜索、搜索列表 4 种设计，分别对应到了各自的处理方，`list` 和 `search` 其实都是在利用 `lib/model` 在生成数据，准备给模板进行渲染。这里的原理也有特殊之处，稍后会看到\r\n3. 再看紧随其后的两个 `app.use`，分别是处理静态资源目录 `assets` 和对模板+数据进行渲染\r\n\r\n所以完整的工作流可以理解为：\r\n\r\n1. 请求页面 (列表或搜索) -> `logger` -> 路由分发 -> `list` 或  `search` -> 模板渲染 -> 回应\r\n2. 请求静态资源 -> `logger` -> 找到对应的 `assets` 文件 -> 回应\r\n\r\n### `function *() {}` 和 `yield` 是啥？\r\n\r\n这个其实是 Koa 的精髓所在，在介绍它之前，我们先把 `list` 和 `search` 的代码也贴出来：\r\n\r\n    // routes\r\n\r\n    function *list(page, next) {\r\n      next = arguments[arguments.length - 1]\r\n      this.templateView = 'page'\r\n      this.templateModel = yield model.list({page: page})\r\n      this.needRendered = true\r\n      yield *next\r\n    }\r\n\r\n    function *search(keywords, page, next) {\r\n      next = arguments[arguments.length - 1]\r\n      this.templateView = 'search'\r\n      this.templateModel = yield model.search({keywords: keywords, page: page})\r\n      this.needRendered = true\r\n      yield *next\r\n    }\r\n\r\n大家会发现，首先 `app.use(...)`  和 `route.get(path, ...)` 传入的参数都是一种写得很像函数的东西，但不同之处是函数的写法是 `function foo() {...}`，而这里的写法多了一个星号，即 `function *foo() {}`。这种写法其实就是 ES6 里的 generator。而 `yield` 正是配合这个写法的一种语法。\r\n\r\n有关 ES6 generator 的基础知识，建议大家来 @兔哥 的这个 [ES6 教程网页](http://es6.ruanyifeng.com/#docs/generator)来学习，这里不做原理方面的赘述。但我想说的是，由于 web 服务的处理本身就是“一层一层”的，并且有些处理是可以同步的，有些是只能异步的，我们不免要精心设计很多中间件并保障它的可扩展性，同时尽量简化异步操作的写法保障它的可读性。\r\n\r\n有了 ES6 generator 和 `yield` 之后，我们的每一层中间件都可以从流程上看成一个以 `yield *next` 语句切分出来的 “三明治”：\r\n\r\n    function *(next) {\r\n      // 下一步之前的操作\r\n      yield *next // 进行下一步\r\n      // 所有逻辑处理完之后的补充操作\r\n    }\r\n\r\n而且这个“下一步”是不介意是不是异步行为，都可以这样简单描述清楚的。\r\n\r\n![koa workflow](https://camo.githubusercontent.com/d80cf3b511ef4898bcde9a464de491fa15a50d06/68747470733a2f2f7261772e6769746875622e636f6d2f66656e676d6b322f6b6f612d67756964652f6d61737465722f6f6e696f6e2e706e67)\r\n\r\n后头看我们设计的整个工作流的实现：\r\n\r\n![workflow](http://img4.tbcdn.cn/L1/461/1/4e70cfbf5ae5069d6bb1a049cbb73e26241d34a7)\r\n\r\n我们这里的逻辑基于全部是出现在 `yield *next` 之前的，但是如果你需要在临发出响应之前做点什么，就可以写在其后面了\r\n\r\n### `co-views` 的用法\r\n\r\n`co-views` 其实是对通用模板引擎渲染平台 [consolidate](https://www.npmjs.com/package/consolidate) 的封装，consolidate 应该算是 express.js 时代非常重要的一个库，它支持包括 ejs, mustache, swig 等各种模板渲染并提供统一的 api 调用方法。根据对 `co-views` 源码的分析，它把 consolidate 统一的 api 又封装成了 `return function (done) {...}` 的形态，这样源代码中的 `yield render(view, model)` 就能够融入 generator 的逻辑之中。\r\n\r\n值得一提的是，源代码中 `yield render(view, model)` 这里的 `model` 传入了一个 `{cache: false}` 的参数，这会意味着模板不会被缓存，每次修改模板文件之后，在不重启服务的情况下，刷新页面就可以看到最新的效果。这个选项是针对开发环境设置的，为了保障线上环境的运行性能和效率，这个选项应该是不需要的。\r\n\r\n### `lib/model` 的用法\r\n\r\n同上，我们在 `lib/model.js` 里封装的 `yield model.list({page: page})` 和 `yield model.search({keywords: keywords, page: page})` 也都会生成形如 `return function (done) {...}` 的返回值，以融入 generator 的逻辑之中。\r\n\r\n### 最后，监听端口\r\n\r\n    // listen\r\n\r\n    app.listen(3000)\r\n    console.log('listening on port 3000')\r\n\r\nThat's it\r\n\r\n### 后记\r\n\r\n在首次尝试用 generator 的方式编写 web 服务的时候，我自己一开始总会把 `yield` 的位置、`yield` 后面要不要加星号、`function` 后面要不要加星号、`app.use()` 的调用顺序这几件事情弄得乱糟糟的，可能还是对 generator 和 koa 的理解不够深入，不过逐渐写着写着，感受到了更多的爽和快感。到最后用如此简单的一个 js 文件完成了全部的功能和逻辑串联，还是觉得很兴奋的。大家如果感兴趣也可以搞来玩一玩，写点自己平时用得到用不到的小玩意儿体验一下：）"},"210":{"title":"Vue + webpack 项目实践","slug":"just-vue","created":1435166473,"modified":1498552670,"text":"最近在内部项目中做了一些基于 vue + webpack 的尝试，在小范围和同事们探讨之后，还是蛮多同学认可和喜欢的，所以通过 blog 分享给更多人。\r\n\r\n首先，我会先简单介绍一下 vue 和 webpack：\r\n\r\n(当然如果你已经比较熟悉它们的话前两个部分可以直接跳过)\r\n\r\n### 介绍 vue\r\n\r\n![_2015_06_25_12_37_36](http://img4.tbcdn.cn/L1/461/1/bfe85a6c83b251c21d6b7c1fd38baae3fa790540)\r\n\r\n[Vue.js](http://vuejs.org/) 是一款极简的 mvvm 框架，如果让我用一个词来形容它，就是 __“轻·巧”__ 。如果用一句话来描述它，它能够集众多优秀逐流的前端框架之大成，但同时保持简单易用。废话不多说，来看几个例子：\r\n\r\n    <script src=\"vue.js\"></script>\r\n\r\n    <div id=\"demo\">\r\n      {{message}}\r\n      <input v-model=\"message\">\r\n    </div>\r\n\r\n    <script>\r\n      var vm = new Vue({\r\n        el: '#demo',\r\n        data: {\r\n          message: 'Hello Vue.js!'\r\n        }\r\n      })\r\n    </script>\r\n\r\n首先，代码分两部分，一部分是 html，同时也是视图模板，里面包含一个值为 `message` 的文本何一个相同值的输入框；另一部分是 script，它创建了一个 vm 对象，其中绑定的 dom 结点是 `#demo`，绑定的数据是 `{message: 'Hello Vue.js'}`，最终页面的显示效果就是一段 `Hello Vue.js` 文本加一个含相同文字的输入框，更关键的是，由于数据是双向绑定的，所以我们修改文本框内文本的同时，第一段文本和被绑定的数据的 `message` 字段的值都会同步更新——而这底层的复杂逻辑，Vue.js 已经全部帮你做好了。\r\n\r\n![_2015_06_24_11_00_20](http://img1.tbcdn.cn/L1/461/1/088c2fe6a59cf1babdb83e963e844bc62b96c8c1)\r\n\r\n<!--more-->\r\n\r\n#### 再多介绍一点\r\n\r\n我们还可以加入更多的 directive，比如：\r\n\r\n    <script src=\"vue.js\"></script>\r\n\r\n    <div id=\"demo2\">\r\n      <img title=\"{{name}}\" alt=\"{{name}}\" v-attr=\"src: url\">\r\n      <input v-model=\"name\">\r\n      <input v-model=\"url\">\r\n    </div>\r\n\r\n    <script>\r\n      var vm = new Vue({\r\n        el: '#demo2',\r\n        data: {\r\n          name: 'taobao',\r\n          url: 'https://www.taobao.com/favicon.ico'\r\n        }\r\n      })\r\n    </script>\r\n\r\n这里的视图模板加入了一个 `<img>` 标签，同时我们看到了 2 个特性的值都写作了 `{{name}}`。这样的话，图片的 `title` 和 `alt` 特性值就都会被绑定为字符串 `'taobao'`。\r\n\r\n如果想绑定的特性是像 `img[src]` 这样的不能在 html 中随意初始化的 (可能默认会产生预期外的网络请求)，没关系，有 `v-attr=\"src: url\"` 这样的写法，把被绑定的数据里的 `url` 同步过来。\r\n\r\n没有介绍到的功能还有很多，推荐大家来我(发起并)翻译的[Vue.js 中文文档](http://cn.vuejs.org/guide/)\r\n\r\n#### web 组件化\r\n\r\n最后要介绍 Vue.js 对于 web 组件化开发的思考和设计\r\n\r\n如果我们要开发更大型的网页或 web 应用，web 组件化的思维是非常重要的，这也是今天整个前端社区长久不衰的话题。\r\n\r\nVue.js 设计了一个 `*.vue` 格式的文件，令每一个组件的样式、模板和脚本集合成了一整个文件， __每个文件就是一个组件，同时还包含了组件之间的依赖关系，麻雀虽小五脏俱全，整个组件从外观到结构到特性再到依赖关系都一览无余__ ：\r\n\r\n![vue 文件示例](http://vuejs.org/images/vue-component.png)\r\n\r\n并且支持预编译各种方言：\r\n\r\n![vue 文件示例](http://vuejs.org/images/vue-component-with-pre-processors.png)\r\n\r\n这样再大的系统、在复杂的界面，也可以用这样的方式庖丁解牛。当然这种组件的写法是需要编译工具才能最终在浏览器端工作的，下面会提到一个基于 webpack 的具体方案。\r\n\r\n#### 小结\r\n\r\n__从功能角度，template, directive, data-binding, components 各种实用功能都齐全，而 filter, computed var, var watcher, custom event 这样的高级功能也都洋溢着作者的巧思；从开发体验角度，这些设计几乎是完全自然的，没有刻意设计过或欠考虑的感觉，只有个别不得已的地方带了自己框架专属的 `v-` 前缀。从性能、体积角度评估，Vue.js 也非常有竞争力！__\r\n\r\n### 介绍 webpack\r\n\r\n![](http://img1.tbcdn.cn/L1/461/1/fb28e5d63e7c32fb2bae6fe2b0539a6e9b77c737)\r\n\r\n[webpack](http://webpack.github.io/) 是另一个近期发现的好东西。它主要的用途是通过 CommonJS 的语法把所有浏览器端需要发布的静态资源做相应的准备，比如资源的合并和打包。\r\n\r\n举个例子，现在有个脚本主文件 `app.js` 依赖了另一个脚本 `module.js`\r\n\r\n    // app.js\r\n    var module = require('./module.js')\r\n    ... module.x ...\r\n\r\n    // module.js\r\n    exports.x = ...\r\n\r\n则通过 `webpack app.js bundle.js` 命令，可以把 `app.js` 和 `module.js` 打包在一起并保存到 `bundle.js`\r\n\r\n同时 webpack 提供了强大的 loader 机制和 plugin 机制，loader 机制支持载入各种各样的静态资源，不只是 js 脚本、连 html, css, images 等各种资源都有相应的 loader 来做依赖管理和打包；而 plugin 则可以对整个 webpack 的流程进行一定的控制。\r\n\r\n比如在安装并配置了 css-loader 和 style-loader 之后，就可以通过 `require('./bootstrap.css')` 这样的方式给网页载入一份样式表。非常方便。\r\n\r\nwebpack 背后的原理其实就是把所有的非 js 资源都转换成 js (如把一个 css 文件转换成“创建一个 `style` 标签并把它插入 `document`”的脚本、把图片转换成一个图片地址的 js 变量或 base64 编码等)，然后用 CommonJS 的机制管理起来。一开始对于这种技术形态我个人还是不太喜欢的，不过随着不断的实践和体验，也逐渐习惯并认同了。\r\n\r\n__最后，对于之前提到的 Vue.js，作者也提供了一个叫做 vue-loader 的 [npm 包](https://www.npmjs.com/package/vue-loader)，可以把 `*.vue` 文件转换成 webpack 包，和整个打包过程融合起来。所以有了 Vue.js、webpack 和 vue-loader，我们自然就可以把它们组合在一起试试看！__\r\n\r\n### 项目实践流程\r\n\r\n回到正题。今天要分享的是，是基于上面两个东西：Vue.js 和 webpack，以及把它们串联起来的 vue-loader\r\n\r\nVue.js 的作者以及提供了一个基于它们三者的<s>[项目示例](https://github.com/vuejs/vue-webpack-example)</s> (链接已失效)。而我们的例子会更贴近实际工作的场景，同时和团队之前总结出来的项目特点和项目流程相吻合。\r\n\r\n#### 目录结构设计\r\n\r\n- `<components>` 组件目录，一个组件一个 `.vue` 文件\r\n    - `a.vue`\r\n    - `b.vue`\r\n- `<lib>` 如果实在有不能算组件，但也不来自外部 (tnpm) 的代码，可以放在这里\r\n    - `foo.css`\r\n    - `bar.js`\r\n- `<src>` 主应用/页面相关文件\r\n    - `app.html` 主 html\r\n    - `app.vue` 主 vue\r\n    - `app.js` 通常做的事情只是 `var Vue = require('vue'); new Vue(require('./app.vue'))`\r\n- `<dist>` (ignored)\r\n- `<node_modules>` (ignored)\r\n- `gulpfile.js` 设计项目打包/监听等任务\r\n- `package.json` 记录项目基本信息，包括模块依赖关系\r\n- `README.md` 项目基本介绍\r\n\r\n#### 打包\r\n\r\n通过 `gulpfile.js` 我们可以设计整套基于 webpack 的打包/监听/调试的任务\r\n\r\n在 [gulp-webpack](https://www.npmjs.com/package/gulp-webpack#multiple-entry-points) 包的官方文档里推荐的写法是这样的：\r\n\r\n    var gulp = require('gulp');\r\n    var webpack = require('gulp-webpack');\r\n    var named = require('vinyl-named');\r\n    gulp.task('default', function() {\r\n      return gulp.src(['src/app.js', 'test/test.js'])\r\n        .pipe(named())\r\n        .pipe(webpack())\r\n        .pipe(gulp.dest('dist/'));\r\n    });\r\n\r\n我们对这个文件稍加修改，首先加入 vue-loader\r\n\r\n    tnpm install vue-loader --save\r\n\r\n    .pipe(webpack({\r\n      module: {\r\n        loaders: [\r\n          { test: /\\.vue$/, loader: 'vue'}\r\n        ]\r\n      }\r\n    }))\r\n\r\n其次，把要打包的文件列表从 `gulp.src(...)` 中抽出来，方便将来维护，也有机会把这个信息共享到别的任务\r\n\r\n    var appList = ['main', 'sub1', 'sub2']\r\n\r\n    gulp.task('default', function() {\r\n      return gulp.src(mapFiles(appList, 'js'))\r\n        ...\r\n    })\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    function mapFiles(list, extname) {\r\n      return list.map(function (app) {return 'src/' + app + '.' + extname})\r\n    }\r\n\r\n现在运行 `gulp` 命令，相应的文件应该就打包好并生成在了 `dist` 目录下。然后我们在 `src/*.html` 中加入对这些生成好的 `js` 文件的引入：\r\n\r\n    <!DOCTYPE html>\r\n    <html>\r\n    <head>\r\n      <meta charset=\"utf-8\">\r\n      <title>Main</title>\r\n    </head>\r\n    <body>\r\n      <div id=\"app\"></div>\r\n      <script src=\"../dist/main.js\"></script>\r\n    </body>\r\n    </html>\r\n\r\n用浏览器打开 `src/main.html` 这时页面已经可以正常工作了\r\n\r\n#### 加入监听\r\n\r\n监听更加简单，只要在刚才 `webpack(opt)` 的参数中加入 `watch: true` 就可以了。\r\n\r\n    .pipe(webpack({\r\n      module: {\r\n        loaders: [\r\n          { test: /\\.vue$/, loader: 'vue'}\r\n        ]\r\n      },\r\n      watch: true\r\n    }))\r\n\r\n当然最好把打包和监听设计成两个任务，分别起名为 `bundle` 和 `watch`：\r\n\r\n    gulp.task('bundle', function() {\r\n      return gulp.src(mapFiles(appList, 'js'))\r\n        .pipe(named())\r\n        .pipe(webpack(getConfig()))\r\n        .pipe(gulp.dest('dist/'))\r\n    })\r\n\r\n    gulp.task('watch', function() {\r\n      return gulp.src(mapFiles(appList, 'js'))\r\n        .pipe(named())\r\n        .pipe(webpack(getConfig({watch: true})))\r\n        .pipe(gulp.dest('dist/'))\r\n    })\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    function getConfig(opt) {\r\n      var config = {\r\n        module: {\r\n          loaders: [\r\n            { test: /\\.vue$/, loader: 'vue'}\r\n          ]\r\n        }\r\n      }\r\n      if (!opt) {\r\n        return config\r\n      }\r\n      for (var i in opt) {\r\n        config[i] = opt\r\n      }\r\n      return config\r\n    }\r\n\r\n现在你可以不必每次修改文件之后都运行 `gulp bundle` 才能看到最新的效果，每次改动之后直接刷新浏览器即可。\r\n\r\n#### 调试\r\n\r\n![_2015_06_25_12_45_41](http://img1.tbcdn.cn/L1/461/1/abd6d07395b7c9e0ced5af27ff0710ae920b0e6e)\r\n\r\n打包好的代码已经不那么易读了，直接在这样的代码上调试还是不那么方便的。这个时候，webpack + vue 有另外一个现成的东西：source map 支持。为 webpack 加入这个配置字段 `devtool: 'source-map'`：\r\n\r\n  var config = {\r\n    module: {\r\n      loaders: [\r\n        { test: /\\.vue$/, loader: 'vue'}\r\n      ]\r\n    },\r\n    devtool: 'source-map'\r\n  }\r\n\r\n再次运行 `gulp bundle` 或 `gulp watch` 试试看，是不是开发者工具里 debug 的时候，可以追踪断点到源代码了呢：）\r\n\r\n![_2015_06_25_12_43_45](http://img1.tbcdn.cn/L1/461/1/eb7099d2472232bb0c7937cc92e8745669a3ce5c)\r\n\r\n完整的 javascript 代码如下：\r\n\r\n    var gulp = require('gulp')\r\n    var webpack = require('gulp-webpack')\r\n    var named = require('vinyl-named')\r\n    \r\n    \r\n    var appList = ['main']\r\n    \r\n    \r\n    gulp.task('default', ['bundle'], function() {\r\n      console.log('done')\r\n    })\r\n    \r\n    gulp.task('bundle', function() {\r\n      return gulp.src(mapFiles(appList, 'js'))\r\n        .pipe(named())\r\n        .pipe(webpack(getConfig()))\r\n        .pipe(gulp.dest('dist/'))\r\n    })\r\n    \r\n    gulp.task('watch', function() {\r\n      return gulp.src(mapFiles(appList, 'js'))\r\n        .pipe(named())\r\n        .pipe(webpack(getConfig({watch: true})))\r\n        .pipe(gulp.dest('dist/'))\r\n    })\r\n    \r\n    \r\n    /**\r\n     * @private\r\n     */\r\n    function getConfig(opt) {\r\n      var config = {\r\n        module: {\r\n          loaders: [\r\n            { test: /\\.vue$/, loader: 'vue'}\r\n          ]\r\n        },\r\n        devtool: 'source-map'\r\n      }\r\n      if (!opt) {\r\n        return config\r\n      }\r\n      for (var i in opt) {\r\n        config[i] = opt[i]\r\n      }\r\n      return config\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     */\r\n    function mapFiles(list, extname) {\r\n      return list.map(function (app) {return 'src/' + app + '.' + extname})\r\n    }\r\n\r\n#### 最后，杜拉拉不如紫罗兰\r\n\r\n_做出一个 vue + webpack 的 generator，把这样的项目体验分享给更多的人。目前我基于团队内部在使用的轻量级脚手架工具写了一份名叫 `just-vue` 的 generator，目前这个 generator 还在小范围试用当中，待比较成熟之后，再分享出来_\r\n\r\n### 总结\r\n\r\n其实上面提到的 `just-vue` 脚手架已经远不止文章中介绍的东西了， __我们在业务落地的“最后一公里”做了更多的沉淀和积累，比如自动图片上传与画质处理、rem单位自动换算、服务端/客户端/数据埋点接口的梳理与整合、自动化 htmlone 打包与 awp 发布等等。它们为支持业务的开发者提供了更简单高效的工作体验。__ 篇幅有限，更多内容我也希望将来有机会再多分享出来。\r\n\r\n最后再次希望大家如果有兴趣的话可以来玩一下，无线前端组内的同学我都愿意提供一对一入门指导：）\r\n\r\nJust Vue！"},"211":{"title":"从原型到发布——“团队时间线” 1.0 开发心得","slug":"try-fullstack-in-timeline-app","created":1435349636,"modified":1435377366,"text":"这篇文章将会记录我自己最近一周时间里，从产生“团队时间线”这个想法，到产品设计、交互设计、开发、迭代、再到 1.0 发布的整个过程。整件事情跨越了多个分工职能，所以这件事情虽然并不大，但对我来说是一种不一样的做事方式和经历，所以觉得应该记录下来。\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2015/06/1009213551.png)\r\n\r\n![_2015_06_27_2_11_23](http://img1.tbcdn.cn/L1/461/1/08312508850019d9db1c250acd4ae15fb66053f9)\r\n\r\n“团队时间线”是个可视化展示团队所有同学时间分配/管理的平台。每个人都可以在“我的时间管理”页面极简的记录自己的时间，比如从某天到另外一天做了一个项目、或者昨天开了一个重要的会等等。\r\n\r\n<!--more-->\r\n\r\n### 从 idea 开始\r\n\r\n(下面这段阐述偏管理思考，只对技术感兴趣的同学可以跳过)\r\n\r\n为什么要做这件事情呢？是从一个我观察到的团队现状开始的：\r\n\r\n1. 今天无线前端产品线基本上是人均2到3个项目在支持，几乎没有多人同时协作一个项目或一个任务\r\n2. 前端团队并不是以业务为颗粒度存在的团队，而是团队个人分别参与到不同业务线的工作当中，业务线团队自身也有各自的项目管理机制和丰富的经验\r\n\r\n我们通常，也应该做事专注在事情上，围绕着任务、业务目标，安排不同的人参与进来，在一起协作。但这样的方式给前端团队带来了很多管理上的死角，我们并没有以人为本，关注人的状态。张三在参与的两个项目里工作安排都是合理的，但是两份工作叠加在一个人身上的时候就不一定了，但任何单个项目团队的负责人都看不到这件事。\r\n\r\n所以作为补充，我希望引入“团队时间线”，从人的维度换个角度来看问题。\r\n\r\n还有一个和时间线概念很接近的东西是“甘特图”，市面上也有不少现成的组件库，我也参与开发过一个叫 jquery.gantt 的插件。但是同样的，甘特图是专注在团队共同做好一件事情上的，而不是以人为中心的，所以每一行基本是一个子任务，像瀑布一样一步步排下来，一件事情就能占满整个屏幕的宽度和高度。而我希望时间线是可以同时让大家一眼看到前端团队全局的工作状态的。所以甘特图其实不是我想要的东西。\r\n\r\n汇总一下自己的想法：\r\n\r\n1. 以人为本，专注一个人同时做多件事情时的时间管理问题\r\n2. 能够看到团队整体的工作状态，任务的精细管理由项目团队自己来做，不产生重复管理\r\n\r\n这就是“团队时间线”想法的由来\r\n\r\n### 设计\r\n\r\n(下面这段描述请设计师和艺术家们轻拍……)\r\n\r\n![](http://image.uisdc.com/wp-content/uploads/2015/05/wireframe-mockup-prototype-differeces-1.jpg)\r\n\r\n前两天看优设哥 (优秀网页设计) 有一篇[《术语小科普！聊聊线框稿、视觉稿与原型的区别》](http://www.uisdc.com/wireframe-mockup-prototype-differeces)的文章，很多人可能会觉得这都是“别人家的设计”，没见过周围有人设计界面先画手稿的啊？不都是直接PS么？而且很多产品和交互文档都是拿同类产品截图来的，做完项目都不知道这文档是我们写出来的还是竞争对手写出来的……\r\n\r\n![](http://image.uisdc.com/wp-content/uploads/2015/05/sy20150523-.png)\r\n\r\n我自己觉得，也许对于牛掰的设计师来说，他们只是因为太牛掰了以至于可以脑补那些初级的设计手段罢了。反正自己没那个专业能力，还是照猫画虎中规中矩一点，所以就试着先画框线图，然后实现原型功能，再做出高保真视觉 (视觉稿)，再做出高保真原型来。走一遍自己认为比较“规矩“的流程\r\n\r\n![_2015_06_27_2_55_25](http://img4.tbcdn.cn/L1/461/1/72fb3861788e347254093011ad2d57eeadee23dc)\r\n\r\n![IMG_1435](http://img1.tbcdn.cn/L1/461/1/7cc8467fc8a828d6c5aad794956852052d1de553)\r\n\r\n当然，凑巧我找到了一个利器——[53 Paper](http://www.fiftythree.com/paper) + [53 Pencil](http://www.fiftythree.com/pencil)，它可以把 iPad 变成你的画板，而且 app 本身的品质是非常之高的！我现在不光拿它来画框线图，而且开会也可以拿它当会议记录本。\r\n\r\n#### 先把线框图画出来\r\n\r\n![IMG_1426](http://img2.tbcdn.cn/L1/461/1/5f84ca794875b77a534fc19ca9fd8c56dae51db1)\r\n\r\n![IMG_1431](http://img2.tbcdn.cn/L1/461/1/70fcc37b36142deb3f5c9dff4792d15bab890fed)\r\n\r\n然后趁热打铁，把组件划分出来，并定下来基本的几个组件名和方法/属性名\r\n\r\n![IMG_1427](http://img1.tbcdn.cn/L1/461/1/79b4a1148562ad9a6de3b67af9fd0a86e047436c)\r\n\r\n![IMG_1428](http://img4.tbcdn.cn/L1/461/1/5af8e7d5f282e7c05fc752cd2b63d44ef9b98543)\r\n\r\n![IMG_1432](http://img3.tbcdn.cn/L1/461/1/fe3c0abf0f7feddc60180cfe3dc9dbfa399f3a91)\r\n\r\n整个的时间大概用了半个小时\r\n\r\n#### 交互体验版本\r\n\r\n之后，我快速在 web 端实现了一个可交互的体验版本 (UI 很“抽象”，几乎没有美感可言)，大概用了一个晚上。包括时间线是可以在表头点击左右滚动的，且有平移的动画效果。\r\n\r\n_坦白讲，做到这个程度花费的时间比我想象中的少了很多，因为我用到了另外的开发利器，晚些时候介绍：）_\r\n\r\n有了这样的一个可操作版本，基本上就可以把设计好的功能和操作流程都走通一遍了。\r\n\r\n![_2015_06_27_3_48_40](http://img2.tbcdn.cn/L1/461/1/d10d65b2539085f1dc1d6436a0110aebe575b330)\r\n\r\n我把做好的这个抽象版本发给某同事，得到这样的评价：\r\n\r\n> 作为一个死码农，觉得这代码比UI漂亮，哈哈～\r\n\r\n#### Design in Browser\r\n\r\n![_2015_06_27_3_46_37](http://img3.tbcdn.cn/L1/461/1/3ae5708714ec762dc70590640fb6368e9c78948b)\r\n\r\n好吧，我紧接着就做了第三步：视觉设计，我直接利用团队已有的 Bootstrap 皮肤 + 浏览器就完成了这件事，用时 1 个小时，然后又发给了刚才那个同事：\r\n\r\n> 什么鬼，为什么突然就这么好看了  \r\n> bootstrap，果然\r\n\r\n#### 融合\r\n\r\n但其实这个设计出来的页面是不能操作的，只是个静态效果。最后我又花了差不多半个小时时间，把静态效果套到之前的“抽象”界面中。第四部也完成了。前后差不多经过了 1 天时间。\r\n\r\n### 前端开发\r\n\r\n前面已经卖了个关子了，能够用一个晚上搞定这个界面的全套功能，包括每个组件的完备性、交互反映、动画效果。Vue + webpack 功不可没，前几天我刚[博客介绍](http://jiongks.name/blog/just-vue/)过一些 vue + webpack 的内容，没错，就是用这一套技术基础快速搭建起来的。再加上前期产品设计的时候已经把组件划分和主要属性/方法命名都确定过了，所以整个开发过程完全是自顶向下的。大应用拆成子组件，子组件再拆成更小的组件；大函数写成几行伪代码，每行伪代码再拆成不同的子函数……非常之顺畅，几乎没有返工。很多地方的逻辑都是一次浏览器刷新就通过的 (那天工作状态也确实不错)\r\n\r\n![_2015_06_27_3_56_48](http://img2.tbcdn.cn/L1/461/1/83973f5da5f461820be65649bb2d1eda57037f3a)\r\n\r\n除了之前博客介绍到的 vue 和 webpack 以及 gulpfile.js 我又加入了 htmlone 打包和 awp 发布等更高集成化的工作方式。让调试、打包、发布都非常简单省时。\r\n\r\n#### 好用的库的积累\r\n\r\n- [xhr](https://www.npmjs.com/package/xhr): 可以在浏览器端被依赖的 xhr 请求函数\r\n- [parse-color](https://www.npmjs.com/package/parse-color): 处理 CSS 中的颜色值，可以返回各种格式，用在了不同任务生成的不同颜色中，同时保证颜色是半透明的。\r\n\r\n### 后端开发\r\n\r\n就在我正准备搭 Node 服务的时候，刚好找到了 @子之 子大爷，跟他聊起这件事，他也非常认同，后端的服务器设备、数据库环境和身份验证等机制都是现成的，于是大家一拍即合，迅速敲定了数据格式和服务器接口，数据基本都是通过 `GET`、`POST`、`PUT`、`DELETE` 四个 HTTP 方法完成查询、增加、更新、删除某个工作任务的。\r\n\r\n@子之 当时同时在处理的事情也比较多，但开发效率也是奇高的，早上跟他说了想法，晚上接口就准备好了。\r\n\r\n### 联调 & 发布\r\n\r\n又经过几轮松散的调试，过了不到一周时间吧。想法、设计、前端、后端都已经完成了，我们对程序进行了部署。并开始在无线前端的导购产品小组和卖家产品小组中先试用起来。\r\n\r\n### 小结\r\n\r\n如上所述，我在大概一周的时间里，参与并见证了“团队时间线”的从无到有。它给我带来的收获，一方面是从团队管理角度一个更好的方式，另一方面实践了很多自己专业范围以外的流程和事情，再一方面也实践了 vue + webpack 的项目流程设计。一举三得。\r\n\r\n希望这些产品、经验和收获可以在未来产生更大的价值，尤其是后两者"},"213":{"title":"Vue.js 源码学习笔记","slug":"vue-code-review","created":1437923741,"modified":1517851066,"text":"最近饶有兴致的又把最新版 [Vue.js](http://vuejs.org/) 的源码学习了一下，觉得真心不错，个人觉得 Vue.js 的代码非常之优雅而且精辟，作者本身可能无 (bu) 意 (xie) 提及这些。那么，就让我来吧：）\r\n\r\n### 程序结构梳理\r\n\r\n![Vue 程序结构](http://img2.tbcdn.cn/L1/461/1/8142ef3fc2055839f1a93a933d80e17694b4f76b)\r\n\r\nVue.js 是一个非常典型的 MVVM 的程序结构，整个程序从最上层大概分为\r\n\r\n1. 全局设计：包括全局接口、默认选项等\r\n2. vm 实例设计：包括接口设计 (vm 原型)、实例初始化过程设计 (vm 构造函数)\r\n\r\n这里面大部分内容可以直接跟 Vue.js 的[官方 API 参考文档](http://vuejs.org/api/)对应起来，但文档里面没有且值得一提的是构造函数的设计，下面是我摘出的构造函数最核心的工作内容。\r\n\r\n![Vue 实例初始化](http://img3.tbcdn.cn/L1/461/1/00049a09def4aff8d80f3bb7229e3f6d395426fb)\r\n\r\n整个实例初始化的过程中，重中之重就是把数据 (Model) 和视图 (View) 建立起关联关系。Vue.js 和诸多 MVVM 的思路是类似的，主要做了三件事：\r\n\r\n1. 通过 observer 对 data 进行了监听，并且提供订阅某个数据项的变化的能力\r\n2. 把 template 解析成一段 document fragment，然后解析其中的 directive，得到每一个 directive 所依赖的数据项及其更新方法。比如 `v-text=\"message\"` 被解析之后 (这里仅作示意，实际程序逻辑会更严谨而复杂)：\r\n    1. 所依赖的数据项 `this.$data.message`，以及\r\n    2. 相应的视图更新方法 `node.textContent = this.$data.message`\r\n3. 通过 watcher 把上述两部分结合起来，即把 directive 中的数据依赖订阅在对应数据的 observer 上，这样当数据变化的时候，就会触发 observer，进而触发相关依赖对应的视图更新方法，最后达到模板原本的关联效果。\r\n\r\n所以整个 vm 的核心，就是如何实现 observer, directive (parser), watcher 这三样东西\r\n\r\n<!--more-->\r\n\r\n### 文件结构梳理\r\n\r\nVue.js 源代码都存放在项目的 `src` 目录中，我们主要关注一下这个目录 (事实上 `test/unit/specs` 目录也值得一看，它是对应着每个源文件的测试用例)。\r\n\r\n`src` 目录下有多个并列的文件夹，每个文件夹都是一部分独立而完整的程序设计。不过在我看来，这些目录之前也是有更立体的关系的：\r\n\r\n![Vue 文件结构](http://img4.tbcdn.cn/L1/461/1/cb73a147451157e52500734c0d31665a9540adae)\r\n\r\n- 首先是 `api/*` 目录，这几乎是最“上层”的接口封装，实际的实现都埋在了其它文件夹里\r\n- 然后是 `instance/init.js`，如果大家希望自顶向下了解所有 Vue.js 的工作原理的话，建议从这个文件开始看起\r\n    - `instance/scope.js`：数据初始化，相关的子程序 (目录) 有 `observer/*`、`watcher.js`、`batcher.js`，而 `observer/dep.js` 又是数据观察和视图依赖相关联的关键\r\n    - `instance/compile.js`：视图初始化，相关的子程序 (目录) 有 `compiler/*`、`directive.js`、`parsers/*`\r\n- 其它核心要素：`directives/*`、`element-directives/*`、`filters/*`、`transition/*`\r\n- 当然还有 `util/*` 目录，工具方法集合，其实还有一个类似的 `cache.js`\r\n- 最后是 `config.js` 默认配置项\r\n\r\n篇幅有限，如果大家有意“通读” Vue.js 的话，个人建议顺着上面的整体介绍来阅读赏析。\r\n\r\n接下来是一些自己觉得值得一提的代码细节\r\n\r\n### 一些不容错过的代码/程序细节\r\n\r\n#### `this._eventsCount` 是什么?\r\n\r\n一开始看 `instance/init.js` 的时候，我立刻注意到一个细节，就是 `this._eventsCount = {}` 这句，后面还有注释\r\n\r\n![eventsCount1](http://img4.tbcdn.cn/L1/461/1/ba0408eb6b96275540a3584e8d2f54fc3e6fa143)\r\n\r\n> for $broadcast optimization\r\n\r\n非常好奇，然后带着疑问继续看了下去，直到看到 `api/events.js` 中 `$broadcast` 方法的实现，才知道这是为了避免不必要的深度遍历：在有广播事件到来时，如果当前 vm 的 `_eventsCount` 为 `0`，则不必向其子 vm 继续传播该事件。而且这个文件稍后也有 `_eventsCount` 计数的实现方式。\r\n\r\n![eventsCount2](http://img2.tbcdn.cn/L1/461/1/c998cff73b20104c67f9a87d696fed2e505bfb5e)\r\n\r\n![eventsCount3](http://img2.tbcdn.cn/L1/461/1/d536a283e6f76e5ab82d1fb77abea50d86edefd1)\r\n\r\n这是一种很巧妙同时也可以在很多地方运用的性能优化方法。\r\n\r\n#### 数据更新的 diff 机制\r\n\r\n前阵子有很多关于视图更新效率的讨论，我猜主要是因为 virtual dom 这个概念的提出而导致的吧。这次我详细看了一下 Vue.js 的相关实现原理。\r\n\r\n实际上，视图更新效率的焦点问题主要在于大列表的更新和深层数据更新这两方面，而被热烈讨论的主要是前者 (后者是因为需求小还是没争议我就不得而知了)。所以这里着重介绍一下 `directives/repeat.js` 里对于列表更新的相关代码。\r\n\r\n![diff1](http://img2.tbcdn.cn/L1/461/1/688d02febd3c3b0633bb89a8c6ed0d03111651de)\r\n\r\n首先 `diff(data, oldVms)` 这个函数的注释对整个比对更新机制做了个简要的阐述，大概意思是先比较新旧两个列表的 vm 的数据的状态，然后差量更新 DOM。\r\n\r\n![diff2](http://img1.tbcdn.cn/L1/461/1/947041e58ac0648ef21c0a76f88c4dd21c1e10ca)\r\n\r\n第一步：遍历新列表里的每一项，如果该项的 vm 之前就存在，则打一个 `_reused` 的标 (这个字段我一开始看 `init.js` 的时候也是困惑的…… 看到这里才明白意思)，如果不存在对应的 vm，则创建一个新的。\r\n\r\n![diff3](http://img3.tbcdn.cn/L1/461/1/befe4ad131b854f48a5db76d208d066b3fc92bf9)\r\n\r\n第二步：遍历旧列表里的每一项，如果 `_reused` 的标没有被打上，则说明新列表里已经没有它了，就地销毁该 vm。\r\n\r\n![diff4](http://img3.tbcdn.cn/L1/461/1/734be56ff87ce5f7eab1f0c2dfeccf1980bfb4fe)\r\n\r\n第三步：整理新的 vm 在视图里的顺序，同时还原之前打上的 `_reused` 标。就此列表更新完成。\r\n\r\n顺带提一句 Vue.js 的元素过渡动画处理 (`v-transition`) 也设计得非常巧妙，感兴趣的自己看吧，就不展开介绍了\r\n\r\n#### 组件的 `[keep-alive]` 特性\r\n\r\n![keepAlive1](http://img3.tbcdn.cn/L1/461/1/84c59f338de3b80f50df41aac16ef35fc7d96ee3)\r\n\r\n![keepAlive2](http://img4.tbcdn.cn/L1/461/1/aab1152e83634dcd06fdf1eb2d68aed37468c643)\r\n\r\nVue.js 为其组件设计了一个 `[keep-alive]` 的特性，如果这个特性存在，那么在组件被重复创建的时候，会通过缓存机制快速创建组件，以提升视图更新的性能。代码在 `directives/component.js`。\r\n\r\n#### 数据监听机制\r\n\r\n如何监听某一个对象属性的变化呢？我们很容易想到 `Object.defineProperty` 这个 API，为此属性设计一个特殊的 getter/setter，然后在 setter 里触发一个函数，就可以达到监听的效果。\r\n\r\n![ob](http://img3.tbcdn.cn/L1/461/1/14830039350289177a948fc2a1c3af4f84ed07d2)\r\n\r\n不过数组可能会有点麻烦，Vue.js 采取的是对几乎每一个可能改变数据的方法进行 prototype 更改：\r\n\r\n![ob_array1](http://img1.tbcdn.cn/L1/461/1/82d90098f1f2f8c0d6499e950d6f42a1ed3d64b1)\r\n\r\n但这个策略主要面临两个问题：\r\n\r\n1. 无法监听数据的 `length`，导致 `arr.length` 这样的数据改变无法被监听\r\n2. 通过角标更改数据，即类似 `arr[2] = 1` 这样的赋值操作，也无法被监听\r\n\r\n为此 Vue.js 在文档中明确提示不建议直接角标修改数据\r\n\r\n![ob_array2](http://img4.tbcdn.cn/L1/461/1/d26e450e3d6cf2e9dfb85be44bb4d61a058fa43a)\r\n\r\n同时 Vue.js 提供了两个额外的“糖方法” `$set` 和 `$remove` 来弥补这方面限制带来的不便。整体上看这是个取舍有度的设计。我个人之前在设计数据绑定库的时候也采取了类似的设计 (一个半途而废的内部项目就不具体献丑了)，所以比较认同也有共鸣。\r\n\r\n#### path 解析器的状态机设计\r\n\r\n首先要说 `parsers` 文件夹里有各种“财宝”等着大家挖掘！认真看一看一定不会后悔的\r\n\r\n`parsers/path.js` 主要的职责是可以把一个 JSON 数据里的某一个“路径”下的数据取出来，比如：\r\n\r\n    var path = 'a.b[1].v'\r\n    var obj = {\r\n      a: {\r\n        b: [\r\n          {v: 1},\r\n          {v: 2},\r\n          {v: 3}\r\n        ]\r\n      }\r\n    }\r\n    parse(obj, path) // 2\r\n\r\n所以对 `path` 字符串的解析成为了它的关键。Vue.js 是通过状态机管理来实现对路径的解析的：\r\n\r\n![state1](http://img2.tbcdn.cn/L1/461/1/192c0ee1f09e39da97f478ac487fff1a7f41ee30)\r\n\r\n咋一看很头大，不过如果再稍微梳理一下：\r\n\r\n![state graph](http://img2.tbcdn.cn/L1/461/1/3acfc1236df2d6cd068dd8540e0b0baeb4b8916b)\r\n\r\n也许看得更清楚一点了，当然也能发现其中有一点小问题，就是源代码中 `inIdent` 这个状态是具有二义性的，它对应到了图中的三个地方，即 `in ident` 和两个 `in (quoted) ident`。\r\n\r\n实际上，我在看代码的过程中[顺手提交了这个 bug](https://github.com/yyx990803/vue/issues/1063)，作者眼明手快，当天就进行了修复，现在最新的代码里已经不是这个样子了：\r\n\r\n![state2](http://img2.tbcdn.cn/L1/461/1/c3d6fbfe3fd1fec5d8bbb582b8785244107c1ce6)\r\n\r\n而且状态机标识由字符串换成了数字常量，解析更准确的同时执行效率也会更高。\r\n\r\n### 一点自己的思考\r\n\r\n首先是视图的解析过程，Vue.js 的策略是把 element 或 template string 先统一转换成 document fragment，然后再分解和解析其中的子组件和 directives。我觉得这里有一定的性能优化空间，毕竟 DOM 操作相比之余纯 JavaScript 运算还是会慢一些。\r\n\r\n然后是基于移动端的思考，Vue.js 虽确实已经非常非常小巧了 (min+gzip 之后约 22 kb)，但它是否可以更小，继续抽象出常用的核心功能，同时更快速，也是个值得思考的问题。\r\n\r\n第三我非常喜欢通过 Vue.js 进行模块化开发的模式，Vue 是否也可以借助类似 web components + virtual dom 的形态把这样的开发模式带到更多的领域，也是件很有意义的事情。\r\n\r\n### 总结\r\n\r\nVue.js 里的代码细节还不仅于此，比如：\r\n\r\n- `cache.js` 里的缓存机制设计和场景运用 (如在 `parsers/path.js` 中)\r\n- `parsers/template.js` 里的 `cloneNode` 方法重写和对 HTML 自动补全机制的兼容\r\n- 在开发和生产环境分别用注释结点和不可见文本结点作为视图的“占位符”等等\r\n\r\n自己也在阅读代码，了解 Vue.js 的同时学到了很多东西，同时我觉得代码实现只是 Vue.js 优秀的要素之一，整体的程序设计、API 设计、细节的取舍、项目的工程考量都非常棒！\r\n\r\n总之，分享一些自己的收获和代码的细节，希望可以帮助大家开阔思路，提供灵感。"},"214":{"title":"如何让办公室政治最小化","slug":"how-to-minimize-politics-in-your-company","created":1438462384,"modified":1438591926,"text":"来来来，看看办公室政治是个什么东西，以及如何将其最小化  \r\n翻译如有疏漏还请指正\r\n\r\n译自：[How to Minimize Politics in Your Company](http://www.bhorowitz.com/how_to_minimize_politics_in_your_company) via www.bhorowitz.com\r\n\r\n*更新：跟身边一些朋友讨论之后，觉得之前翻译的标题“杜绝”言过了，还是规规矩矩翻译成了“最小化”*\r\n\r\n----\r\n\r\n> Who the f@#k you think you f$&kin’ with  \r\n> I’m the f%*kin’ boss\r\n> \r\n> —Rick Ross, Hustlin'\r\n\r\n在我所有的从商经历中，我从没听过有人说：“我喜欢办公室政治”。但在我们的周围，令人深恶痛绝的政治又到处都是，甚至自己的公司就是如此。既然大家都不喜欢政治，那为什么它无处不在呢？\r\n\r\n政治行为几乎都源自 CEO。也许你会觉得：“我讨厌政治，我也不关心政治，但是我的周围充满了政治气味。这显然不是我造成的。”很遗憾，你并不需要怎么关心政治就会让你的周围充斥政治手段。实际上，很少关心政治的 CEO 才会让办公室充斥政治手段。不关心政治的 CEO 们往往会直接助涨政治行为。\r\n\r\n我这里说的政治，就是指员工追求自我职业发展多于价值产出和贡献。也许还有别样的政治类型，但是这类政治行为真的很烦。\r\n\r\n<!--more-->\r\n\r\n### 为什么会这样\r\n\r\nCEO 无意识的激励甚至有时刺激了政治行为，办公室政治由此而生。举个非常简单的例子，我们想象一下薪酬决策。作为一个 CEO，资深的员工会反复找你索要加薪。他们会提醒你自己得到的回报已经比市场行情低多了。他们甚至已经手握外面的 offer 了。你大可给他们加个薪。这听起来没什么问题，但你就这样强烈刺激了大家的政治行为。\r\n\r\n尤其是你在为一些对你的业务毫无价值的东西做奖励，员工会在你主动为他们的杰出表现嘉奖之前赚取更多的回报。为什么这样做很糟糕？我们仔细分析一下：\r\n\r\n1. 其他“好胜”的同学会立刻感到不爽。注意不管是这种不爽还是之前的奖励都和实际的业绩毫无关系。你得花很多精力处理这些跟业绩无关的鸟事。重要的是，如果你有能力上限 (competent board) 的话，你不可能给每个人预期之外的涨薪，所以这会变成一件“先到先得”的事情。\r\n2. 比较“与世无争”的 (但有可能很给力的) 同学会因为不关心政治而失去期末的涨薪。\r\n3. 公司全员都上了一课：会哭的孩子有奶吃，关心政治的人会加薪。让暴风雨来的更猛烈些吧。\r\n\r\n现在我们来到一个更复杂的例子。你的 CFO 找到你说他希望在管理方面更进一步。他说他希望最终成为 COO，想了解自己需要具备什么样的技能才能胜任公司的这一职位。作为一个积极的主管，你可能会鼓励他实现自己的梦想。你告诉他你觉得他将来一定会是一个合格的 COO，并且应该开发某些方面的技能。额外的，你告诉他应该在管理上变得够强，这样其他高管 (executes) 才会愿意为他工作。一周之后，你的另一个高管就来找你诉苦了。她说 CFO 问她愿不愿意为他工作。她说你看好他成为最终的 COO。你之前遇到过这种事情吗？恭喜你摊上大事儿了。\r\n\r\n### 如何政治最小化\r\n\r\n#### 专家 vs. 菜鸟\r\n\r\n避免政治往往会觉得不自然。它挑战了诸如开明思想或鼓励员工发展等管理最佳实践。\r\n\r\n管理高层和初级雇员的不同好比跟业余选手和职业拳手过招的不同。如果你跟一个普通人交手，你尽可自然为之不必担心。如果你想退一步，你可以先抬起你迈在前面的一只脚。如果你对垒一位专业拳手，估计就被击到了。职业拳手经过了年复一年的训练，他们善于利用你的每一处微小的失误。先抬起你迈在前面的一只脚向后退会让你在那一瞬间失去重心，这就是你的对手一直等待的机会。\r\n\r\n同样的，如果你管理一名初级雇员，他们跟你探讨职业发展的时候，你大可忘掉那些顾虑随性作答。但就像我们之前看到的，在对待那些高度敏感的老家伙时就不一样了。为了不被政治手段击倒，你需要在这方面提炼自己的技巧。\r\n\r\n#### 技巧\r\n\r\n我作为一个 CEO 发展至今，我发现三条非常有效的将政治最小化的秘诀\r\n\r\n**1. 雇佣有正确目标的人**\r\n\r\n我之前描述的例子可能卷入了有目标，但本质并不关心政治的人。并不是所有的情况都是这样的。毫无疑问，把你的公司政治搞成美国参议院级别的方式就是雇佣错误目标的人。正如 [Andy Grove](https://zh.wikipedia.org/wiki/%E5%AE%89%E8%BF%AA%C2%B7%E8%91%9B%E6%B4%9B%E5%A4%AB) 所说，正确的目标是把主管的个人成功和公司成功和公司产品的胜利息息相关。错误的目标是把主管的个人成功和公司的收入划清界限。\r\n\r\n**2. 为潜在的政治行为建立严格的机制并坚持贯彻**\r\n\r\n某些行动会助涨政治，比如这三点：\r\n\r\n- 绩效评估和薪酬调整\r\n- 组织结构设计与调整\r\n- 晋升\r\n\r\n我们来审视在每一种情况下，你该如何制定程序来杜绝不好的行为和政治的动机。\r\n\r\n*绩效管理和薪酬调整*\r\n\r\n公司的绩效管理和薪酬调整通常都有一些滞后。这并不意味着他们没有认可员工或不给员工加薪，这仅仅是因为他们仓促特许此事在政治手段面前是非常脆弱的。通过规范合理的结构、正规的绩效评估和薪酬评估，你会在更高的高度明确薪水和股票的涨幅情况。尤其对高管的薪酬调整尤为重要，因为这样做会杜绝政治。在上面的例子中，CEO 应该有一套滴水不漏的绩效和薪酬政策，并且跟高管明确他的薪酬会被其他所有人评估。理想状态下，高管的薪酬体系应该有董事会的参与。这会 a) 有助于更好的管理 b) 让意外更难出现。\r\n\r\n*组织结构设计与调整*\r\n\r\n如果你管理高级员工，他们会一次又一次希望扩展自己的职责范围。在上面的例子中，CFO 希望成为 COO。在其它情形下，市场的一把手都希望把销售和市场一起运作起来，或工程的一把手希望把研发和产品管理都握在手上。当有些人向你提出类似的要求时，你要非常小心作答，因为你所讲的每一句话都会变成定时炸弹。一般情况下最好什么都别说。最多问问为什么，并且要牢记不要对对方提及的原因做出任何回应和解释。如果你表明了你的想法，那它一定会被传出去的，谣言会变得到处都是，你的周围会被业务无关的讨论所淹没。你应该基于常规的考虑评估你的组织结构，为了做出正确的决定，你可以获取必要的信息，但不要把你的计划透露或暗示出去。一旦你做了决定，那么就立刻执行组织结构调整：别让谣言先传到园区里。\r\n\r\n*晋升*\r\n\r\n每次你的公司提拔某些人的时候，其他同级别的人都会对此指指点点，探讨这个人是因为业绩好还是会来事儿才得到晋升的。如果答案是后者，那么其他人的反应无外乎是下面这三种：\r\n\r\n1. 他们闷闷不乐，感觉被低估了\r\n2. 他们表现出不认同，跟这个人对着干，并在背后使坏\r\n3. 他们决定也学这个人的政治手段，因此产生了更多不合理的晋升\r\n\r\n很明显哪种行为你都不希望看到。因此你必须有一个正式的、透明的、有正当理由的晋升流程来决定每个人的晋升。通常这个流程是由其他团队成员参与的 (一般晋升流程要让其他主管参与，这些主管的工作性质和这个人类似，高管的晋升流程里应该有董事会的参与)。这个流程的目的是两面的。一方面它会让组织相信公司至少是基于业绩进行晋升评估的，另一方面流程的结果足以充分解释你的晋升。\r\n\r\n**3. 小心别人打来的“小报告”**\r\n\r\n一旦你的组织壮大到一定规模，团队成员就会不断相互投诉和抱怨。有时这些批评是非常激进的。要非常小心留意你听到的话以及它背后传递的信息。如果单纯的没有任何防备的解答员工提出的问题，你很容易把你内心认同的信息传递出去。如果大家在公司认为你觉得某个高管不够好，这样的信息会迅速传播开来，并且不会有人求证真相的。最后，大家都不再相信那个“问题高管”，做事也不再有效率。\r\n\r\n这里有两种典型的你会听到的抱怨：\r\n\r\n1. 抱怨一个高管的行为\r\n2. 抱怨一个高管的能力和业绩\r\n\r\n对于第一种问题，一般最好的处理方式就是找投诉和被投诉的双方高管拉到一个小黑屋里当面把事情解释清楚。通常一个当面的沟通就可以挽回冲突和错误 (如有)。不要试图隔空解决问题，那样只会带来问题和政治。\r\n\r\n第二种问题会更少见同时处理起来也更复杂。如果你的一个高管鼓起勇气质疑他同伴的能力，那么很有可能，这两个人之间有很严重的问题。如果你遇到了这种问题，你一般会得到下面两种回复中的一种：a) 你会从他们那里得知一些你已经知道的事情，或者 b) 他们会给你“惊喜”。\r\n\r\n如果他们告诉你的是你已经知道的事情，那么最主要的问题就是你已经让这个问题存在太久了。不论你迟迟不解决问题的理由是什么，你把这件事拖太久了导致现在你的团队已经向这名主管发难。你必须用最快速度解决这个问题。基本上你是要解雇这名高管了，因为我看到过的高官们只有提升得自己业绩和技能的，却从没有重拾起团队的信任和支持的。\r\n\r\n而如果你收到的是信息是你从未了解过的，那么你必须立刻打断他，让这位抱怨别人的高管明确，你没办法确定这个评判。你不希望在重新审视他的表现之前就做处理。你也不希望大家觉得投诉是万能的。一旦你终止了谈话，你必须立刻重新审视这名被抱怨的员工。如果你发现他表现的很好，那么你必须找出抱怨他的人的动机并把它处理好，不要让这种言论占上风。如果你发现这个员工确实有问题，那么再回到抱怨他的人提供的信息，这时你应该明确处理表现不好的人。\r\n\r\n### 总结\r\n\r\n作为 CEO，你必须系统的考虑自己的一言一行导致的结果。开放，负责，目标导向才是王道，尽量避免错误的激励方式。"},"215":{"title":"手机淘宝前端的图片相关工作流程梳理","slug":"our-image-workflow","created":1439194546,"modified":1439194928,"text":"本文首发自[阿里无线前端博客](https://github.com/amfe/article/issues/8)\r\n\r\n_注：本文摘自阿里内网的无线前端博客《无线前端的图片相关工作流程梳理》。其实是一个月前写的，鉴于团队在[中国第二届 CSS Conf](http://css.w3ctech.com/) 上做了《手机淘宝 CSS 实践启示录》的分享，而图片工作流程梳理是其中的一个子话题，故在此一并分享出来，希望仍可以给大家一些经验和启发。另外，考虑到这是一篇公开分享，原版内容有部分删节和调整，里面有一些经验和产出是和我们的工作环境相关的，不完全具有普遍性，还请见谅。_\r\n\r\n今天很荣幸的跟大家分享一件事情，就是经过差不多半年多的努力，尤其是最近 2 周的“突击扫尾”，无线前端团队又在工具流程方面有了一个不小的突破：我们暂且称其为“图片工作流”梳理。\r\n\r\n### 图片！图片！图片！\r\n\r\n要说最近 1 年里，无线前端开发的一线同学最“难搞”的几件事，图片处理绝对可以排在前三。\r\n\r\n- 首先，我们首先要从视觉稿 (绝大部分出自 photoshop) 里把图片合理的分解、测量、切割、导出——俗称“切图”\r\n- 然后，我们要把切好的图放入页面代码中，完成相关的本地调试\r\n- 第三步，把本地图片通过一个内部网站 (名叫 TPS) 上传到我们的图片 CDN 上，并复制图片的 CDN 地址，把本地调试用的相对路径替换掉\r\n- 第四步，不同的图片、不同的外部环境下 (比如 3g 还是 wifi)，我们需要给图片不一样的尺寸、画质展现，并有一系列的配置需要遵循\r\n- 如果视觉稿有更改 (不要小看这件事，微观上还是很频繁的哦)，不好意思，从第一步开始再重新走一遍……\r\n\r\n这里面“难搞”在哪些地方呢？我们逐一分析一下：\r\n\r\n1. “切图”的效率并不高，而且每一步都很容易出现返工或再沟通\r\n2. 打开 TPS 网站上传图片放到前端开发流程中并不是一个连贯流畅的步骤，而且 GUI 相比于命令行工具的缺陷在于无法和其它工具更好的集成\r\n3. 替换 CDN 图片路径的工作机械而繁琐，并且代码中替换后的图片地址失去了原本的可读性，非常容易造成后期的维护困惑甚至混乱\r\n4. 适配工作异常繁杂和辛苦，也很容易漏掉其中的某个环节\r\n5. 视觉变更的成本高，web 的快速响应的特点在丧失\r\n\r\n所以可能把这些东西画成一张图表的话：\r\n\r\n![](http://img2.tbcdn.cn/L1/461/1/58a8b4f12816b6f71918c31ee5a0ceae74f40fb9)\r\n\r\n### 团队的单点突破\r\n\r\n在最近半年的一段时间里，无线前端团队先后发起了下面几项工作，从某个点上尝试解决这些问题：\r\n\r\n<!--more-->\r\n\r\n#### lib.flexible\r\n\r\n首先，我们和 UED 团队共同协商约定了一套 REM 方案 (后更名为 flexible 方案，进而演进为 lib.flexible 库)，通过对视觉稿的产出格式的约定，从工作流程的源头把控质量，同时在技术上产出了配套的 [lib.flexible](https://github.com/amfe/lib-flexible/) 库，可以“抹平”不同设备屏幕的尺寸差异，同时对清晰度进行了智能判断。这部分工作前端的部分是 @wintercn 寒老师和 @terrykingcha 共同创建的。\r\n\r\n![](http://img4.tbcdn.cn/L1/461/1/bd051f9dbea5cf39a1b087f552181ce509ca5c7f)\r\n\r\n#### 视觉稿辅助工具普及\r\n\r\n其次，我们于去年 12 月开始启动了一个“视觉稿工具效率提升”的开放课题，由团队的 @songsiqi 负责牵头，我们从课题的一开始就确立了 KPI 和 roadmap，经过一段时间的调研和落实，收罗了很多实用的辅助工具帮助我们提升效率，同时布道给了整个团队。比如 [cutterman](http://www.cutterman.cn/)、[parker](http://www.cutterman.cn/parker)、[Size Marks](https://github.com/romashamin/Size-Marks-PS) 等\r\n\r\n#### img-uploader\r\n\r\n在 @hongru 去年主持完成的一系列 One-Request 前端工具集当中，有一个很有意义的名叫 `or-uploadimg` 的图片上传工具。它把 TPS 的图片上传服务命令化了。这给我们对图片上传工作批量化、集成化提供了一个非常重要的基础！这个工具同时也和淘宝网前端团队的另一个 TPS 图片上传工具有异曲同工之妙。大概用法是这样的，大家可以感受一下：\r\n\r\n    var uploader = require('@ali/or-uploadimg');\r\n\r\n    // 上传 glob 多张图\r\n    uploader('./**/*.jpg', function (list) {\r\n        console.log(list)\r\n    });\r\n    // 上传多张\r\n    uploader(['./1.jpg', './3d-base.jpg'], function (list1, list2) {\r\n        console.log(list1, list2);\r\n    })\r\n\r\n    // 上传单张\r\n    uploader('./3d-base.jpg', function (list1) {\r\n        console.log(list1)\r\n    })\r\n\r\n随后团队又出现了这一工具的 [gulp](http://gulpjs.com) 插件，可以对图片上传的工作流程做一个简单的集成，具体集成方式是分析网页的 html/css 代码，找到其中的相对图片地址并上传+替换 CDN URL。\r\n\r\n    var gulp = require('gulp');\r\n    var imgex = require('@ali/gulp-imgex');\r\n\r\n    gulp.task('imgex', function() {\r\n        gulp.src(['./*.html'])\r\n            .pipe(imgex())\r\n            .pipe(gulp.dest('./'));\r\n\r\n        gulp.src('./css/*.css')\r\n            .pipe(imgex({\r\n                base64Limit: 8000, // base64化的图片size上限，小于这个size会直接base64化，否则上传cdn\r\n                uploadDest: 'tps' // 或者 `mt`\r\n            }))\r\n            .pipe(gulp.dest('./css'));\r\n    });\r\n\r\n#### lib.img\r\n\r\n`lib.img` 是团队 @chenerlang666 主持开发的一个基础库，它是一套图片自动处理优化方案。可以同时解决屏幕尺寸判断、清晰度判断、网络环境判断、域名收敛、尺寸后缀计算、画质后缀计算、锐化度后缀计算、懒加载等一系列图片和性能相关的问题。这个库的意义和实用性都非常之高，并且始终保持着快速的业务响应和迭代周期，也算是无线前端团队的一个明星作品，也报送了当年度的无线技术金码奖。\r\n\r\n![](http://img1.tbcdn.cn/L1/461/1/b98433bdbbf29c3682b169bd3f004a22fc5935d1)\r\n\r\n#### px2rem\r\n\r\n[px2rem](https://www.npmjs.com/package/px2rem) 是 @songsiqi 主持开发的另一个小工具，它因 lib.flexible 方案而生，因为我们统一采用 rem 单位来最终记录界面的尺寸，且对于个别1像素边框、文本字号来说，还有特殊的规则作为补充 (详见 lib.flexible 的文档)。\r\n\r\n![](http://img4.tbcdn.cn/L1/461/1/b78ccf6e3f3332e03751e6fbbec1abeec25bee1c)\r\n\r\n同样的，它也有 [gulp](https://www.npmjs.com/package/gulp-px2rem) / browser 的各种版本。\r\n\r\n#### img4dpr\r\n\r\n`img4dpr` 则是一个可以把 CSS 中的 CDN URL 自动转成 3 种 dpr 下不同的尺寸后缀。算是对 lib.img 的一个补充。如果你的图片不是产生在 `<img>` 标签或 JavaScript 中，而是写在了 CSS 文件里，那么即使是 lib.img 恐怕也无能为力，img4dpr 恰恰是在解决这个问题。\r\n\r\n![](http://img1.tbcdn.cn/L1/461/1/d0d545549d5a93d5a717ac673c7d54701f0d4066)\r\n\r\n### 完事儿了吗？\r\n\r\n看上去，团队为团队做了很多事情，每件事情都在单点上有所突破，解决了一定的问题。\r\n\r\n但我们并没有为此停止思考\r\n\r\n有一个很明显的改进空间在这里：今天我们的前端开发流程是一整套工程链路，每个环节之间都紧密相扣， __解决了单点的问题并不是终点，基于场景而不是功能点的思考方式，才能够把每个环节都流畅的串联起来，才能给前端开发者在业务支持的过程当中提供完美高效畅通无阻的体验——这是我们为之努力的更大的价值！也是我认为真正“临门一脚”的最终价值体现！__\r\n\r\n### 基于场景的思维方式\r\n\r\n__这种思维方式听上去很玄幻，其实想做到很简单，我们不要单个儿看某个工具好不好用，牛不牛掰，模拟真实工程场景，创建个新项目，从“切图”的第一步连续走到发布的最后一步，看看中间哪里断掉了？哪里衔接的不自然？哪里不完备？哪里重复设计了？哪里可以整合？通常这些问题都会变得一目了然。__\r\n\r\n首先，在 Photoshop 中“切图”本身的过程对于后续的开发流程来说是相对独立的，所以这里并没有做更多的融合 _(从另外一个角度看，这里其实有潜在的改造空间，如何让“切图”的工作也能集成到前端工具链路中，这值得我们长期思考)_\r\n\r\n然后，从图片导出产生的那一刻起，它所经历的场景大概会是这么几种：\r\n\r\n- 放入 `images` 文件夹\r\n  - to HTML\r\n    - src: (upload time) -> set `[src]` -> webpack require -> hash filename (upload time) -> file-loader\r\n    - data-src\r\n      - (upload time) -> set `[data-src]` -> lib.img (auto resize)\r\n  - to JavaScript: element.src, element.style.backgroundImage\r\n      - (upload time) -> set `[data-src]` data\r\n      - (upload time) -> set `[src]` (manually resize)\r\n      - (upload time) -> set `element.style.background` -> lib.img (manually resize)\r\n  - to CSS: background-image\r\n      - (upload time) -> set `background` -> postcss (upload time) -> px2rem, img4dpr\r\n\r\n其中 `(upload time)` 指的是我有机会在这个时机把图片上传到 CDN 并把代码里的图片地址替换掉；`(* resize)` 指的是我有机会在这个时机把图片的域名收敛/尺寸/画质/锐化度等需求处理掉。\r\n\r\n经过这样一整理，我们很容易发现问题：\r\n\r\n1. 图片上传存在很多种可选的时机，并没有形成最佳实践\r\n2. 有些链路完全没有机会做必要的处理 (如 to HTML -> src 的链路无法优化图片地址)\r\n3. 有些链路处理图片的逻辑并不够智能 (比如需要手动确定优化图片选项的链路)\r\n4. 图片上传 CDN 之后必须手动替换掉源代码里的图片路径，这个问题在任何一个链路里都没有得到解决\r\n5. CSS 相关的小工具很多，比较零散，学习和使用的成本在逐步变高变复杂\r\n6. 没有统一完善的项目脚手架，大家创建新项目都需要初始化好多小工具的 gulp 配置 (当然有个土办法就是从就项目里 copy 一份 `package.json` 和一份 `gulpfile.js`)\r\n\r\n### 基于场景的“查漏补缺”\r\n\r\n![](http://gtms03.alicdn.com/tps/i3/TB1xb2FIpXXXXb7XVXXtkvyUVXX-2048-1536.jpg)\r\n\r\n在完善场景的“最后一公里”，我们做了如下的工作：\r\n\r\n1. 把所有的 CSS 工具集成到了 postcss，再通过 postcss 的 gulp 插件、webpack 插件、browserify 插件令其未来有机会灵活运用到多种场景而不需要做多种工具链的适配，即：postcss-px2rem、postcss-img4dpr，同时额外的，借此机会引入 postcss-autoprefixer，让团队拜托旧的 webkit 前缀，拥抱标准的写法\r\n2. 把图片上传的时机由最早的 or-imgex-gulp 在最后阶段分析网页的html/css代码上传替换其中的图片，变为在 `images` 目录下约定一个名为 `_cdnurl.json` 的文件，记录图片的 hash 值和线上 CDN 地址，并写了一个 `@ali/gulp-img-uploader` 的 gulp 插件，每次运行的时候会便利 `images` 文件夹中的图片，如果出现新的 hash 值，就自动上传到 CDN，并把相应生成的 CDN URL 写入 `_cdnurl.json`\r\n3. 同时，这个文件可以引入到页面的 JavaScript 环境中，引入到 img4dpr 工具中，引入到 lib.img 的逻辑中，让 HTML/CSS/JavaScript 的各种使用图片的场景都可以访问到 `_cdnurl.json` 中记录的本地图片路径和线上地址的对应关系\r\n4. 这也意味着 lib.img, img4dpr 需要做相应的改动，同时\r\n5. 页面本身要默认把 `_cdnurl.json` 的信息引入以做准备\r\n6. 创建一个 lib.cdnurl 的库，在图片未上传的情况下，返回本地路径，在已经上传的情况下，返回 CDN URL，这样通过这个库作支持，外加 lib.img、img4dpr，开发者可以做到在源代码中完全使用本地路径，源代码的可读性得到了最大程度的保证\r\n7. 基于 adam 创建一个包含全套工具链路的项目模板 (脚手架)\r\n\r\n上述几件事我们于上周一做了统一讨论和分工，这里要感谢 @mingelz @songsiqi @chenerlang666 的共同努力！！\r\n\r\n#### 夹带私货 (偷笑)\r\n\r\n我在这个过程中，融入了之前一段时间集中实践的 [vue 和 webpack 的工程体系](http://jiongks.name/blog/just-vue/)，在 vue 的基础上进行组件化开发，在 webpack 的基础上管理资源打包、集成和发布，最终合并在了最新的 just-vue 的 adam template 里面。\r\n\r\n之前不是在文章的最后卖了个“最后一公里”的关子吗，这里介绍的图片工作流改进就是其中的一部分：）\r\n\r\n同时，我基于 lib.img 的思路，结合 vue.js 自身的特点，写了一个 `v-src` 的 directive，在做到 lib.img 里 `[data-src]` 相同目的的同时，更好的融入了 vue.js 的体系，同时加入了更高集成度的功能，稍后会再介绍。\r\n\r\n__夹带了私货之后是不是我就没法用了？__\r\n\r\n最后我想强调的是，除了自己的这些“私货”之外，上面提到的几个改进点和这些个人的内容是完全解耦的，如果你不选择 vue.js 或 webpack 而是别的同类型工具或自己研发的一套工具，它依然可以灵活的融入你的工作流程中。\r\n\r\n### 最终效果\r\n\r\n我们在团队内部把这些工作流程以脚手架的方式进行了沉淀，并放在了团队内部叫做 `adam` 的 generator 平台上 (后续会有介绍) 取名叫做 `just-vue` (时间仓促，adam 和相关的 generator 未来会在适当的时机开放出来)。大致用法：\r\n\r\n安装 adam 和 just-vue 模板：\r\n\r\n    tnpm install -g @ali/adam\r\n    adam tmpl add <just-vue git repo>\r\n\r\n交互式初始化新项目：\r\n\r\n    $ adam\r\n\r\n    ? Choose a template: just-vue\r\n    ? Project Name: y\r\n    ? Git User or Project Author: ...\r\n    ? Your email address: ...\r\n    Awesome! Your project is created!\r\n     |--.gitignore\r\n     |--components\r\n     |--|--foo.vue\r\n     |--gulpfile.js\r\n     |--images\r\n     |--|--_cdnurl.json\r\n     |--|--logo.png\r\n     |--|--one.png\r\n     |--|--taobao.jpg\r\n     |--lib\r\n     |--|--lib-cdnurl.js\r\n     |--|--lib-img.js\r\n     |--|--vue-src.js\r\n     |--package.json\r\n     |--README.md\r\n     |--src\r\n     |--|--main.html\r\n     |--|--main.js\r\n     |--|--main.vue\r\n\r\n#### 目录结构剖析\r\n\r\n然后大家会看到项目目录里默认就有：\r\n\r\n- `gulpfile.js`，里面默认写好了图片批量上传并更新 `_cdnurl.json`、webpack 打包、htmlone 合并 等常见任务\r\n- `images` 目录，里面放好了关键的 `_cdnurl.json`，还有几张图片作为示例，它们的 hash 和 CDN URL 已经写好了\r\n- `src/main.*`，主页面入口，包括一个 htmlone 文件 (`main.html`)，一个 webpack 文件 (`main.js`) 和一个 vue 主文件 (`main.vue`)，默认引入了需要的所有样式和脚本，比如 lib.img, lib.flexible, lib.cdnurl, _cdnurl.json, v-src.js 等，我们将来主要的代码都会从 `main.vue` 写起——额外的，我们为 MT 模板开发者贴心的引入了默认的 mock 数据的 `<script data-mt-variable=\"data\">` 标签，不需要 MT 模板开发环境的将其删掉即可\r\n- `components` 目录，这里会把我们拆分下来的子组件都放在这里，我们示范性的放了一个 `foo.vue` 的组件在里面，并默认引入了 lib.cdnurl 库\r\n- `lib` 这里默认放入了 lib.img, lib.cdnurl, v-src.js 几个库，这几个库在未来逐步稳定之后都会通过 tnpm + CommonJS 的方式进行管理，目前团队 tnpm + CommonJS 的组件整合还需要一定时间，这里是个方便调整迭代的临时状态。\r\n\r\n然后，我们来看一看 `main.vue` 里的细节，这才是真正让你真切感受到未来开发体验的地方。\r\n\r\n#### 图片工作场景\r\n\r\n首先，新产生任何图片，尽管丢到 `images` 目录，别忘了起个好理解的文件名\r\n\r\n#### CSS 中的图片\r\n\r\n然后，在 `main.vue` 的第 11 行看到了一个 CSS 的 background-image 的场景，我们只是把 `url(../images/taobao.jpg)` 设为其背景图片：\r\n\r\n    background-image: url(../images/taobao.jpg);\r\n\r\n__完成了！就这样！你在发布之前不需要再关注额外的事情了。没有手动上传图片、没有另外的GUI、没有重命名、没有 CDN 地址替换、没有图片地址优化、没有不可读的代码__\r\n\r\n#### HTML 中的图片\r\n\r\n我们再来看看 HTML 里的图片，来到 39 行：\r\n\r\n    <img id=\"test-img\" v-src=\"../images/one.png\" size=\"cover\">\r\n\r\n__一个 `[v-src]` 特性搞定！就这样！你在发布之前不需要再关注额外的事情了__ (这里 `[size]` 特性提供了更多的图片地址优化策略，篇幅有限，大家感兴趣可以移步到 `lib/vue-src.js` 看其中的实现原理)。\r\n\r\n#### JavaScript 中的图片\r\n\r\n最后再看看在 JavaScript 里使用图片，来到 68 行：\r\n\r\n    this.$el.style.backgroundImage = 'url(' + cdn('../images/logo.png') + ')'\r\n\r\n__只加入了一步 `cdn(...)` 的图片生成，也搞定了！就这样！你在发布之前不需要再关注额外的事情了。__\r\n\r\n#### 发布\r\n\r\n那有人可能会怀疑： __“那你都说发布之前很方便，发布的时候会不会太麻烦啊？”__\r\n\r\n好问题，发布就两行命令：\r\n\r\n    # 图片增量上传、webpack 打包、htmlone 合并，最终生成在 dist 目录\r\n    gulp\r\n    # 交互式上传到 awp\r\n    awp\r\n\r\n正常的命令行反应是类似这样的：\r\n\r\n    $ gulp\r\n    [04:46:48] Using gulpfile ~/Sites/alibaba/samples/y/gulpfile.js\r\n    [04:46:48] Starting 'images'...\r\n    uploaded ../images/logo.png e1ea82cb1c39656b925012efe60f22ea http://gw.alicdn.com/tfscom/TB1SDNqIFXXXXaTaXXX7WcCNVXX-400-400.png\r\n    uploaded ../images/one.png 64eb2181ebb96809c7202a162b9289fb http://gw.alicdn.com/tfscom/TB1G7JHIFXXXXbTXpXX_g.pNVXX-400-300.png\r\n    uploaded ../images/taobao.jpg 4771bae84dfc0e57f841147b86844363 http://gw.alicdn.com/tfscom/TB1f2xSIFXXXXa1XXXXuLfz_XXX-1125-422.jpg\r\n    [04:46:48] Finished 'images' after 46 ms\r\n    [04:46:48] Starting 'bundle'...\r\n    [04:46:49] Version: webpack 1.10.1\r\n          Asset     Size  Chunks             Chunk Names\r\n        main.js  17.1 kB       0  [emitted]  main\r\n    main.js.map  23.5 kB       0  [emitted]  main\r\n    [04:46:49] Finished 'bundle' after 1.28 s\r\n    [04:46:49] Starting 'build'...\r\n    \"htmlone_temp/cdn_combo_1.css\" downloaded!\r\n    \"htmlone_temp/cdn_combo_0.js\" downloaded!\r\n    [04:46:57] >> All html done!\r\n    [04:46:57] Finished 'build' after 8.07 s\r\n    [04:46:57] Starting 'default'...\r\n    done\r\n    [04:46:57] Finished 'default' after 130 μs\r\n    $ awp (交互式过程略)\r\n\r\n你甚至可以写成一行：\r\n\r\n    gulp && awp\r\n\r\n最终这个初始化工程的示例页面的效果如下\r\n\r\n![](http://img4.tbcdn.cn/L1/461/1/a9b1d49e0461e8f7b652d4fac2bb21998eed638d)\r\n\r\n#### 设计变更了？\r\n\r\n这条链路是我们之前最不愿意面对的，今天，我们来看看这条链路变成了什么，假设有一张设计图要换：\r\n\r\n1. 在 Photoshop 里把图重新切下来\r\n2. 同名图片文件放入 `images` 文件夹\r\n3. 运行 `gulp && awp`\r\n\r\n__就这样！__\r\n\r\n额外的，如果尺寸有变化，就加一步：更改相应的 CSS 尺寸代码\r\n\r\n### 总结\r\n\r\n在整个团队架构的过程中，大家都在不断尝试，如何以更贴近开发者真实场景的方式，还原真实的问题，找出切实有效的解决方案，而不仅仅是单个功能或特性。这样我们往往会找到问题的关键，用最精细有效的方式把工作的价值最大化。其实“基于场景的思维方式”不只是流程设计的专利，我们业务上的产品设计、交互设计更需要这样的思维。我个人也正是受到了一些产品经理朋友们的思维方式的影响，把这种方式运用在了我自己的工作内容当中。希望我们产出的这套方案能够给大家创造一些价值，更是向大家传递我们的心得体会，希望这样的思维方式和做事方式可以有更多更广的用武之地。"},"216":{"title":"如何成为一名卓越的前端工程师","slug":"how-to-become-a-great-front-end-engineer","created":1439204458,"modified":1498552771,"text":"译自 [Philip Walton 的博客](http://philipwalton.com/articles/how-to-become-a-great-front-end-engineer/)\r\n\r\n看过之后非常有感触，很多观点都是自己长期非常坚持和认同的，所以翻译出来分享给更多的前端同学！\r\n\r\n----\r\n\r\n最近我收到一封读者来信让我陷入了思考，信是这么写的：\r\n\r\n> Hi Philip，您是否介意我问您是如何成为一名卓越 (great) 的前端工程师的？对此您有什么建议吗？\r\n\r\n我不得不承认，我很惊讶被问这样的问题，因为我从来不觉得自己是个很卓越的前端工程师。甚至我入行头几年时并不认为自己可以做好这一行。我只确定自己比自己想象中还才疏学浅，而且大家面试我的时候都不知道从何问起\r\n\r\n话虽这么说，我到现在做得还算不错，而且成为了团队中有价值的一员。但我最终离开 (去寻求新的挑战——即我还不能够胜任的工作) 的时候，我经常会被要求招聘我的继任者。现在回看这些面试，我不禁感叹当我刚开始的时候自己在这方面的知识是多么的匮乏。我现在或许不会按照我自己的模型进行招聘，即便我个人的这种经历也有可能成功。\r\n\r\n我在 web 领域工作越长时间，我就越意识到区分人才和顶尖人才的并不是他们的知识——而是他们思考问题的方式。很显然，知识在很多情况下是非常重要而且关键的——但是在一个快速发展的领域，你前进和获取知识的方式 (至少在相当长的一段时间里) 会比你已经掌握的知识显得更加重要。更重要的是：你是如何运用这些知识解决每天的问题的。\r\n\r\n这里有许许多多的文章谈论你工作中需要的语言、框架、工具等等。我希望给一些不一样的建议。在这篇文章里，我想谈一谈一个前端工程师的心态，希望可以帮助大家找到通往卓越的道路。\r\n\r\n<!--more-->\r\n\r\n### 别光解决问题，想想究竟发生了什么\r\n\r\n很多人埋头写 CSS 和 JavaScript 直到程序工作起来了，然后就去做别的事情了。我通过 code review 发现这种事经常发生。\r\n\r\n我总会问大家：“为什么你会在这里添加 `float: left`？”或者“这里的 `overflow: hidden` 是必要的吗？”，他们往往答道：“我也不知道，可是我一删掉它们，页面就乱套了。”\r\n\r\nJavaScript 也是一样，我总会在一个条件竞争的地方看到一个 `setTimeout`，或者有些人无意中阻止了事件传播，却不知道它会[影响](http://css-tricks.com/dangers-stopping-event-propagation/)到页面中其它的事件处理。\r\n\r\n我发现很多情况下，当你遇到问题的时候，你只是解决当下的问题罢了。但是如果你永远不花时间理解问题的本源，你将一次又一次的面对相同的问题。\r\n\r\n花一些时间找出为什么，这看上去费时费力，但是我保证它会节省你未来的时间。在完全理解整个系统之后，你就不需要总去猜测和论证了。\r\n\r\n### 学会预见未来的浏览器发展趋势\r\n\r\n前后端开发的一个主要区别在于后端代码通常都运行在完全由你掌控的环境下。前端相对来说不那么在你的掌控之中。不同用户的平台或设备是前端永恒的话题，你的代码需要优雅掌控这一切。\r\n\r\n我记得自己 2011 年之前曾经阅读某主流 JavaScript 框架的时候看到过下面这样的代码 (简化过的)：\r\n\r\n    var isIE6 = !isIE7 && !isIE8 && !isIE9;\r\n\r\n在这个例子中变量 IE6 为了判断 IE 浏览器版本是否是 6 或更低的版本。那么在 IE10 发布时，我们的程序判断还是会出问题。\r\n\r\n我理解在真实世界特性检测并不 100% 工作，而且有的时候你不得不依赖有 bug 的特性或根据浏览器特性检测的错误设计白名单。但你为此做的每一件事都非常关键，因为你预见到了不再有 bug 的未来。\r\n\r\n对于我们当中的很多人来说，我们今天写的代码都会比我们的工作周期要长。有些我写的代码已经过去 8 年多了还在产品线上运行。这让人很满足又很不安。\r\n\r\n### 阅读规范文档\r\n\r\n浏览器有 bug 是很难免的事，但是当同一份代码在两个浏览器渲染出来的效果不一样，人们总会不假思索的推测，那个“广受好评”的浏览器是对的，而“不起眼”的浏览器是错的。但事实并不一定如此，当你的假设出现错误时，你选取的变通办法都会在未来遭遇问题。\r\n\r\n一个就近的例子是 flex 元素的默认最小尺寸问题。根据[规范](http://www.w3.org/TR/css-flexbox/#min-size-auto)的描述，flex 元素初始化的 `min-width` 和 `min-height` 的值是 `auto` (而不是 0)，也就是说它们默认应该收缩到自己内容的最小尺寸。但是在过去长达 8 个月的时间里，只有 Firefox 的实现是准确的。[1]\r\n\r\n如果你遇到了这个浏览器兼容性的问题并且发现 Chrome、IE、Opera、Safari 的效果相同而 Firefox 和它们不同时，你很可能会认为是 Firefox 搞错了。事实上这种情况我见多了。很多我在自己 [Flexbugs](https://github.com/philipwalton/flexbugs) 项目上报的问题都是这样的。而且这些解决方案的问题会在两周之后 Chrome 44 修复之后被体现出来。和遵循标准的解决方案相比，这些方案都伤害到了正确的规范行为。[2]\r\n\r\n当同一份代码在两个或更多浏览器的渲染结果不同时，你应该花些时间确定哪个效果是正确的，并且以此为标准写代码。你的解决方案应该是对未来友好的。\r\n\r\n额外的，所谓“卓越”的前端工程师是时刻感受变化，在某项技术成为主流之前就去适应它的，甚至在为这样的技术做着贡献。如果你锻炼自己看到规范就能在浏览器支持它之前想象出它如何工作的，那么你将成为谈论并影响其规范开发的那群人。\r\n\r\n### 阅读别人的代码\r\n\r\n出于乐趣阅读别人的代码可能并不是你每周六晚上会想到的娱乐项目，但是这毫无疑问是你成为优秀工程师的最佳途径。\r\n\r\n自己独立解决问题绝对是个不错的方式，但是这不应该是你唯一的方式，因为它很快就会让你稳定在某个层次。阅读别人的代码会让你开阔思维，并且阅读和理解别人写的代码也是团队协作或开源贡献必须具备的能力。\r\n\r\n我着实认为很多公司在招聘新员工的时候犯的最大错误是他们只评估应聘者从轮廓开始写新代码的能力。我几乎没有见过一场面试会要求应聘者阅读现有的代码，找出其中的问题，并修复它们。缺少这样的面试流程真的非常不好，因为你作为工程师的很多时间都花费在了在现有的代码的基础上增加或改变上面，而不是搭建新的东西。\r\n\r\n### 与比你聪明的人一起工作\r\n\r\n我印象中的很多前端开发者 (相比于全职工作来说) 都是自由职业者，有同类想法的后端开发者并没有那么多。可能是因为很多前端都是自学成才的而后端则多是学校里学出来的。\r\n\r\n不论是自我学习还是自我工作，我们都面对一个问题：你并没有机会从比你聪明的家伙那里学到什么。没有人帮你 review 代码，也没有人与你碰撞灵感。\r\n\r\n我强烈建议，最起码在你职业发展的前期，你要在一个团队里工作，尤其是一个普遍比你聪明而且有经验的团队里工作。\r\n\r\n如果你最终会在你职业发展的某个阶段选择独立工作，一定要让自己投身在开源社区当中。保持对开源项目的活跃贡献，这会给你团队工作相同甚至更多的益处。\r\n\r\n### “造轮子”\r\n\r\n造轮子在商业上是非常糟糕的，但是从学习的角度是非常好的。你可能很想把那些库和小工具直接从 npm 里拿下来用，但也可以想象一下你独立建造它们能够学到多少东西。\r\n\r\n我知道有些人读到这里是特别不赞成的。别误会，我并没有说你不应该使用第三方代码。那些经过充分测试的库具有多年的测试用例积累和已知问题积累，使用它们绝对是非常明智的选择。\r\n\r\n但在这里我想说的是如何从优秀到卓越。我觉得这个领域很多卓越的人都是我每天在用的非常流行的库的作者或维护者。\r\n\r\n你可能不曾打造过自己的 JavaScript 库也拥有一个成功的职业发展，但是你从不把自己手弄脏是几乎不可能淘到金子的。\r\n\r\n在这一行大家普遍会问的一个问题是：我接下来应该做点什么？如果你没有试着学一个新的工具创建一个新的应用，那不妨试着重新造一个你喜欢的 JavaScript 库或 CSS 框架。这样做的一个好消息是，在你遇到困难的时候，所有现成的库的源代码都会为你提供帮助。\r\n\r\n### 把你学到的东西都记录下来\r\n\r\n最后，但丝毫不逊色的是，你应该把你学到的东西记录下来。这样做有很多原因，但也许最重要的原因是它强迫你更好的理解这件事。如果你无法讲清楚它的工作原理，在整个过程中它会推动你自己把并不真正理解的东西弄清楚。很多情况下你根本意识不到自己还不理解它们——直到自己动手写的时候。\r\n\r\n根据我的经验，写作、演讲、做 demo 是强迫自己完全深入理解一件事的最佳方式。就算你写的东西没有人看，整个过程也会让你受益匪浅。\r\n\r\n#### Footnotes:\r\n\r\n1. Firefox implemented the spec change in [version 34](https://en.wikipedia.org/wiki/Firefox_release_history) on December 1, 2014. Chrome implemented it in [version 44](https://en.wikipedia.org/wiki/Google_Chrome_release_history) on July 21, 2015, which means Opera will get it shortly. Edge shipped with this implemented on July 29, 2015. A Safari implementation appears to be [in progress](https://bugs.webkit.org/show_bug.cgi?id=136754).\r\n2. You can refer to [Flexbug #1](https://github.com/philipwalton/flexbugs#1-minimum-content-sizing-of-flex-items-not-honored) for a future-friendly, cross-browser workaround to this issue."},"217":{"title":"Vue.js 1.0.0 发布了！","slug":"vuejs-1-0-0-release","created":1446118604,"modified":1501527787,"text":"作为“打入敌人内部”的第一件事，转载一下 Vue.js 1.0.0 新世纪福音战士 (其实发这篇文章的时候已经 1.0.3 了) 正式发布的[\b博文](http://vuejs.org/2015/10/26/1.0.0-release/) ^_^\r\n\r\n![Vue.js](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2015/10/2139857295.png)\r\n\r\n----\r\n\r\n> Hi HN (Hacker News)! 如果你还不熟悉 Vue.js 的话，可以通过[这篇文章 (英文)](http://blog.evanyou.me/2015/10/25/vuejs-re-introduction/)对其有个总体印象。\r\n\r\n在经历了 300+ 次提交、8 次 alpha、4 次 beta 和 2 次 rc 之后，今天我很荣幸的向大家宣布 [Vue.js 1.0.0 Evangelion](https://github.com/vuejs/vue/releases/tag/1.0.0) 正式发布了！非常感谢所有参与 API 重设计的同学们——没有来自社区的贡献这是不可能完成的。\r\n\r\n<!--more-->\r\n\r\n### 模板语法改进\r\n\r\n1.0 的模板语法解决了很多微小的一致性问题，并使得 Vue 的模板更加简洁且易于阅读。最值得留意的新特性就是 `v-on` 和 `v-bind` 的语法简写：\r\n\r\n    <!-- 简写版 v-bind:href -->\r\n    <a :href=\"someURL\"></a>\r\n    \r\n    <!-- 简写版 v-on:click -->\r\n    <button @click=\"onClick\"></button>\r\n\r\n当使用一个子组件的时候，`v-on` 用来监听自定义事件，`v-bind` 用来绑定属性 (props)。这些简写让子组件变得更易用：\r\n\r\n    <item-list\r\n      :items=\"items\"\r\n      @ready=\"onItemsReady\"\r\n      @update=\"onItemsUpdate\">\r\n    </item-list>\r\n\r\n### API 清理\r\n\r\nVue.js 1.0 的总体目标是使其适用于更大型的项目。这也是很多 API 被弃用的原因。在被弃用的 API 中，除了很少被用及之外，最常见的理由就是它会导致可维护性被破坏。特别是，我们弃用了难以维护的功能，并把组件提炼隔离开，使其不会对项目其它部分产生影响。\r\n\r\n比如，在 0.12 中默认资源 (asset) 方案会隐性降级到组件树中的父级。这使得组件中的可用资源非常不确定，并且取决于在运行时的用法。在 1.0 中，所有的资源都基于严格模式进行解析，也没有了隐性降级。`inherit` 选项也被移除了，因为它很容易导致组件强耦合，无法提炼。\r\n\r\n### 更快的初始化渲染\r\n\r\n1.0 用 `v-for` 指令 (directive) 取代了 `v-repeat`。除了提供相同的功能和更直观的作用域之外，`v-for` 将初始化渲染大列表和大表格时的性能提升了 **100%**！\r\n\r\n### 更强大的工具\r\n\r\n在 Vue.js core 之外，还有很多令人激动的东西：[vue-loader](https://github.com/vuejs/vue-loader) 和 [vueify](https://github.com/vuejs/vueify) 的新升级，包括：\r\n\r\n- 组件热加载。当一个 `*.vue` 组件被编辑之后，其所有活跃实例都可以在页面不刷新的情况下完成热转换。这意味着你不需要重新加载 app 就可以完成诸如样式或模板的小调整；而 app 本身及其被转换的组件的状态可以被保留，这大大提升了开发体验。\r\n\r\n- 局部 CSS。通过在你的 `*.vue` 组件的 style 标签上简单加入一个 `scoped` 特性，该组件的模板和最终生成的 CSS 就会被奇妙的重写以保证组件的样式只被应用在其自身的元素上。最重要的是，父组件的特殊样式**不会**泄露到嵌套的子组件当中。\r\n\r\n- 默认支持 ES2015。JavaScript 一直在进化。你可以用最新的语法写出更简洁生动的代码。`vue-loader` 和 `vueify` 现在会直接转换你的 `*.vue` 组件中的 JavaScript，无需额外的设置。今天，就来写未来的 JavaScript 吧！\r\n\r\n结合 [vue-router](https://github.com/vuejs/vue-router)，Vue.js 现在不只是一个库了——它提供了一个构建复杂单页应用的稳固基础。\r\n\r\n### 下一步？\r\n\r\n如一般 1.0.0 所提倡的，核心 API 将会保持稳定服务于可预见的未来，库也做好了产品级别的准备。未来的开发会专注于：\r\n\r\n1. 改善 `vue-loader` 并使其做好产品级别的准备。\r\n\r\n2. 捋顺开发体验，比如更好的开发者工具和 Vue.js 项目/组件脚手架的 CLI。\r\n\r\n3. 提供更多诸如教程和示例的学习资料。"},"219":{"title":"务实的小而美","slug":"small-and-beautiful","created":1452016112,"modified":1452043490,"text":"随意分享几则自己近期的感悟\r\n\r\n### 人不够？\r\n\r\n我自己发现周围的同学越来越把一句话挂在嘴边，那就是：我们就这么些人，想搞定这件事情是远远不够的\r\n\r\n说白了，大家觉得“人多好办事”，“规模”这个词很多情况下几乎就是个褒义词。\r\n\r\n但是今天有些变化正在悄然发生，比如人类的学习能力越来越强，同时信息技术越来越发达，学习新知识的门槛越来越低，比如各技术领域的成熟度越来越高，比如移动时代前所未有的技术挑战，在有限的硬件性能和网络带宽的情况下，越是“规模”的东西越难以维持；比如体力和知识都逐渐远离核心竞争优势等等\r\n\r\n### 拥抱社区，“我们有更多人”\r\n\r\n一件事搞得起来搞不起来，逐渐不取决于我们的团队有多少人，而取决于我们有没有让这件事情发生在最广阔的舞台上，因为一个技术团队再多人，哪怕一百多人，相比起任何一个知名技术社区都是九牛一毛，而一个集团、一个国家、一门语言的社区，相比起全球的互联网社区，也都是渺小的。所以今天，我们想在技术上成就一件事，未必需要很大的团队，未必需要很多人在身边\r\n\r\n同时，我们也不能小看个体在科技发展中所起到的关键作用。技术的不断融合和碰撞也加速了这件事情。所以更重要的不是团队有多少人，而是团队有没有能够真正起到关键作用的个体，找到对的人，比组建一支上百人的团队要重要得多\r\n\r\n### 从社区汲取最好的技术\r\n\r\n我敢说，抛开具有真正技术驱动力的公司，绝大多数公司的技术工作都能够在社区找到现成并且适合的方案，也都不太需要最高精简的科研探索。一个务实的技术方案，一定是在大量的社区成熟技术基础上建立起来的，再加上一点点针对自身业务独特性的技术实践。不过看上去“没什么自己的东西”罢了，如果大家很介意这东西“得是我自己的”，那么你需要继续考虑这个问题：自己搞出来的东西能不能比今天社区的更好，能不能发展成更好的社区，是否可以在社区中的深度参与从而把“别人的”变成“自己的”\r\n\r\n### 在社区中施展+检验自己的技术\r\n\r\n然而社区不应该只有索取，还应该有奉献，如果你发现有件事情是别人也会再次遇到的那种事情，但社区没有合适现成的东西，那么恭喜你，赶紧开工吧\r\n\r\n有的时候觉得社区化的技术发展也有它残酷的一面，同类的方案或工具库基本上也就全球数一数二的几个能生存下来，并且体现出可观的价值，稍微差一点的，也许绝对实力没有差很多，但只要不是第一，所产生的价值和影响力就少得可怜了。所以想掂量掂量自己，看看是不是这块料，不妨放到社区里跟大家一起来一场真正的PK吧！也别自己憋着，别觉得“等我弄得再完善一点再给你们看”，因为在社区化的技术发展中，这样做只会让自己越来越没有价值和勇气把它拿出来了。当然也不必贪多，哪怕是一个小小的功能，如果做到最好，能够被全球的开发者使用，那也是极好的\r\n\r\n### 合理的把技术运用在工作中\r\n\r\n我们在工作中逐渐对人的评价，会由评价其绝对的技术实力，转向评价其运用各方面技术解决实际问题的能力。这两者之间有一个比较形象的比喻，就好比我们学生时期背单词，拿出任何一个单词来，都能立刻说出它的含义、发音、常用短语、同义词、反义词、各种形态，但面对具体的对话场景不知道该用哪个词最合适最得体，这是比较典型的一种现象。其实前者就像是一个人的技术实力，后者就像是一个人的解决实际问题的能力。所以新知识新技术不光要学，还要学以致用，如何合理运用技术解决实际问题才是我们真正希望看到的。\r\n\r\n### 把工作中的必经之路和常见任务萃取出来沉淀为最佳实践\r\n\r\n现在回到“小而美的务实方案”这件事情上。我们认为看上去很重要、工作量很大、需要很多人来做的工作，是可以充分拥抱社区，汲取最好的技术，同时发挥关键角色的关键作用，并把技术合理运用在实际需求上。整件事情的成败有很多因素，但是“规模”这个因素显然不在考前的位置了\r\n\r\n基于这样的思考，我觉得，自己喜欢的团队，是一个小而美的团队\r\n"},"220":{"title":"Vue 2.0 发布啦！","slug":"announcing-vue-2","created":1461716342,"modified":1501527771,"text":"原文：[https://medium.com/the-vue-point/announcing-vue-js-2-0-8af1bde7ab9#.cyoou0ivk](https://medium.com/the-vue-point/announcing-vue-js-2-0-8af1bde7ab9#.cyoou0ivk)\r\n\r\n![](http://ww1.sinaimg.cn/mw1024/660d0cdfgw1f3bs1115fsj20ug0jiq6m.jpg)\r\n\r\n今天我们非常激动的首发 Vue 2.0 preview 版本，这个版本带来了很多激动人心的改进和新特性。我们来看看这里面都有些什么！\r\n\r\n<!--more-->\r\n\r\n### 更轻，更快\r\n\r\nVue.js 始终聚焦在轻量和快速上面，而 2.0 把它做得更好。现在的渲染层基于一个轻量级的 virtual-DOM 实现，在大多数场景下初试化渲染速度和内存消耗都提升了 2~4 倍 (详见这里的 [benchmarks](https://github.com/vuejs/vue/tree/next/benchmarks))。从模板到 virtuel-DOM 的编译器和运行时是可以独立开来的，所以你可以将模板预编译并只通过 Vue 的运行时让你的应用工作起来，而这份运行时的代码 min+gzip 之后只有不到 12kb (提一下，React 15 在 min+gzip 之后的大小是 44kb)。编译器同样可以在浏览器中工作，也就是说你也可以写一段 script 标签然后开始你的工作，就像以前一样。而即便你把编译器加进去，build 出来的文件 min+gzip 之后也仅有 17kb，仍然小于目前的 1.0 版本。\r\n\r\n### 不是普通的 Virtual-DOM\r\n\r\n现在 virtual-DOM 有点让人听腻了，因为社区里有太多种实现，但是 Vue 2.0 的实现有与众不同的地方。和 Vue 的响应式系统结合在一起之后，它可以让你不必做任何事就获得完全优化的重渲染。由于每个组件都会在渲染时追踪其响应依赖，所以系统精确地知道应该何时重渲染、应该重渲染哪些组件。不需要 `shouldComponentUpdate`，也不需要 immutable 数据 - **it just works**.\r\n\r\n除此之外，Vue 2.0 从模板到 virtuel-DOM 的编译阶段使用了一些高阶优化：\r\n\r\n1. 它会检测出静态的 class 名和 attributes 这样它们在初始化渲染之后就永远都不会再被比对。\r\n\r\n2. 它会检测出最大静态子树 (就是不需要动态性的子树) 并且从渲染函数中萃取出来。这样在每次重渲染的时候，它就会直接重用完全相同的 virtual nodes 同时跳过比对。\r\n\r\n这些高阶优化通常只会在使用 JSX 时通过 Babel plugin 来做，但是 Vue 2.0 即使在使用浏览器内的编译器时也能做到。\r\n\r\n新的渲染系统同时允许你通过简单的冻结数据来禁用响应式转换，配以手动的强制更新，这意味着你对于重渲染的流程实际上有着完全的控制权。\r\n\r\n以上这些技术组合在一起，确保了 Vue 2.0 在每一个场景下都能够拥有高性能的表现，同时把开发者的负担和成本降到了最低。\r\n\r\n### Templates, JSX, or Hyperscript?\r\n\r\n开发者对于用模板还是 JSX 有很多的争执。一方面，模板更接近 HTML - 它能更好地反映你的 app 的语义结构，并且易于思考视觉上的设计、布局和样式。另一方面，模板作为一个 DSL 也有它的局限性 - 相比之下 JSX/hyperscript 的程序本质使得它们具有图灵完备的表达能力。\r\n\r\n作为一个兼顾设计和开发的人，我喜欢用模板来写大部分的界面，但在某些情况下我也希望能拥有 JSX/hyperscript 的灵活性。举例来说，当你想在一个组件中程序化的处理其子元素时，基于模板的 slot 机制会显得比较有局限性。\r\n\r\n那么，为什么不能同时拥有它们呢？在 Vue 2.0 中，你可以继续使用熟悉的模板语法，但当你觉得受限制的时候，你也可以直接写底层的 virtual-DOM 代码，只需用一个 `render` 函数替换掉 `template` 选项。你甚至可以直接在你的模板里使用一个特殊的 `<render>` 标签来嵌入渲染函数！一个框架，两全其美。\r\n\r\n### 流式服务端渲染\r\n\r\n既然迁移到了 virtual-DOM，Vue 2.0 自然支持服务端渲染和客户端的 hydration（直接使用服务端渲染的 DOM 元素）。当前服务端渲染的实现有一个痛点，比如在 React 里，渲染是同步的，所以如果这个 app 比较复杂的话它会阻塞服务器的 event loop。同步的服务端渲染在优化不当的情况下甚至会对客户端获得内容的速度带来负面影响。Vue 2.0 提供了内建的流式服务端渲染 - 在渲染组件时返回一个可读的 stream，然后直接 pipe 到 HTTP response。流式渲染能够确保服务端的响应度，也能让用户更快地获得渲染内容。\r\n\r\n### 解锁更多可能性\r\n\r\n基于新的架构，我们还有更多的可能性有待开发 - 比如在手机端渲染到 native 界面。目前我们正在探索一个 Vue.js 2.0 的端，它会用 [weex](http://alibaba.github.io/weex/)：一个由中国最大科技公司之一的阿里巴巴的工程师们维护的项目，作为一个 native 的渲染层。同时从技术角度 Vue 2.0 运行在 ReactNative 上也是可行的。让我们拭目以待！\r\n\r\n### 兼容性以及接下来的计划\r\n\r\nVue.js 2.0 仍然处在 pre-alpha 阶段，但是你可以来[这里](https://github.com/vuejs/vue/tree/next/) 查看源代码。尽管 2.0 是一个完全重写的项目，但是除了一些有意废弃掉的功能，API 和 1.0 是大部分兼容的。看看 [2.0 中一模一样的官方例子](https://github.com/vuejs/vue/tree/next/examples) - 你会发现几乎没有什么变化！\r\n\r\n对于部分功能的废弃，本质上是为了提供更简洁的 API 从而提高开发者的效率。你可以移步[这里](https://github.com/vuejs/vue/wiki/2.0-features) 查看 1.0 和 2.0 的特性比对。如果你在现有的项目中大量地使用着一些被废弃的特性，这意味着会有一定的迁移成本，不过我们在未来会提供更详实的升级指导。\r\n\r\n现在我们还有很多工作没有完成。一旦我们达到了令人满意的测试覆盖率，我们将会推出 alpha 版本，同时我们希望能在五月底六月初推出 beta 版。除了更多的测试之外，我们也需要更新相关库（如 vue-router, Vuex, vue-loader, vueify...）的支持。目前只有 Vuex 在 2.0 下可以直接使用，但是我们会确保在 2.0 正式发布时所有东西都会顺畅地工作。\r\n\r\n我们不会因此而忘记 1.x 哦！1.1 将会和 2.0 beta 独立发布，提供六个月 critical bug fixes 和九个月安全升级的长效服务 (LTS)。同时 1.1 还会包含可选的废弃特性警告，让你为升级到 2.0 做好充足的准备。尽请期待！\r\n"},"221":{"title":"Code Review for Vue 2.0 Preview","slug":"code-review-for-vue-next","created":1461777363,"modified":1462947469,"text":"是的！[Vue 2.0 发布了！](http://jiongks.name/blog/announcing-vue-2/) 源代码仓库[在此](https://github.com/vuejs/vue/tree/next)\r\n\r\n首先，当我第一次看到 Vue 2.0 的真面目的时候，我的内心是非常激动的\r\n\r\n### Demo\r\n\r\n来个简单的 demo，首先把 `dist/vue.js` 导入到一个空白的网页里，然后写：\r\n\r\n**当然，在大家阅读下面所有的内容之前，先想象一下，这是一个运行时 min+gzip 后只有 12kb 大小的库**\r\n\r\n    <script src=\"./dist/vue.js\"></script>\r\n    \r\n    <div id=\"app\">\r\n      Hello {{who}}\r\n    </div>\r\n    <script>\r\n      new Vue({\r\n        el: '#app',\r\n        data: {who: 'Vue'}\r\n      })\r\n    </script>\r\n\r\n你将看到 \"Hello Vue\"\r\n\r\n然后再看一个神奇的：\r\n\r\n    <script src=\"./dist/vue.js\"></script>\r\n    \r\n    <div id=\"app\"></div>\r\n    <script>\r\n      new Vue({\r\n        el: '#app',\r\n        render: function () {\r\n          with (this) {\r\n            __h__('div',\r\n              {staticAttrs:{\"id\":\"app\"}},\r\n              [(\"\\n  Hello \"+__toString__(who)+\"\\n\")],\r\n              ''\r\n            )\r\n          }\r\n        }\r\n        data: {who: 'Vue'}\r\n      })\r\n    </script>\r\n\r\n这个是 compile 过后的格式，大家会发现首先 `#app` 下不需要写模板了，然后 `<script>` 里多了一个 `render` 字段，Vue 在运行时其实是会把模板内容先转换成渲染方法存入 `render` 字段，然后再执行，如果发现 `render` 已经存在，就跳过模板解析过程直接渲染。所以在 Vue 2.0 中写一段模板和写一个 `render` option 是等价的。为什么要这样设计，稍后会我们会涉及到。\r\n\r\n<!--more-->\r\n\r\n### Code Review\r\n\r\n废话不说，来看[仓库](https://github.com/vuejs/vue/tree/next)\r\n\r\n哎呀好东西太多我都不知道该先讲哪个啦！\r\n\r\n### `package.json` - -\r\n\r\n[https://github.com/vuejs/vue/blob/next/package.json](https://github.com/vuejs/vue/blob/next/package.json)\r\n\r\n先看这里，我个人习惯是拿到仓库之后除了 README (它没写) 就先看这个。和 1.x 相比，开发工具链还是以 rollup + webpack + karma 为主，开发的时候用 webpack 加 watch；打包的时候用 rollup 快速而且可以自动删掉没用到的代码片段；测试的时候用 karma 各种组合，包括 e2e、spec、coverage、sauce等。语法检查用了 eslint 这个似乎没什么争议和悬念。另外我发现了两个新东西：[nightwatch](http://nightwatchjs.org/) 和 [selenium-server](https://www.npmjs.com/package/selenium-server)\r\n\r\n另外你们就选眼睛再迟钝也会看到 ssr 这个词吧！对，就是服务端渲染 Server-Side Rendering！先不急，这个最后说，你们可以先去 high 一会儿\r\n\r\n### `src`\r\n\r\n作为一个见证了一小段 Vue 2.0 成长过程的脑残粉，我得跟大家从时间线的角度介绍一下这个文件夹：\r\n\r\n#### `compiler` + `runtime`\r\n\r\n早些时候 Vue 2.0 的代码还是这样分的，一半运行时，一半(预)编译时，中间会通过一个 JavaScript 的格式严格划清界限，即源代码 template + JavaScript 经过编译之后变成了一段纯 JavaScript 代码，然后这段纯 JavaScript 的代码又可以在运行时被执行渲染。\r\n\r\n这里面奇妙的地方是：编译时的代码完全可以脱离浏览器预执行，也可以在浏览器里执行。所以你可以把代码提前编译好，减轻运行时的负担。\r\n\r\n由于 Vue 2.0 对 template 的解析没有借助 DOM 以及 fragment document，而是在 John Resig 的 [HTML Parser](https://github.com/vuejs/vue/blob/14feb83879fe32fc9c54eddf33c6c5ef2fb4e8a2/src/compiler/parser/html-parser.js) 基础上实现的，所以完全可以在任何主流的 JavaScript 环境中执行，这也为 ssr 提供了必要的基础\r\n\r\nVue 最早会打包生成三个文件，一个是 runtime only 的文件 vue.common.js，一个是 compiler only 的文件 compiler.js，一个是 runtime + compiler 的文件 vue.js，它们有三个打包入口，都放在了 `entries` 目录下，这是 `src` 里的第三个文件夹，第四个文件夹是 `shared`，放置一些运行时和编译时都会用到的工具方法集。\r\n\r\n#### `compiler` + `runtime` + `platforms`\r\n\r\nWahahaha~\r\n\r\n这要说到 Vue 2.0 的第二个优点：virtual-DOM！virtual-DOM 有很多优点，也被很多人热议，而 Vue 2.0 里面的 virtual-DOM 简直是把它做到了极致！代码非常简练，而且性能超高 (据说秒杀 React，我自己没试过，大家可以自己比比看)。在这一点上编译器的前置起到了非常重要的作用，而且很多 diff 算法的优化点而且是在运行时之前就准备好的。\r\n\r\n另外 virtual-DOM 的另一个优点当然就是可以对渲染引擎做一般化的抽象，进而适配到更多类型的终端渲染引擎上！所以在我的怂恿下，小右把本来在 `runtime` 下的 `runtime/dom` 文件夹挪到了一个名叫 `platforms` 的新文件夹下，改名叫 `platforms/web/runtime`，把本来 `compiler` 文件夹下 web 相关的 `modules` 挪到了 `platforms/web/compiler`！\r\n\r\n(是的没错，今天在 [Weex](http://alibaba.github.io/weex/) 的子仓库里已经有另外一个 `platforms/weex` 文件夹了耶)\r\n\r\n#### `compiler` + `runtime` + `platforms` + `server`\r\n\r\n是的没有错！Vue 2.0 既然已经有了 virtual-DOM，也有了运行环境无关的 compiler，为什么不能 ssr 呢？！Vue 2.0 不只是简单的把预渲染拿到服务端这么简单，Vue 2.0 ssr 除了提供传统的由源文件编译出字符串之外，还提供了输出 stream 的功能，这样服务端的渲染不会因为大量的同步字符串处理而变慢。即：`createRenderer()` 会返回 `renderToString()` 和 `renderToStream()` 两个方法。同时，在 `platforms/web` 文件夹下除了 `runtime` 和 `compiler` 之外又多了一个 `server` 目录，这样编译器、服务端流式预渲染、运行时的铁三角架构就这样达成了！\r\n\r\n### `test`\r\n\r\n说到测试，我惊奇的发现，在带来了这么多颠覆性的改变之后，Vue 2.0 竟然完好保留了绝大多数 1.0 的 API 设计，而且更快更小巧延展性更强。Vue 2.0 在前期研发阶段主要是通过粗线条的 e2e 测试进行质量保障的，因为版本延续性做得非常好，所以这部分在 1.x 的积累已经帮上很大忙了。现在 Vue 2.0 逐渐的在从 feature 的角度在进一步覆盖测试用例，对每个 API 和每个流程进行测试。目前以我个人的感觉主要的常见的链路都已经比较畅通了，具体功能细节上偶尔还是会遇到 bug 待修复，不过作为一个新兴的 Vue 2.0 来说，相信这已经远远超过大家的预期了！\r\n\r\n### 其它\r\n\r\n我觉得 Vue 2.0 在编译器和运行时的解耦上做得超级棒！中间格式设计得也非常巧妙，把静态的部分在编译时就分析出来，而且通过非常简单的 `__h__`, `__renderList__` 等方法就搞定了几乎所有的逻辑控制和数据绑定。之前我个人在实践 Weex 的时候也是会把 template 提前 compile，但只是 compile 成一段 JSON，逻辑分析还是在运行时做的，当时和小右交流的时候就在讨论，能不能把分析过程也前置，无奈自己功力不够啊，一直没搞出来。看到 2.0 横空出世，简直是泪流满面有木有！！\r\n\r\n还有一件事情也是之前跟小右聊到过，就是目前 Vue 提供的很多 directive 包括 filter 也都是有机会前置处理的，所以在 Vue 2.0 里，有相当一部分 directive 是前置处理成一般格式的，运行时只是针对各端的渲染机制保留了 attr, style, class, event 等几个最基础简单的解析过程，比如 if, for, else 都直接在 compile 的时候被解开了。而且 Vue 2.0 把这部分内容抽象得如此清晰，除了赞叹还是赞叹！！\r\n\r\n还有就是，你们去看看 Vue 2.0 的提交记录，300+ 次提交，上万行高效优质的代码，总共花了差不多两周的时间，而且提交时间几乎遍布二十四个小时……\r\n\r\n别的不多啰嗦了，我觉得大家还是亲自看过 Vue 2.0 的源码，会对这些内容有更深刻的了解。从今天起，fork + clone Vue 2.0，写写 demo、写写测试、练练英文 XD go!\r\n"},"223":{"title":"通过一张图走进 Vue 2.0","slug":"a-big-map-to-intro-vue-next","created":1463057259,"modified":1463057259,"text":"这可能是字最少的一篇了，都在图里 - -\r\n\r\n文字介绍稍后抽空再补补\r\n\r\n[![](http://ww2.sinaimg.cn/large/660d0cdfgw1f3sv9xpn3vj21221yrdp8.jpg)](http://ww2.sinaimg.cn/large/660d0cdfgw1f3sv9xpn3vj21221yrdp8.jpg)\r\n"},"224":{"title":"【整理】Vue 2.0 自 beta 1 到 beta 4 以来的主要更新","slug":"vue-2-from-beta-1-to-beta-4","created":1469698385,"modified":1501527700,"text":"主要内容来自 [https://github.com/vuejs/vue/releases](https://github.com/vuejs/vue/releases)\r\n\r\n之前 [Vue 2.0 发布技术预览版](http://jiongks.name/blog/announcing-vue-2/) 到现在差不多三个月了，之前写过一篇简单的 [code review](http://jiongks.name/blog/code-review-for-vue-next/)，如今三个月过去了，Vue 2.0 在这个[基础](http://jiongks.name/blog/a-big-map-to-intro-vue-next/)之上又带来了不少更新，这里汇总 beta 以来 (最新的版本是 beta 4) 的主要更新，大家随意学习感受一下\r\n\r\n### alpha 和 beta 版本的侧重点会有所不同\r\n\r\n首先 Vue 2.0 对 alpha、beta 有自己的理解和设定：alpha 版本旨在完善 API、考虑所需的特性；而来到 beta 版则会对未来的正式发布进行充分的“消化”，比如提前进行一些必要的 breaking change，增强框架的稳定性、完善文档和周边工具 (如 vue-router 2.0 等)\r\n\r\n### 最后的几个 alpha 版本主要更新\r\n\r\nVue 本身的语法基础这里就不多赘述了，网上有很多资料可以查阅，我们已经假定你比较熟悉 Vue 并对 2.0 的理念和技术预览版的状态有一定的了解。\r\n\r\n<!--more-->\r\n\r\n#### alpha 5\r\n\r\n1. ref 的写法由 `<comp v-ref:foo>` 变成了 `<comp ref=\"foo\">`，更加简单，同时动态数据的写法是 `<comp :ref=\"x\">`\r\n2. 支持 functional components，这个特性蛮酷的，可以把一个组件的生成过程完全变成一个高度自定义的函数执行过程，比如：\r\n\r\n    Vue.component('name', {\r\n        functional: true,\r\n        props: ['x'],\r\n        render: (h, props, children) {\r\n            return h(props.tag, null, children)\r\n        }\r\n    })\r\n\r\n你可以在 `render()` 函数里写各种特殊的逻辑，这样标签的含义和能力都得到了非常大的扩展，在后续的几次更新中，你马上会感受到一些 functional components 的威力\r\n\r\n另外剧透一下，`h` 方法里的第二个参数如果是 `null` 就可以省略，这个改动出现在了 beta 1\r\n\r\n#### alpha 6\r\n\r\n可以设置特殊的 keyCode，比如 `Vue.config.keyCodes.a = 65`，然后你就可以写 `<input @keyup.a=\"aPressed\">` 了\r\n\r\n#### alpha7\r\n\r\n1. 一个组件的生命周期名由 `init` 改成了 `beforeCreated` (大家可以在 Vuex 的源码里看到对应的改变哦)\r\n2. `Vue.transition` 的 hook 支持第二个参数，把 vm 传递进去\r\n\r\n如：\r\n\r\n    Vue.transition('name', {\r\n        onEnter (el, vm) {\r\n            ...\r\n        }\r\n    })\r\n\r\n### Beta 1 ~ Beta 4\r\n\r\n#### beta 1\r\n\r\n1. 自定义 directive 里 `update` 的触发时机发生了变化，由于 functional component 等概念的引入，一个 directive 的变更的颗粒度也不完全是 directive 本身引起的，所以这里做了一个更具有通用性的调整；同时 hook 名 `postupdate` 也相应的更名为 `componentUpdated`——如果你想让 `update` 保持原有的触发时机，可以加入一句 `binding.value !== binding.oldValue` 即可。\r\n2. `Vue.traisition` 的 hook 名做了简化\r\n    * `onEnter` -> `enter`\r\n    * `onLeave` -> `leave`\r\n3. server-side rendering\r\n    * `server.getCacheKey` 更名为 `serverCacheKey`，避免多一层结构嵌套\r\n    * `createRenderer`/`createBundleRenderer` 方法不会强制应用 `lru-cache`，而是开发者手动选择\r\n\r\n#### beta 2\r\n\r\n`<transition>` 标签来了！\r\n\r\n其实这个玩意儿我之前在 polymer 等其他框架里也见到过，不过看到 Vue 的语法设计，还是觉得巧妙而简洁：\r\n\r\n\r\n    <transition>\r\n        <div v-if=\"...\">...</div>\r\n    </traisition>\r\n\r\n    <transition-group tag=\"ul\">\r\n        <li v-for=\"...\">...</li>\r\n    </traisition-group>\r\n\r\n更牛掰的在这里，还记得 functional components 吧，你今天可以这样抽象一个动画效果的标签：\r\n\r\n    Vue.component('fade', {\r\n        functional: true,\r\n        render (h, children) {\r\n            return h('transition', {\r\n                props: {...},\r\n                on: {\r\n                    beforeEnter,\r\n                    afterEnter\r\n                }\r\n            }, children)\r\n        }\r\n    })\r\n\r\n然后\r\n\r\n    <fade>...</fade>\r\n\r\n就可以实现高度自定义的动画效果了，这个我个人觉得是非常赞的设计和实现！\r\n\r\n#### beta 3\r\n\r\n1. 支持在自定义组件中使用原生事件。因为在 Vue 2.0 的设计中，自定义组件上是不能绑定原生事件的，自定义组件上的事件绑定被默认理解为组件的自定义事件，而不是原生事件。针对这个问题我很早就提了 [issue](https://github.com/vuejs/vue/issues/2942) 当时小右提出了一个新的语法设计，就是 `<comp @click.native=\"...\"></comp>`，beta 3 的时候终于看到它被实现了，嘿嘿，有点小激动\r\n2. 支持两种语法 `<div :xxx.prop=\"x\">` 和 `<div v-bind:prop=\"{ xxx: x }\">` 来对 DOM 的 property 进行绑定，最近我自己也在思考一些在 virtual-DOM 上支持 properties 而不只是 attributes 的想法，这个设计让我也多了一些新的思路。\r\n\r\n#### beta 4\r\n\r\n2 天前发布的，其实这个版本以 bugfix 为主\r\n\r\n### 总结\r\n\r\n以上是近期 Vue 2.0 的一些更新，让我自己比较兴奋的主要是 functional component 以及基于这个设计的 `<transition>` 和 `<transition-group>` 标签和自定义 transition 标签的能力拓展，还有就是久违的 `<comp @click.native=\"...\"></comp>`\r\n\r\n最后希望大家可以多多试用，有更大兴趣的可以多多学习 Vue 的源码！"},"225":{"title":"Vue 2.0 来了！","slug":"vue-2-is-here","created":1475253909,"modified":1501527644,"text":"终于发布了！\r\n\r\n原文：[https://medium.com/the-vue-point/vue-2-0-is-here-ef1f26acf4b8#.6r9xjmu6x](https://medium.com/the-vue-point/vue-2-0-is-here-ef1f26acf4b8#.6r9xjmu6x)\r\n\r\n今天我非常兴奋的官宣 Vue.js 2.0 的发布：Ghost in the Shell。历经 8 个 alpha 版本、8 个 beta 版本和 8 个 rc 版本 (矮油好巧！)，Vue.js 2.0 已经为生产环境准备好了！我们的官方教程 [vuejs.org/guide](http://vuejs.org/guide/) 也已经全面更新。\r\n\r\n2.0 的工作自今年 4 月启动以来，[核心团队](https://github.com/orgs/vuejs/people)为 API 设计、bugfix、文档、类型声明做出了很重要的贡献，社区中的同学们也反馈了很多有价值的 API 建议——在此为每一位参与者致以大大的感谢！\r\n\r\n<!--more-->\r\n\r\n### 2.0 有哪些新东西\r\n\r\n#### 性能\r\n\r\n![基于第三方 benchmark，数值越低越好](https://d262ilb51hltx0.cloudfront.net/max/1600/1*Lu6OJiraJYShl4aBppoh3w.png)\r\n\r\n基于[第三方 benchmark](http://stefankrause.net/js-frameworks-benchmark4/webdriver-ts/table.html)，数值越低越好\r\n\r\n2.0 用一个 fork 自 [snabbdom](https://github.com/snabbdom/snabbdom) 的轻量 Virtual DOM 实现对渲染层进行了重写。在其上层，Vue 的模板编译器能够在编译时做一些智能的优化处理，例如分析并提炼出静态子树以避免界面重绘时不必要的比对。新的渲染层较之 v1 带来了巨大的性能提升，也让 Vue 2.0 成为了最快速的框架之一。除此之外，它把你在优化方面需要做的努力降到了最低，因为 Vue 的响应系统能够在巨大而且复杂的组件树中精准的判断其中需要被重绘的那部分。\r\n\r\n![](https://d262ilb51hltx0.cloudfront.net/max/1600/1*xV2_bx4eWC9RXiBZjeAMrw.png)\r\n\r\n还有个值得一提的地方，就是 2.0 的 runtime-only 包大小 min+gzip 过后只有 16kb，即便把 *vue-router* 和 *vuex* 都包含进去也只有 26kb，和 v1 核心的包大小相当！\r\n\r\n#### 渲染函数\r\n\r\n尽管渲染层全面更新，Vue 2.0 兼容了绝大部分的 1.0 模板语法，仅废弃掉了其中的一小部分。这些模板在背后被编译成了 Virtual DOM 渲染函数，但是如果用户需要更复杂的 JavaScript，也可以选择在其中直接撰写渲染函数。同时我们为喜欢 JSX 的同学提供了[支持选项](https://github.com/vuejs/babel-plugin-transform-vue-jsx)\r\n\r\n渲染函数使得这种基于组件的开发模式变得异常强大，并打开了各种可能性——比如现在新的 transition 系统就是完全基于组件的，内部由渲染函数实现。\r\n\r\n#### 服务端渲染\r\n\r\nVue 2.0 支持服务端渲染 (SSR)，并且是[流式的](https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer#rendererrendertostreamvm)，可以做[组件级的缓存](https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer#component-caching)，这使得极速渲染成为可能。同时，*vue-router* 和 *vuex* 2.0 也都支持了可以通用路由和客户端状态“hydration”的服务端渲染。你可以通过 [vue-hackernews-2.0 的 demo app](https://github.com/vuejs/vue-hackernews-2.0/) 了解到它们是如何协同工作的。\r\n\r\n### 辅助库\r\n\r\n官方支持的库和工具——*vue-router*、*vuex*、*vue-loader* 和 *vueify*——都已经升级并支持 2.0 了。**vue-cli 现在已经默认生成 2.0 的脚手架了。**\r\n\r\n特别之处在于，*vue-router* 和 *vuex* 在它们的 2.0 版本中都已经有了很多改进：\r\n\r\n**vue-router**\r\n\r\n* 支持多命名的 `<router-view>`\r\n* 通过 `<router-link>` 组件改进了导航功能\r\n* 简化了导航的 hooks API\r\n* 可定制的滚动行为控制\r\n* [更多复杂示例](https://github.com/vuejs/vue-router/tree/dev/examples)\r\n\r\n**vuex**\r\n\r\n* 简化了组件内的用法\r\n* 通过改进 modules API 提供更好的代码组织方式\r\n* 可聚合的异步 actions\r\n\r\n它们各自的 2.0 文档里有更多的细节：\r\n\r\n* [http://router.vuejs.org/](http://router.vuejs.org/)\r\n* [http://vuex.vuejs.org/](http://vuex.vuejs.org/)\r\n\r\n#### 社区项目\r\n\r\n中国最大的在线订餐平台饿了么的[团队](https://github.com/ElemeFE/)已经基于 Vue 2.0 构建了[一套完整的桌面 UI 组件库](https://github.com/ElemeFE/element)。不过还没有英文文档，但是他们正在为此而努力！\r\n\r\n很多其他社区的项目也都在为 2.0 做兼容——请移步到 [awesome-vue](https://github.com/vuejs/awesome-vue) 搜索关键字“2.0”。\r\n\r\n### 从 1.0 迁移\r\n\r\n如果你是一个 Vue 的新同学，现在就可以“无脑”使用 Vue 2.0 了。最大的问题其实是目前 1.0 的用户如何迁移到新的版本。\r\n\r\n![](https://d262ilb51hltx0.cloudfront.net/max/1600/1*157Ly5X6gx0C2CIvsMaNog.png)\r\n\r\n为了帮助大家完成迁移，团队已经在配合 [CLI 迁移辅助工具](https://github.com/vuejs/vue-migration-helper)制作[非常详实的迁移教程](http://vuejs.org/guide/migration.html)。这个工具不一定捕获每一处被废弃的东西，但相信能帮你开个好头。\r\n\r\n### One More Thing……\r\n\r\n中国最大的电商公司阿里巴巴的工程师们已经发起了一个叫做 [Weex](https://github.com/alibaba/weex) 的项目，通过 Vue-inspired 语法在移动端渲染 native UI 组件。但是很快，“Vue-inspired” 将会成为 “Vue-powered”——我们已经启动了官方合作，让 Vue 2.0 真正成为 Weex 的 JavaScript 运行时框架。这让用户能够撰写横跨 Web、iOS 和 Android 的通用 Vue 组件！我们的合作才刚刚开始，这将会是 2.0 发布后未来我们专注的重点，请大家拭目以待！\r\n\r\nVue 从一个不起眼的 side project 开始如今已经有了长足的发展。今天它已经是[社区资助的](https://www.patreon.com/evanyou)，[被实际广泛认可的](https://www.quora.com/How-popular-is-VueJS-in-the-industry/answer/Evan-You-3?__snid3__=365957938&__nsrc__=2&__filter__)，并且根据 [stats.js.org](http://stats.js.org/) 统计在所有 JavaScript 库中增势最强劲的一个。我们相信 2.0 会走得更远。这是 Vue 自启动以来最大的一次更新，我们期待大家用 Vue 创造出更多好产品！\r\n"},"226":{"title":"C 程序的原则","slug":"principles-for-c-programming","created":1489913287,"modified":1489914431,"text":"按照 Doug Gwyn 的话说：“Unix 不会阻止你做愚蠢的事情，因为那会同样阻止你做聪明的事情”。C 是一个非常强大的工具，但使用它的时候需要非常小心和[自律][discipline]。学习这些纪律是绝对值得的，因为 C 是所有程序语言中最优秀的。一个自律的 C 程序员将会……\r\n\r\n**喜欢可维护性**。不要在不必要的地方自作聪明。取而代之的是，找出最简单最易懂的满足需求的方案。诸如性能之类考量是放在第二位的。你应该为你的代码做一个性能预算，并自在的支配它。\r\n\r\n随着你对这门语言越来越[了解][proficient]，掌握了越来越多能够从中获益的特性，你也应该学会什么时候不能使用它们。相比用到了很多新奇的方式去解决问题，易于[新手][novice]理解是更重要的。最好是让一个新手理解你的代码并从中有所收获。像你[大概][circa]去年就在维护它一样去撰写代码。\r\n\r\n**避免使用魔法**。不要使用宏 (macros)——尽管用它定义常量是没问题的。不要使用 typedef 来隐藏指针或回避撰写“结构”。避免撰写复杂的抽象。保持你的构建系统简单透明。不要因为一个愚蠢的 hacky 的[废物][crap]解决问题的方式酷炫就使用它。你的代码在行为[之下][underlying]应该是明显的，甚至不需要上下文。\r\n\r\nC 最大的优势之一就是透明和简单。这应该被信奉，而不是被[颠覆][subverted]。但是 C 的优良传统是给你足够的空间施展自己，所以你可以为了一些魔术般的目的使用它。但最好还是不要这样，做个[麻瓜][muggle]挺好的。\r\n\r\n**辨识并回避危险的模式**。不要使用固定尺寸的 buffers (有人指出这种说法并不是完全正确。我之前打草稿的时候提到了这些，但还是删掉了)——始终计算你需要分配的空间。阅读你使用的函数的 man 手册并掌握他的成功有出错模式。立刻把不安全的用户输入转换为[干净][sanitized]的 C 结构。如果你之后会把这些数据展现给用户，那么尽可能把 C 结构保持到最后。要学会在使用例如 strcat 的敏感函数时多加留意。\r\n\r\n撰写 C 有的时候像握着一把枪。枪是很重要的工具，但是和枪有关的事故都是非常糟糕的。你对待枪要非常小心：不要用枪指着任何你喜爱的东西，要有好的用枪[纪律][discipline]，把它当作始终上膛一样谨慎。而就像枪善于拿来打孔一样，C 也善于用来撰写内核。\r\n\r\n**用心组织代码。**永远不要把代码写到 header 里。永远不要使用 `inline` 关键字。把独立的东西分开写成不同的文件。[大量][liberally]使用静态方法组织你的逻辑。用一套编码规范让一切都有足够的[空间][breathing-room]且易于阅读。当目的[显而易见][self-evident]的情况下使用单字符变量名，反之则使用[描述性][descriptive]的变量名。\r\n\r\n我喜欢把我的代码组织成目录，每个目录实现一组函数，每个函数有属于自己的文件。这些文件通常会包含很多静态函数，但是它们全部用于组织这个文件所要实现的行为。写一个 header 允许这个模块被外部访问。并使用 Linux 内核编码规范，[该死][god-dammit]。\r\n\r\n**只使用标准的特性**。不要把平台假设为 Linux。不要把编译器假设为 gcc。不要把 libc 假设为 glibc。不要把架构假设为 x86 的。不要把核心工具假设为 GNU。不要定义 `_GNU_SOURCE`。\r\n\r\n如果你一定要使用平台相关的特性，为这样的特性描述一个接口，然后撰写各自平台相关的支持代码。在任何[情况][circumstances]下都不要使用 gcc 扩展或 glibc 扩展。GNU 是[枯萎的][blight]，不要让它[传染][infect]到你的代码。\r\n\r\n**使用[严谨][disciplined]的工作流**。也要有严谨的版本控制方法。撰写提交记录的时候要[用心][thoughtful]——在第一行简短解释变动，然后在扩展提交记录中加上改变它的[理由][justification]。在 feature 分支上工作要明确定义目标，不要包含和这个目标不相关的改动。不要害怕在 rebase 时编辑你的分支的历史，它会让你的改动展示得更清晰。\r\n\r\n当你稍后不得不回退你的代码时，你将会感激你之前详尽撰写的提交记录。其他人和你的代码互动时也同样会心存感激。当你看到一些愚蠢的代码时，也可以知道这个[白痴][bastard]当时是怎么想的，尤其是当这个[白痴][bastard]是你自己的时候。\r\n\r\n**严格测试和[回顾][review]**。找出你的改动可能会经过的代码路径。测试每条路径的行为是正确的。给它不正确的输入。给它“永远不可能发生”的输入。对[有错误倾向][error-prone]的模式格外小心。寻找可以简化代码的地方并让过程变得更清晰。\r\n\r\n接下来，把你的改动交给另外一个人进行[回顾][review]。这个人应该运用相同的程序并签署你的改动。而且[回顾][review]要[严格][discipline]，标准始终如一。[回顾][review]的时候应该想着，如果由于这些代码出了问题，自己会[感到耻辱][be-your-ass-on-the-line]。\r\n\r\n**从错误中学习**。首先，修复 bug。然后，修复实际的 bug：你的流程允许里这个错误的发生。拉[回顾][reviewer]你代码的人讨论——这是你们共同的过错。严格的检查撰写、[回顾][review]和部署这些代码的流程，找出[根源][root-cause]所在。\r\n\r\n解决方案可以简单，比如把 strcat 加入到你的触发“认真回顾”[条件反射][reflex]的函数列表。它可以通过电脑进行静态分析，帮你检测到这个问题。可能这些代码需要[重构][refactored]，这样找出问题变得简单容易。疏于避免未来的[错误][fuck-up]才是真的[大错][fuck-up]。\r\n\r\n----\r\n\r\n重要的是记住规则就是用来打破的。可能有些情况下，不被鼓励的行为是有用的，被鼓励的行为是应该[被忽视的][disregarded]。你应该[力争][strive]把这些情况当作例外而不是[常态][norm]，并当它们发生时仔细的[证明][justify]它们。\r\n\r\nC 是狗屎。我爱它，并希望更多的人可以学到我做事的方式。祝好运！\r\n\r\n[bastard]: http://dict.cn/bastard\r\n[be-your-ass-on-the-line]: http://dict.cn/be%20your%20ass%20on%20the%20line\r\n[blight]: http://dict.cn/blight\r\n[breathing-room]: http://dict.cn/breathing%20room\r\n[circa]: http://dict.cn/circa\r\n[circumstances]: http://dict.cn/circumstances\r\n[crap]: http://dict.cn/crap\r\n[descriptive]: http://dict.cn/descriptive\r\n[discipline]: http://dict.cn/discipline\r\n[disciplined]: http://dict.cn/discipline\r\n[disregarded]: http://dict.cn/disregarded\r\n[error-prone]: http://dict.cn/error-prone\r\n[fuck-up]: http://dict.cn/fuck-up\r\n[god-dammit]: http://dict.cn/god%20dammit\r\n[infect]: http://dict.cn/infect\r\n[justification]: http://dict.cn/justification\r\n[justify]: http://dict.cn/justify\r\n[liberally]: http://dict.cn/liberally\r\n[muggle]: http://dict.cn/muggle\r\n[norm]: http://dict.cn/norm\r\n[novice]: http://dict.cn/novice\r\n[proficient]: http://dict.cn/proficient\r\n[refactored]: http://dict.cn/refactored\r\n[reflex]: http://dict.cn/reflex\r\n[review]: http://dict.cn/review\r\n[reviewer]: http://dict.cn/review\r\n[root-cause]: http://dict.cn/root%20cause\r\n[sanitized]: http://dict.cn/sanitized\r\n[self-evident]: http://dict.cn/self-evident\r\n[strive]: http://dict.cn/strive\r\n[subverted]: http://dict.cn/subverted\r\n[thoughtful]: http://dict.cn/thoughtful\r\n[underlying]: http://dict.cn/underlying\r\n"},"227":{"title":"如何撰写 Git 提交信息","slug":"git-commit","created":1489994885,"modified":1503042137,"text":"译自：[https://chris.beams.io/posts/git-commit/](https://chris.beams.io/posts/git-commit/)\r\n\r\n----\r\n\r\n![](https://imgs.xkcd.com/comics/git_commit.png)\r\n\r\n### 介绍：为什么好的提交信息非常重要\r\n\r\n如果你浏览任何 Git 仓库的日志，你可能会发现那些提交信息多少有些[混乱][mess]。比如，看看这些我早年提交给 Spring 的[精品](https://github.com/spring-projects/spring-framework/commits/e5f4b49?author=cbeams)：\r\n\r\n    $ git log --oneline -5 --author cbeams --before \"Fri Mar 26 2009\"\r\n    \r\n    e5f4b49 Re-adding ConfigurationPostProcessorTests after its brief removal in r814. @Ignore-ing the testCglibClassesAreLoadedJustInTimeForEnhancement() method as it turns out this was one of the culprits in the recent build breakage. The classloader hacking causes subtle downstream effects, breaking unrelated tests. The test method is still useful, but should only be run on a manual basis to ensure CGLIB is not prematurely classloaded, and should not be run as part of the automated build.\r\n    2db0f12 fixed two build-breaking issues: + reverted ClassMetadataReadingVisitor to revision 794 + eliminated ConfigurationPostProcessorTests until further investigation determines why it causes downstream tests to fail (such as the seemingly unrelated ClassPathXmlApplicationContextTests)\r\n    147709f Tweaks to package-info.java files\r\n    22b25e0 Consolidated Util and MutableAnnotationUtils classes into existing AsmUtils\r\n    7f96f57 polishing\r\n\r\n[呀][Yikes]，比较一下这个仓库[最近的提交](https://github.com/spring-projects/spring-framework/commits/5ba3db?author=philwebb)：\r\n\r\n    $ git log --oneline -5 --author pwebb --before \"Sat Aug 30 2014\"\r\n    \r\n    5ba3db6 Fix failing CompositePropertySourceTests\r\n    84564a0 Rework @PropertySource early parsing logic\r\n    e142fd1 Add tests for ImportSelector meta-data\r\n    887815f Update docbook dependency and generate epub\r\n    ac8326d Polish mockito usage\r\n\r\n你更喜欢读哪个呢？\r\n\r\n<!--more-->\r\n\r\n过去的信息从长度到形式都很多样；最近的信息比较简洁且一致。过去的信息是一般情况下会发生的；最近的信息绝不是[偶然][by-accident]发生。\r\n\r\n虽然很多仓库的日志看起来像是过去的，但也有例外。Linux 内核和 Git 自身就是伟大的例子。再比如 Spring Boot 或其它由 Tim Pope 管理的仓库。\r\n\r\n这些仓库的贡献者知道，对于一个开发同事来说 (其实对未来的[自己][selves]也是一样)，一条用心撰写的 Git 提交信息是用来沟通这则改动最好的上下文。一个 diff 会告诉你*什么*改变了，但是只有提交信息能[正确的][properly]告诉你*为什么*。Peter Hutterer 阐述得非常好：\r\n\r\n> 重建一段代码的上下文是非常费时费力的，这是无法完全避免的。所以我们应该努力尽可能的[减少它](http://www.osnews.com/story/19266/WTFs_m)。提交信息可以帮上这个忙，也正因为此，一个提交信息反应了一名开发者是不是个好的协作者。\r\n\r\n如果你对于创建一个伟大的提交信息还没有想过太多，那说明你可能还没有在 `git log` 及相关的工具上花费太多的时间。这里有一个[恶性][vicious]循环：因为提交历史不成体系且不一致，我们就不会花更多的时间使用和关心它。因为它得不到使用和关注，所以它就一直不成体系且不一致。\r\n\r\n但是用心写出来的日志是美丽且实用的。`git blame`、`revert`、`rebase`、`log`、`shortlog` 以及其它子命令就是生命的一部分。回顾其他人的提交和 pull requests 变成了值得去做的事情，并且可以快速独立完成。理解最近几个月或几年为什么发生了这些事情不止是可能的并且是[高效的][efficient]。\r\n\r\n一个项目的长期成功[靠的是][rests-on]其可维护性，以及一个拥有比项目的日志更强大的工具的维护者。这里值得花时间学习一下如何[正确的][properly]考虑它。一开始可能是个[麻烦][hassle]的东西很快会变成习惯，并且最终变成一切[投入][involved]的自豪和[产能][productivity]的源泉。\r\n\r\n在这篇文章中，我只会[致力于][addressing]保障一个健康的提交历史的最基本要素：如何撰写一份个人提交信息。这里还有其它重要的实践比如[压缩][squashing]提交 (commit squashing) 就不是我在这里想说的。可能会为此[再][subsequent]写一篇吧。\r\n\r\n大多数编程语言都建立了良好的编码规约，以[形成][constitutes][惯用][idiomatic]的风格，比如命名、格式化等。当然在这些编码规约中有一些[差异][variations]，但是大多数开发者赞同取其一并养成习惯好过每个人都选择自己的风格而[发生][ensues]混乱。\r\n\r\n一个团队的提交日志方法应该是一致的。为了建立一个有用的[修订][revision]历史，团队应该首先约定一个提交信息的规约，该规约至少定义以下三方面：\r\n\r\n**样式。**标记[句法][syntax]、缠绕边距、[语法][grammar]、[大小写][capitalization]、[标点符号][punctuation]。把这些东西都找出来，去除猜测，把规则定的尽量简单可行。最终的产出将会是[不同寻常的][remarkably]一致的日志，不只是乐于阅读，实际上也让阅读变成了一种[习惯][on-a-regular-basis]。\r\n\r\n**内容。**提交信息的正文 (body) (如有) 应该包含什么样的信息？不应该包含什么？\r\n\r\n**元数据。**Issue 追踪 ID、pull request 号等信息如何放进来？\r\n\r\n幸运的是，这里有一些已经被良好建立的规约，用来创建[惯用的][idiomatic] Git 提交信息。[事实上][indeed]，有些规约中很多都是以某种 Git 命令的方式工作的。不需要你重新发明任何东西。只需遵循下面七大法则，你就可以像专家一样进行提交：\r\n\r\n### 伟大的 Git 提交信息七大法则\r\n\r\n> 注意：[这些](http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html) [法则](http://www.git-scm.com/book/en/Distributed-Git-Contributing-to-a-Project#Commit-Guidelines) [之前](https://github.com/torvalds/subsurface/blob/master/README#L82-109) [在别的地方](http://who-t.blogspot.co.at/2009/12/on-commit-messages.html) [也](https://github.com/erlang/otp/wiki/writing-good-commit-messages) [提到过](https://github.com/spring-projects/spring-framework/blob/30bce7/CONTRIBUTING.md#format-commit-messages)。\r\n\r\n1. 用一个空行把主题和主题隔离开\r\n2. 把主题行限制在 50 个字符以内\r\n3. 主题行大写开头\r\n4. 主题行不必以句号结尾\r\n5. 在主题行中使用[祈使句][imperative]\r\n6. 正文在 72 个字符处折行\r\n7. 使用正文解释*是什么*和*为什么*而不是*怎么样*\r\n\r\n比如：\r\n\r\n    Summarize changes in around 50 characters or less\r\n    \r\n    More detailed explanatory text, if necessary. Wrap it to about 72\r\n    characters or so. In some contexts, the first line is treated as the\r\n    subject of the commit and the rest of the text as the body. The\r\n    blank line separating the summary from the body is critical (unless\r\n    you omit the body entirely); various tools like `log`, `shortlog`\r\n    and `rebase` can get confused if you run the two together.\r\n    \r\n    Explain the problem that this commit is solving. Focus on why you\r\n    are making this change as opposed to how (the code explains that).\r\n    Are there side effects or other unintuitive consequences of this\r\n    change? Here's the place to explain them.\r\n    \r\n    Further paragraphs come after blank lines.\r\n    \r\n     - Bullet points are okay, too\r\n    \r\n     - Typically a hyphen or asterisk is used for the bullet, preceded\r\n       by a single space, with blank lines in between, but conventions\r\n       vary here\r\n    \r\n    If you use an issue tracker, put references to them at the bottom,\r\n    like this:\r\n    \r\n    Resolves: #123\r\n    See also: #456, #789\r\n\r\n#### 1. 用一个空行把主题和正文隔离开\r\n\r\n在 `git commit` 的 manpage 手册中写到：\r\n\r\n> 虽然不是必须的，但是你最好以一句少于 50 个字符的话简短概括你的改动，然后空一行，再深入描述。提交信息中空行之上的文本会被当作提交的标题，该标题在 Git 中到处都会用到。比如 Git-format-patch(1) 会把一个提交转换为一封电子邮件，它会把这个标题作为邮件的主题，其余的部分会作为邮件的正文。\r\n\r\n首先，不是每一次提交都同时需要一个主题和一段正文。有的时候单独一行就可以了，尤其是当改动很简单没有更多必要的上下文的时候。比如：\r\n\r\n    Fix typo in introduction to user guide\r\n\r\n无需说更多；如果读者好奇到底修复了什么 typo，她可以通过诸如 `git show` 或 `git diff` 或 `git log -p` 简单看看改动的内容就可以了。\r\n\r\n如果你是在命令行中提交，则很容易使用 `git commit` 的 `-m` 选项：\r\n\r\n    $ git commit -m\"Fix typo in introduction to user guide\"\r\n\r\n然而，当一个提交[值得][merits]一些解释和上下文的时候，你需要撰写正文。比如：\r\n\r\n\r\n    Derezz the master control program\r\n    \r\n    MCP turned out to be evil and had become intent on world domination.\r\n    This commit throws Tron's disc into MCP (causing its deresolution)\r\n    and turns it back into a chess game.\r\n\r\n带正文的提交信息并不便于通过 `-m` 选项来撰写。你最好找一个合适的文本编辑器撰写信息。如果你并没有在命令行中为 Git 设置过编辑器，那么请移步阅读 [Pro Git 的这个章节](https://git-scm.com/book/en/v2/Customizing-Git-Git-Configuration)。\r\n\r\n当你在任何情况下浏览日志的时候，都会觉得把主题从正文中分离出来是[值得的][pays-off]。这里有一整段日志：\r\n\r\n    $ git log\r\n    commit 42e769bdf4894310333942ffc5a15151222a87be\r\n    Author: Kevin Flynn <kevin@flynnsarcade.com>\r\n    Date:   Fri Jan 01 00:00:00 1982 -0200\r\n    \r\n     Derezz the master control program\r\n    \r\n     MCP turned out to be evil and had become intent on world domination.\r\n     This commit throws Tron's disc into MCP (causing its deresolution)\r\n     and turns it back into a chess game.\r\n\r\n现在运行 `git log --oneline`，这个命令只会打印主题行：\r\n\r\n    $ git log --oneline\r\n    42e769 Derezz the master control program\r\n\r\n或者，`git shortlog`，这个命令会把提交按照用户分组，同样出于[简洁][concision]的考虑只会打印主题行：\r\n\r\n    $ git shortlog\r\n    Kevin Flynn (1):\r\n          Derezz the master control program\r\n    \r\n    Alan Bradley (1):\r\n          Introduce security program \"Tron\"\r\n    \r\n    Ed Dillinger (3):\r\n          Rename chess program to \"MCP\"\r\n          Modify chess program\r\n          Upgrade chess program\r\n    \r\n    Walter Gibbs (1):\r\n          Introduce protoype chess program\r\n\r\n在 Git 里还有一些其它的情况下，会[区分][distinction]主题行和正文——但是如果没有它们中间的空行的话是不会[正常][properly]工作的。\r\n\r\n#### 2. 把主题行限制在 50 个字符以内\r\n\r\n50 个字符并不是一个严格的限制，只是个[经验之谈][rule-of-thumb]。保持主题行的长度以确保它可读且促使作者考虑一下最[简略][concise]的表达方式足矣。\r\n\r\n> 提示：如果你做总结很艰难，你可能是一次性提交太多东西了。把原子提交从中剥离出来吧 (每个主题是一个独立的提交)。\r\n\r\nGitHub 的 UI 都会提醒这些规约。如果你输入超过 50 个字符的限制，它会警告：\r\n\r\n![gh1](https://i.imgur.com/zyBU2l6.png)\r\n\r\n而且会主题行超过 75 个字符的部分会被截断，留下一个省略号：\r\n\r\n![gh2](https://i.imgur.com/27n9O8y.png)\r\n\r\n所以奔着 50 个字符去写，但是 72 个字符是底线。\r\n\r\n#### 3. 主题行大写开头\r\n\r\n如题。比如：\r\n\r\n* Accelerate to 88 miles per hour\r\n\r\n而不是：\r\n\r\n* accelerate to 88 miles per hour\r\n\r\n#### 4. 主题行不必以句号结尾\r\n\r\n主题行结尾的标点[符号用法][punctuation]不是必要的。而且，当你打算控制在 50 个字符以内时，连空格都是[很宝贵的][precious]。比如：\r\n\r\n* Open the pod bay doors\r\n\r\n而不是：\r\n\r\n* Open the pod bay doors.\r\n\r\n#### 5. 在主题行中使用[祈使句][imperative]\r\n\r\n*[祈使句][imperative]*就是指“说起来或写起来像是在发号施令”。举几个例子：\r\n\r\n* Clean your room\r\n* Close the door\r\n* Take out the trash\r\n\r\n其实这七大法则的每一条读起来都是[祈使句][imperative]的 (“正文在 72 个字符处折行”等)。\r\n\r\n[祈使句][imperative]听起来有一点粗鲁；这也是我们为什么不常用它的原因。但是这非常适合写在 Git 提交的主题行中。其中一个的原因就是 **Git 本身就是根据你的意志[命令式][imperative]的创建一个提交的**。\r\n\r\n例如，使用 `git merge` 的默认信息读起来是这样的：\r\n\r\n    Merge branch 'myfeature'\r\n\r\n而用 `git revert` 的时候是：\r\n\r\n    Revert \"Add the thing with the stuff\"\r\n    \r\n    This reverts commit cc87791524aedd593cff5a74532befe7ab69ce9d.\r\n\r\n再或者在一个 GitHub pull request 上点击“Merge”按钮时：\r\n\r\n    Merge pull request #123 from someuser/somebranch\r\n\r\n所以当你以[祈使句][imperative]撰写你的提交信息时，你遵循了 Git 自己内建的规约。比如：\r\n\r\n* Refactor subsystem X for readability\r\n* Update getting started documentation\r\n* Remove deprecated methods\r\n* Release version 1.0.0\r\n\r\n这样撰写一开始会觉得有点[怪怪的][awkward]。我们更多的在说话的时候使用[陈述句][indicative]来陈述事实。这是为什么提交信息经常读起来像：\r\n\r\n* Fixed bug with Y\r\n* Changing behavior of X\r\n\r\n有的时候提交信息写起来像是对于其内容的描述：\r\n\r\n* More fixes for broken stuff\r\n* Sweet new API methods\r\n\r\n为了避免混淆，这里有一个简单原则，可以用在每一个地方。\r\n\r\n**一个 Git 提交的主题行的准确的格式应该始终完全遵循下面的句式：**\r\n\r\n* If applied, this commit will *这里是你的主题行*\r\n\r\n比如：\r\n\r\n* If applied, this commit will *refactor subsystem X for readability*\r\n* If applied, this commit will *update getting started documentation*\r\n* If applied, this commit will *remove deprecated methods*\r\n* If applied, this commit will *release version 1.0.0*\r\n* If applied, this commit will *merge pull request #123 from user/branch*\r\n\r\n注意[非祈使句][non-imperative]在这里别扭的地方：\r\n\r\n* If applied, this commit will *fixed bug with Y*\r\n* If applied, this commit will *changing behavior of X*\r\n* If applied, this commit will *more fixes for broken stuff*\r\n* If applied, this commit will *sweet new API methods*\r\n\r\n> 注意：使用祈使句只在主题行中至关重要。当你撰写正文的时候就可以放下这些限制了。\r\n\r\n#### 6. 正文在 72 个字符处折行\r\n\r\nGit 不会自动给文本折行。当你为一个提交撰写消息正文的时候，你必须意识到它正确的边距，并且手动折行。\r\n\r\n这里推荐在 72 个字符处折行，这样 Git 有足够的空间，即便缩进文本也可以保证所有东西在 80 个字符以内。\r\n\r\n一个好的文本编辑器是可以帮上忙的。比如在 Vim 中配置在 Git 提交的 72 个字符处折行非常容易。然而传统的 IDE 在给提交信息文本折行方面提供的智能支持[很糟糕][terrible] (尽管 IntelliJ IDEA 在最近的版本中终于在这方面做得好一些了)。\r\n\r\n#### 7. 使用正文解释是什么和为什么而不是怎么样\r\n\r\n这个[来自比特币核心的提交](https://github.com/bitcoin/bitcoin/commit/eb0b56b19017ab5c16c745e6da39c53126924ed6)是一个非常好的解释改动是什么和为什么的例子：\r\n\r\n    commit eb0b56b19017ab5c16c745e6da39c53126924ed6\r\n    Author: Pieter Wuille <pieter.wuille@gmail.com>\r\n    Date:   Fri Aug 1 22:57:55 2014 +0200\r\n    \r\n       Simplify serialize.h's exception handling\r\n    \r\n       Remove the 'state' and 'exceptmask' from serialize.h's stream\r\n       implementations, as well as related methods.\r\n    \r\n       As exceptmask always included 'failbit', and setstate was always\r\n       called with bits = failbit, all it did was immediately raise an\r\n       exception. Get rid of those variables, and replace the setstate\r\n       with direct exception throwing (which also removes some dead\r\n       code).\r\n    \r\n       As a result, good() is never reached after a failure (there are\r\n       only 2 calls, one of which is in tests), and can just be replaced\r\n       by !eof().\r\n    \r\n       fail(), clear(n) and exceptions() are just never called. Delete\r\n       them.\r\n\r\n看一眼[完整的 diff](https://github.com/bitcoin/bitcoin/commit/eb0b56b19017ab5c16c745e6da39c53126924ed6)，想一下作者此时此刻通过提供这样的上下文为同事以及未来的提交者节省了多少时间。如果他不这样做，这些信息可能永远找不回来了。\r\n\r\n在很多情况下，你可以[忽略][leave-out]这个改动发生时的各种细节。从这个角度看，代码自己会说话 (如果代码很复杂以至于需要长篇大论的解释，那也是代码注释该做的事情)。请首先专注于弄清你产生这个改动的理由——改动前的工作方式，改动后的工作方式 (以及这样做哪里不对)，以及为什么你决定以这样的方式解决问题。\r\n\r\n你将来某一天维护它的时候也许会感激今天的你！\r\n\r\n### 提示\r\n\r\n#### 学着爱上命令行。远离 IDE。\r\n\r\n[和 Git 子命令同样多的原因][For-as-many-reasons-at-there-are-Git-subcommands]，拥抱命令行是[明智][wise]的。Git 是[超级][insanely]强大的；IDE 也一样，但是套路不同。我每天都使用 IDE (IntelliJ IDEA) 也用过[很多][extensively]其它的 (Eclipse)，但是我从未见到 IDE 对 Git 的集成能够配得上命令行的易用和强大 (一旦你意识到这一点)。\r\n\r\n某些 Git 相关的 IDE 功能是[非常宝贵的][invaluable]，比如当你删除一个文件时调用 `git rm`、当你重命名一个文件时完成相应的 `git` 命令。但是当你尝试提交、合并、rebase、或通过 IDE 做[复杂的][sophisticated]历史分析时，事情就[分崩离析][falls-apart]了。\r\n\r\n当你想[发挥出][wielding] Git 全部的能量的时候，命令行始终是不二之选。\r\n\r\n记住不论你是用的是 Bash 还是 Z shell，都有 [tab 补全脚本](http://git-scm.com/book/en/Git-Basics-Tips-and-Tricks)减轻忘记子命令和开关的痛苦。\r\n\r\n#### 阅读 Pro Git\r\n\r\n[Pro Git](http://git-scm.com/book) 这本书已经可以免费在线阅读，这本书非常棒。[用好它吧][take-advantage]！\r\n\r\n[mess]: http://dict.cn/mess\r\n[Yikes]: http://dict.cn/Yikes\r\n[by-accident]: http://dict.cn/by%20accident\r\n[selves]: http://dict.cn/selves\r\n[properly]: http://dict.cn/properly\r\n[vicious]: http://dict.cn/vicious\r\n[efficient]: http://dict.cn/efficient\r\n[rests-on]: http://dict.cn/rest%20on\r\n[hassle]: http://dict.cn/hassle\r\n[involved]: http://dict.cn/involved\r\n[productivity]: http://dict.cn/productivity\r\n[addressing]: http://dict.cn/addressing\r\n[squashing]: http://dict.cn/squashing\r\n[subsequent]: http://dict.cn/subsequent\r\n[constitutes]: http://dict.cn/constitutes\r\n[idiomatic]: http://dict.cn/idiomatic\r\n[variations]: http://dict.cn/variations\r\n[ensues]: http://dict.cn/ensues\r\n[revision]: http://dict.cn/revision\r\n[syntax]: http://dict.cn/syntax\r\n[grammar]: http://dict.cn/grammar\r\n[capitalization]: http://dict.cn/capitalization\r\n[punctuation]: http://dict.cn/punctuation\r\n[remarkably]: http://dict.cn/remarkably\r\n[on-a-regular-basis]: http://dict.cn/on%20a%20regular%20basis\r\n[idiomatic]: http://dict.cn/idiomatic\r\n[indeed]: http://dict.cn/indeed\r\n[imperative]: http://dict.cn/imperative\r\n[merits]: http://dict.cn/merits\r\n[pays-off]: http://dict.cn/pay%20off\r\n[concision]: http://dict.cn/concision\r\n[distinction]: http://dict.cn/distinction\r\n[properly]: http://dict.cn/properly\r\n[rule-of-thumb]: http://dict.cn/rule%20of%20thumb\r\n[concise]: http://dict.cn/concise\r\n[punctuation]: http://dict.cn/punctuation\r\n[precious]: http://dict.cn/precious\r\n[imperative]: http://dict.cn/imperative\r\n[awkward]: http://dict.cn/awkward\r\n[indicative]: http://dict.cn/indicative\r\n[non-imperative]: http://dict.cn/imperative\r\n[terrible]: http://dict.cn/terrible\r\n[leave-out]: http://dict.cn/leave%20out\r\n[wise]: http://dict.cn/wise\r\n[insanely]: http://dict.cn/insanely\r\n[extensively]: http://dict.cn/extensively\r\n[invaluable]: http://dict.cn/invaluable\r\n[sophisticated]: http://dict.cn/sophisticated\r\n[falls-apart]: http://dict.cn/fall%20apart\r\n[wielding]: http://dict.cn/wielding\r\n[take-advantage]: http://dict.cn/take%20advantage\r\n[For-as-many-reasons-as-there-are-Git-subcommands]: https://translate.google.com/#en/zh-CN/For%20as%20many%20reasons%20as%20there%20are%20Git%20subcommands\r\n"},"228":{"title":"如果管理是唯一可走的路，那就完蛋了","slug":"if-management-is-the-only-way-up-we-are-all-fd","created":1490632458,"modified":1501527516,"text":"译自：[https://moz.com/rand/if-management-is-the-only-way-up-were-all-fd/](https://moz.com/rand/if-management-is-the-only-way-up-were-all-fd/)\r\n\r\n注：作者 Rand 是 Moz 的 CEO，文中反复出现两个词：IC (Individual Contributor) 和 PW (People Wrangler)，分别翻译成了一线员工和经理人。\r\n\r\n----\r\n\r\n[Geraldine](http://everywhereist.com/) 很喜欢她曾经在 Cranium 的工作 (西雅图的[桌游][board game]初创公司，在 Hasbro 收购他们并[裁员][layoffs][之前][prior])。她为桌游撰写问题，并为包装盒和营销材料撰写[文案][copy]。她很擅长这个。但是发生了一些奇怪的事情——他们想让她晋升。我记得她晚上回家后[非常的][endlessly][苦恼][fretting]。她不想让人们向她汇报。她不想在团队中拥有更大的责任。她只想写写东西。\r\n\r\n这很奇怪。当我们审视一家公司的结构时，很容易发现团队需要很多高质量的一线员工 (IC) 以及少数高质量的[经理人][wranglers]。然而我们的[公司][corporate]文化和这个世界的“模式”已经让我觉得除非你要带人，否则你的影响力、薪水、利益、职位和自我价值都不会增长。\r\n\r\n[这都什么乱七八糟的。][im calling bs]\r\n\r\n我过去写过关于多样化成长轨迹的重要性——[一线员工和经理人](https://moz.com/rand/whats-the-right-team-structure/)——但是我们最近在 Moz 花了大量的时间碰撞想法，很快会实施一个新的职位/团队的结构，最终付诸实践，我对此充满期待。\r\n\r\n现在我会为一个在其工作岗位上做的很优秀的一线员工表达对管理的兴趣而担心。我担心这种渴望的很[重要的][significant][一部分][portion]不源自真正的管理责任感，而是因为他们想要在职业生涯和/或影响力上得到提高，并且认为这是唯一的办法。\r\n\r\n我画了这张图来辅助[说明][illustrate]两种角色之间的不同：\r\n\r\n![ics-vs-pws-small](https://moz.com/rand/wp-content/uploads/2013/04/ics-vs-pws-small.gif)  \r\n([大图](https://moz.com/rand/wp-content/uploads/2013/04/ics-vs-pws-large.gif))\r\n\r\n<!--more-->\r\n\r\n一线员工为他们自己及其工作负责。因为他们以一线员工的方式取得了长足的发展，所以他们的影响力变得更加广泛。一个在 Moz 的好的例子就是 [Dr. Pete](http://www.seomoz.org/users/profile/22897)，他[判断][recognizes]公司的战略[指示][imperatives]并随之[协力投入][pitches in]。他通过审查来协助大数据操作，通过[战术][tactical]指导和策略输入来辅助市场，发表如此高质量的[博客](http://www.seomoz.org/blog/are-exact-match-domains-in-decline)和[指南](http://www.seomoz.org/google-algorithm-change)，甚至[从头开始][from the ground up]设计[整个项目](http://mozcast.com/)并基于他们的创意执行。他的影响遍及整个公司，横跨多个团队，和他们一同成长。他通过自己的影响力定义了这个角色，这比其它方式都好。\r\n\r\n[另一方面][on the flip side]，优秀的经理人有义务让他们的团队开心、[团结][cohesion]、[自主][empowerment]，也要负责审查、指导等等。他们发展的越顺利，就越不需要“待在[壕沟][trenches]里”了。很多情况下，他们只会协助定义战略问题。剩下的定义范围、搜索相关答案、实现和执行统统都交给一线员工来做。一个在 Moz 的好的例子就是 [Samantha Britney](http://www.seomoz.org/team/samantha)。她长期是一个一线员工，但现如今已经成为了经理人，帮助产品团队的几个一线员工，给予他们工作的自主性，通过工具、资源和协助把事做好，并提供作为一个经理人必要的辅导、一对一、回顾和 HR 工作。她的报告中从不会提及任何细枝末节，但总会驱动他们的项目向前。\r\n\r\n基本上，如果你喜欢并且能够把这件事做好，那么你应该做一个一线员工。如果你喜欢 (且擅长) 把自主权交给其他人，帮助他们成长和成功，那么你应该做一个经理人。\r\n\r\n这些一线员工和经理人之间有这样一些[差别][nuance]：\r\n\r\n* 随着一线员工们的发展，他们希望和经理人的职责范围有更多的重叠。对经理人来说恰恰相反——随着他们的发展，他们实际干的活越来越少。\r\n* 资深的一线员工的角色更加灵活——他们能够在各种地方工作，并且由于工作得到[认可][recognition]，收到的会议和活动邀约就越来越多。资深的经理人相反——他们在办公室的时间更为[关键][critical]，所以很少出差，也经常[身居幕后][behind-the-scenes] ([很明显][notable] CEO 在这方面是一个例外)。\r\n* 如果你有很多一线员工却只有很少的经理人，那么你会发现汇报和管理很有挑战。但是如果你有一堆经理人而没几个一线员工，你会[面临][horrifying]“厨师太多伙计不够了”的问题 (并且这通常意味着你们的组织和文化已经一团糟了)。\r\n* 优秀的一线员工有时会发展成为经理人，并因此在新的角色上变得[平庸][mediocre]或失败。这绝对是个悲剧。公司不仅失去了一个卓越的一线员工，而且连管理也被搞砸了，因为这会造成大量[传染式][viral]的问题。[而][on the flip side]如果一个一线员工[表现平平][underperforming]，问题往往不至于这么严重。\r\n* [待遇][compensation]是个技巧活儿。在我理想的世界里 (对了我们在 Moz 创建的工资范围是跨发展路线的)，一线员工和经理人的级别是[大致][roughly][等价的][equivalent]。假设在某一条路线上有 7 个级别，那么 level 3 的一线员工可以做 level 3 的经理人的事情。最高级别的一线员工应该能够和 CXO 挣得一样多。\r\n\r\n我和他人分享这些观点时，大部分情况是[直观的][intuitive]。我遇到过的最大问题和一个简单的概念有关——战略战术的所有权。有一天一个 Mozzer 同事和我在这方面的看法就不一致。他觉得在 Moz 的历史上，有些团队的经理人掌握着战略和战术的所有权。个人开发者没有定义他们做什么，怎么做，如何衡量，也没有定义执行过程，他们只是接受命令。\r\n\r\n是的这样做也行得通并且这种情况确实发生过。但是我不同意我的同事，这样做相比于，把更大的所有权交给一线员工，让他们决定做什么、何时何地、如何做，让经理人指决定谁来做已经为什么要做，效果不可能一样。[诚然][Granted]，很多初级经理人和一线员工之间会具有更大的内容重叠，而很多高级个人开发者会决定谁来做和为什么要做 (如上所述)。但是我强烈的相信，从长期来看，我们应该走这条路。人们的快乐便在此之上。\r\n\r\n当 Daniel Pink 问道[“是什么让我们的工作快乐？”](http://www.danpink.com/drive-the-summaries)时，答案已经很明显 (并且被很多其他学者和不太正式调查者证实)：\r\n\r\n1. 自治——主导我们自己生活的渴望。\r\n2. 精通——在关键的事情上越做越好的欲望。\r\n3. 目的——渴望做好比我们自己更重要的事情\r\n\r\n如果个人开发者无法控制自己的工作内容并且能够掌握工作技能，他们中间优秀的人就会离开，去那些提供这种机会的公司。我们将只留下经理人，而且这会很快。\r\n\r\n很奇怪，我是那种一线员工风格的 CEO (也许这并不都是奇怪)。我是一个高级别的一线员工，所以我和经理人有很大的职责重叠，但是我会服务所有的团队、工作和细节。我可能是最直接参与到产品和市场的人，我也经常让这些团队 Mozzer 们像对待资源和工具一样对待我。你让我写篇博客我就会去写，你让我答复一个客户我就会冲上去，你需要聊聊一个项目如何匹配更广泛的目标，以及如何改变你的做法，那就一起聊聊呗。我喜欢我汇报给这些 Moz 员工的感觉——而不是其它方式。我想这件事情永远也不会改变。\r\n\r\np.s. 我很喜欢 [Phil Scarr 的这篇文章](http://themassesareangry.blogspot.com/2011/05/on-virtues-of-being-individual.html)，它描述了自己从经理人转变为一线员工的经历以及为什么。[Carin](http://www.seomoz.org/team/carin) 从带领着我们的大数据团队，转变为一个产品团队的资深一线员工，我为之感到骄傲。\r\n\r\np.p.s. 如果我的思路不对 (或者对) 而你也有相关的经验，不妨也留言给我。我一定虚心学习——因为我一直在提醒自己，我是第一次当 CEO \r\n\r\n[board game]: http://dict.cn/board%20game\r\n[layoffs]: http://dict.cn/layoffs\r\n[prior]: http://dict.cn/prior\r\n[copy]: http://dict.cn/copy\r\n[endlessly]: http://dict.cn/endlessly\r\n[fretting]: http://dict.cn/fretting\r\n[wranglers]: http://dict.cn/wrangler\r\n[corporate]: http://dict.cn/corporate\r\n[im calling bs]: http://www.urbandictionary.com/define.php?term=I%20call%20bullshit\r\n[significant]: http://dict.cn/significant\r\n[portion]: http://dict.cn/portion\r\n[illustrate]: http://dict.cn/illustrate\r\n[recognizes]: http://dict.cn/recognize\r\n[imperatives]: http://dict.cn/imperative\r\n[pitches in]: http://dict.cn/pitch%20in\r\n[tactical]: http://dict.cn/tactical\r\n[from the ground up]: http://dict.cn/from%20the%20ground%20up\r\n[on the flip side]: https://translate.google.com/#en/zh-CN/on%20the%20flip%20side\r\n[cohesion]: http://dict.cn/cohesion\r\n[empowerment]: http://dict.cn/empowerment\r\n[trenches]: http://dict.cn/trench\r\n[nuance]: http://dict.cn/nuance\r\n[recognition]: http://dict.cn/recognition\r\n[critical]: http://dict.cn/critical\r\n[behind-the-scenes]: http://dict.cn/behind-the-scenes\r\n[notable]: http://dict.cn/notable\r\n[horrifying]: http://dict.cn/horrify\r\n[mediocre]: http://dict.cn/mediocre\r\n[viral]: http://dict.cn/viral\r\n[underperforming]: http://dict.cn/underperforming\r\n[compensation]: http://dict.cn/compensation\r\n[roughly]: http://dict.cn/roughly\r\n[equivalent]: http://dict.cn/equivalent\r\n[intuitive]: http://dict.cn/intuitive\r\n[Granted]: http://dict.cn/Granted"},"229":{"title":"寄语应届生：走出校园的几个人生转变","slug":"for-after-college","created":1490858664,"modified":1490859627,"text":"最近收到个邀请，[有机会和大学生的在线互动交流](http://weibo.com/2724465062/ECaVuAyZk)，体裁不限。我选了上面这个题目，整理了一些心得感想，虽然活动很快就结束了，但是这些想法我打算还是以文字形式备忘一下。如果能给更多人帮助或参考，我会倍感欣慰。\r\n\r\n### 目标的转变\r\n\r\n作为学生，毫无疑问是以学业为重。在校园里，大家不出意外都会把学习定为最大的目标，围着功课转。但是工作之后，你可能面对很多事情要处理，怎么有所成就？怎么赚钱？怎么照顾好自己？怎么照顾好家庭……除了目标本身不同之外，我觉得更大的不一样在于，在相当长且连续的学生生涯中，我们没有太多选择的余地和必要，即便是有什么目标，也基本上是被动接受或被灌输的。但是走出校园之后，你面对的是一个无比自由开放的社会。这个时候你需要的不是意见，而是主见。甚至你是否做好了准备，有了足够的本事从事一项工作，还是继续学习深造修炼自我，直到自己准备好为止再工作？这也需要你的主见 (并为这个主见承担相应的后果，某种角度上)。最终很多选择是开放的，权衡的，遵从自己内心的结果。\r\n\r\n还有一点我想说的是，因为你拥有了新的目标，而且不再会有人逼着你学习，从外部给你学习上的压力，所以客观上学习的环境也没有那么好那么纯粹了，学习这件事情会逐渐变得让你渴望、珍惜、喜欢。希望你还没有因为繁重的学业对新事物新知识，尤其是表面上枯燥但实际上对你有很多帮助的东西，失去动力。我们在校园里更多的是学习知识，然后推导这些知识可以用在什么地方；走出校园之后更多的需要思考，我遇到一个问题想解决它，究竟有多少知识哪些知识可以为我所用？也许在未来的某一天你会突然觉得，当时在校园里，学习环境那么好，怎么没有多看两本书，多做些训练。所以最好不要丢下自己看书学习的习惯，给自己定个长期的学习计划，有空就多看两本书。\r\n\r\n### 学会社交\r\n\r\n坦白地讲我觉得这在校园里并不是必备的技能。但是走出校园之后，它非常非常重要。这也是为什么几乎所有的公司都会给员工做沟通培训 (尽管那并不一定管用)。社交并不只是沟通而已，也不只是表达，更是聆听，是待人接物的每一个细节。我发现很多人在工作中，最简单的两件事情做不好，也不知道该怎么做，那就是：1 如何写邮件、2 如何开会。这表面上是职场礼数的范畴，也有很多文章介绍这些职场礼数，看上去就是个知识点罢了。但实际上一个人在理解和实践它的背后，反映的是修养，甚至是教养。这不是一两篇文章能够教会你的，是你平时为人处事方式的积累和感悟。\r\n\r\n另外社交能力的重要性不止体现在工作中，体现在你步入社会之后可能会面对的各种场合的各种人，比如和同事下班之后一起组织些活动放松消遣一下，和老乡或老同学叙叙旧——这些也都是我刚毕业的时候经常会做的事情。但是这里我认为更重要的场景是：学会如何跟陌生人打交道，如何更主动的和陌生人交流，和这个社会交流。从最简单的跟陌生人问路、跟陌生的房东租房子、甚至搭讪对吧 ^_^，到跟不同性格的服务员、乘务员、售票员、公交车司机、出租车司机沟通或寻求帮助，再到你如何主动但又不会让对方和周围人尴尬的帮助别人，包括你是否会本能的路见不平挺身而出……抱歉这可能有点超出社交这个话题了。但这些都是有关联的不是吗？每个人在这个社会中都是一个独立的个体，但又是相互依赖相互依靠的一个集体社会。想真正融入这个社会，我觉得这些都是必须的。\r\n\r\n最后，关于社交，还有一点很重要，就是在你刚刚加入一个公司或团队的时候，你周围的人一开始对你来说都是陌生人。这个社会上可能有很多适合你的机会，但它们不会主动找到你头上，这个时候需要你学会跟陌生人打交道。好的社交能力会让你的人生更有安全感，对自己办好一件事更有信心。和别人交流同样是一个完善自我认知的过程，尝试接受更多不同的观点，发现并理解不同的看问题的角度，有助于更认清自己，避免自以为是 (相信我，这种事情别人帮不上忙的，只能你自己领悟)。\r\n\r\n### 个人发展\r\n\r\n我觉得找工作这件事情，更多的要从兴趣出发，而不是所谓的“前途”。我逐渐越来越认同和相信一句老话：“三百六十行，行行出状元”。首先，如果对这件事情没有兴趣，你很难“用心”做好它，这样的状态也不是长久的；第二，我们已经看得见摸得着的“前途”和“机会”，往往已经不是什么好机会了，尤其是如今互联网时代事情变化发展这么快。而且那些真正抓住机会的人往往都是在完全没人看好的时候就开始全身心的投入在这个行业或方向上，才能在“机会”来临的时候抓住它，我不觉得这些人只是更厉害的“投机主义者”，如果没有兴趣在背后趋势着这些人，他们又是怎样才能在枯燥 (往往还伴随着高风险和不确定性) 的领域里这么坚定的做到今天呢？所以我的个人建议是，找工作，就完全追随自己的兴趣和内心就好了，不要想太多“这个行业比较赚钱比较有前途”之类的——它最多是你的一个参考项。找到自己的兴趣所在，相信它，相信自己，保持专注，一定有最好的回报，剩下的东西交给运(时)气(间)就好了。\r\n\r\n再有就是要相信专业的力量，对学问保有“敬畏之心”。这里的学问不只是纯职业技术，也包括做事方式方法等等一切社科类的研究。<!--虽然我们看到今天很多行业存在这样一种不健康的现象：做 X 不赚钱，然后免费做 X 出了名，靠走穴之类的“不专注”来赚钱；再接下来大家发现 X 方面不专业也没关系，只要“出了名”，后面的“商演走穴赚钱”也行得通，而“出名”的方法又有很多，所以渐渐的没有人相信专业 X 的价值。我不知道这个 X 换成音乐、演技、技术之类的名次是不是都适用，但是这种成功只是少数个体的成功，而且是很短暂的，更重要的是这并不是一个行业和社会的成功。-->如果一个行业的专业性丢掉了，整个行业也就被毁掉了，最后大家会一起丢掉工作，一起失败。\r\n\r\n这种东西我觉得跟很多已经被一份工作或长期不良型的环境所固化思想的“老家伙”们讲已经不一定有意义和效果了。但是对于打算或刚刚从校园步入社会，有理想，有抱负，承载着社会的未来的大学生们来说，我希望有机会在这方面多呼吁一下。尊重和相信专业的力量，耐得住性子，不要被一时的挫折、不走运或委屈左右，多多磨练自己，你一定不会后悔。\r\n\r\n### So Are You Ready？\r\n\r\n：）"},"230":{"title":"为什么我不会无偿加班且你也不应该","slug":"why-i-dont-unpaid-overtime-and-neither-should-you","created":1491048365,"modified":1501527464,"text":"译自：[http://thecodist.com/article/why_i_don_39_t_do_unpaid_overtime_and_neither_should_you](http://thecodist.com/article/why_i_don_39_t_do_unpaid_overtime_and_neither_should_you)\r\n\r\n原文写于 2012 年，至今已经有一段时间了，前段时间这篇文章又被大家翻出来热烈讨论，看过之后有些感触，所以翻译了一下\r\n\r\n----\r\n\r\n我是一个在美国待了 30 年的程序员，我有过一周工作超过 40 小时的经历，这在行业里面并不常见，但是我[很难][rarely]因此而得到更多的薪水。\r\n\r\n总之，我现在发现整个做法[很恶心][nauseating]。\r\n\r\n我并不是针对自营或创业等多干活儿就能得到更多回报的情况。我曾经在 80 年代中期到 90 年代开过两个小的软件公司，并且工作时间也很长，但是我们会共享全部的成果，而第二家公司我们在合同里就定好了多劳多得的规矩。当然这不是我们今天讨论的重点。\r\n\r\n如果我为一家大公司工作并且谈好了薪水，那我的预期就是我在标准的时间内，即公认的 (至少在美国) 一天 8 小时一周 5 天，尽我所能完成工作。如果他们希望我每周工作 70 个小时或有些主管期望团队每天都来上班，现在的我是会拒绝的。为什么呢？\r\n\r\n当我们决定工作赚钱的时候，我们假定工作的主要原因是为了换取我们生活所需的开销。雇员的预期是他们会获得等价于这笔薪水的产出。但问题在于，雇主概念中的价值经常和雇员的不一样，尤其在美国和亚洲。许多公司期望薪水是固定的，但是他们创造这些价值需要完成的工作是不确定的。雇主觉得只要提高对雇员的预期和要求，就能够获得更大的回报，这样他们就可以通过为每份薪水延长工作时间来降低实质的劳动成本。\r\n\r\n这对于雇员来说意味着什么？如果你同意了，那么你实际上就认同了自己的工作更廉价。甚至这种工作其实就是无偿的。那么作为雇员你在这样的无偿工作中收获了什么呢？在绝大多数雇主面前，你什么也没有得到。如果你是一个主管，也许会得到晋升，但是作为程序员你职业发展的道路不只是做管理这一条。如果你连续几个月每周编码超过 80 个小时，通常情况下得到的回报和一周努力工作 40 小时差不多。\r\n\r\n<!--more-->\r\n\r\n在一些行业里，比如 AAA 游戏工作室，准备发布大型游戏这样的关键时刻的经历都是非常痛苦的。而你看了很多人们玩命工作然后发布没多久就下岗了的故事。当然你是可以选择休息的，但是付出的代价是多少？收益又是多少？\r\n\r\n现在想象一下你自己是一个供应商 (我现在就是)。如果你要求在协议之上做更多的工作，那么公司付钱，供应商付出劳动。也许不会有更高的回报但不会比正常情况少。现在你是在为工作获取应有的回报。但奇怪之处在于，显然公司更倾向于根据时间付钱给你而不是你的实际产出，所以他们有的时候不会允许供应商加班。那他们为什么简单的要求雇员无偿工作或自告奋勇呢？\r\n\r\n美国工人一般都有 10 天左右的年休假，有的时候还额外有几天病假；但是全职的美国工人评价一年只休息 5～7 天。在世界上很多地方，尤其是欧洲，政府[授权][mandates] 20～30 天年假，人们基本上都会把这些假期用掉。在很多国家加班并不普遍，无偿加班是极少的，甚至是非法的。人们配得上工作之外的生活，对于他们来说，只为雇主埋头工作是[极其][unimaginably]愚蠢的。而我们在美国 (以及亚洲很多地方) 很少这么思考问题。\r\n\r\n我曾经有一个朋友，他的老板希望她的黑莓手机保持 24x7 待命状态。一年以后她拒绝并辞职了。她的老板为此[大为恼火][livid]。而在那段时间她没有获得任何多余的回报。那我们为什么还这么做呢？\r\n\r\n在欧美之间有一个很大的不同，美国的健康保险通常是和你的雇主绑定的，几乎没有其他地方给你[实质的][virtually]保障。如果你失业了，那么你得在有限的时间里支付一大笔 (COBRA) 费用，即便你找到了一份新工作，你的健康保险在 6 个月内也没法生效。所以对失业的恐惧感以及健康保险会让你更倾向于接受更长的无偿工作时间。感觉这个系统设计之初就想阻止你跳来跳去 (尤其是你成家之后)。在欧洲你的健康保险不会和雇主做任何绑定。如果公司想留住一个有价值的员工，他们就得采取一些积极的措施把你[留][entice]住。很多欧洲国家 (和欧元区) 你很难期待或要求别人无偿加班。\r\n\r\n另外一个无偿加班的副作用是更少的人被雇佣。如果你长期让你的雇员每周工作 60～80 小时，你就不需要雇佣更多的人。但是对于雇员来说他们收获了什么呢？基本是没有什么收获的。\r\n\r\n我想说的重点是，如果你付钱给我，那么我为你好好工作 40 小时，如果其他人愿意工作 60 或 80 小时，他们就更有价值而我就贬值了？我就应该由于没有把人生的全部都放在工作上而被解雇？那些愿意工作两倍时间的人就真的交付了两倍于我交付的价值吗？你可以反驳如果公司是根据工作时间给员工回报的，那么工作 80 小时的人就得到两倍回报，但这只是从雇主的角度来看。而雇员创造了更多的价值 (为公司带来了更多的收入) 但是没有得到任何更多的回报。当然你可以[无视][get rid of]我，找到更多这样的公司，但是我对这种现代的“奴隶制”并[不感冒][unappealing]。\r\n\r\n工作不能也不应该是一个人的生活的全部，这绝对是欧洲式的思维。生活对我来说也意味着更多。然而在美国有一种非常商业化的观点，就是如果你根据工作时间付钱，那么公司就不会成功；如果人们每年要休假 20 天，那么他们就会失败；一个雇员工作之外的生活一文不值。\r\n\r\n我从 Steve Jobs 听到的一个有意思的故事是，在 iPhone 装备的几周前 Steve 要求他们把塑料屏幕换成玻璃的，所以他们通知中国的工厂，那边立刻把上千名工人叫起来，每人发一块饼干一杯茶水，让他们每天连续工作 12 小时，直到 iPhone 装配好。真是一个神奇的故事，但同时也是一个悲伤的故事。他们如此轻易的放弃了生活 (我相信他们还是根据工作时间得到了报酬) 甚至乐在其中，就为了有份工作。而且我从雇主这里听到用这个故事来激励大家做相同的事情——“如果你每周不工作 80 个小时，那么在中国某些人就会顶替你的工作”。而企业会通过这些[引起][evoke]笑声的国家取得成功。\r\n\r\n经济是一门复杂的“科学”，我不想为此争辩太多。但是从一个个人工作者的角度看，就是一份付出一分回报。我有技能，公司有需求，我能作为一个有价值的工作者，但是这里是有度的。我不能对你或你的处境说什么，但是对我来说我的工作能力或工作期待是一个有限的范围。可能这是我的德国人的遗传，可能是因为我曾经在我的小公司每周工作 80 个小时的结果，可能我变老了也变聪明了，但是我更愿意享受工作和生活之间的平衡。\r\n\r\n当我在 General Dynamics 的第一份工作时，我认识一位年轻的经理，他每周七天连续工作并且每天工作很长时间。有天在一个会上他突然猝死了。你说他没日没夜的工作最后得到了什么呢？\r\n\r\n不为别人，也不为我自己。我努力工作，但到点该回家就会回家。你也应该这样。\r\n\r\n[rarely]: http://dict.cn/rarely\r\n[nauseating]: http://dict.cn/nauseating\r\n[mandates]: http://dict.cn/mandates\r\n[unimaginably]: http://dict.cn/unimaginably\r\n[livid]: http://dict.cn/livid\r\n[virtually]: http://dict.cn/virtually\r\n[entice]: http://dict.cn/entice\r\n[get rid of]: http://dict.cn/get%20rid%20of\r\n[unappealing]: http://dict.cn/unappealing\r\n[evoke]: http://dict.cn/evoke\r\n"},"232":{"title":"苹果正在做一些他们的程序员明摆着不想要的东西","slug":"apple-is-about-to-do-something-their-programmers-definitely-dont-want","created":1501526986,"modified":1501527399,"text":"译自: [https://medium.com/make-better-software/apple-is-about-to-do-something-their-programmers-definitely-dont-want-fc19f5f4487](https://medium.com/make-better-software/apple-is-about-to-do-something-their-programmers-definitely-dont-want-fc19f5f4487)\r\n\r\nJul 29, 2017\r\n\r\n作者 [Anil Dash](http://anildash.com/) 是 Fog Creek Software 的 CEO，致力于让科技变得更人性和道德一些，同时他也是 Medium 的顾问。\r\n\r\n----\r\n\r\n> 苹果在 Apple Park 这个漂亮的新办公楼上花了 50 亿美金，却犯了一个完全可以避免的极其昂贵的错误：让他们的程序员工作在一个开放式的格局中。这真让人惊讶。\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2017/08/2254787802.jpg)\r\n\r\n我在 Fog Creek Software 工作，我们的联合创始人兼前 CEO [Joel Spolsky](https://medium.com/u/869c7e626b83) 在[至少 17 年前](https://www.joelonsoftware.com/2000/04/19/where-do-these-people-get-their-unoriginal-ideas/)就已经针对开放式办公室对于程序员产能的糟糕影响撰文了。他在这方面的洞察基于了 Tom DeMarco 和 Tim Lister 的经典书籍[《Peopleware》](https://en.wikipedia.org/wiki/Peopleware:_Productive_Projects_and_Teams)——该书已经出版了三十年。所以这其实不是什么全新的观点。当然在这数十年里，也已经有无数的[学术研究确认](http://theconversation.com/open-plan-offices-attract-highest-levels-of-worker-dissatisfaction-study-18246)了同一个结论：人们在开放式空间办公是烦躁的、注意力不集中的、常常不开心的。\r\n\r\n这不是说开放式办公环境一无是处——它能够营造很好的协作和联络的氛围。对于市场或销售团队来说，共享空间是非常有意义的。但是对于需要身处某种工作流状态的任务来说呢？这个问题从科学的角度是有定论的。\r\n\r\n那就是把门关上。\r\n\r\n<!--more-->\r\n\r\n### 保持在工作流中\r\n\r\n现在，如果我们的工作或角色需要特定工作流的时候，那事情就能通过排除一切干扰而获益，编程或许就是这种绝无仅有的最好的例子。而苹果拥有一批这个世界上最顶尖的程序员，所以很显然应该给予他们非常好的环境。\r\n\r\n这就是为什么[华尔街日报的这篇醒目的文章](https://www.wsj.com/articles/how-jony-ive-masterminded-apples-new-headquarters-1501063201)里会出现这段关于苹果新总部的尤其刺眼的边注：\r\n\r\n> **数以千计的** Apple Park 的雇员都会出现在 Ive 的办公视线内。很多人都将坐在开放空间，而不是以往的小办公室。<mark>程序员们都会担心他们的工作氛围太过嘈杂和注意力不集中。</mark>……\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2017/08/941992970.png)\r\n\r\n通常，公司会以预算为由把程序员安排在开放式办公室。确实让每个程序员都有一个自己的封闭办公室是一笔不小的开销。但是鉴于苹果已经在这个新园区投资了 50 亿美金，且用上了[被 iPhone 设计影响了的定制抽水马桶](https://qz.com/905934/even-the-toilets-in-apples-aapl-campus-2-are-inspired-by-the-iphone/)，你很难确信这是因为省钱而做的决定。\r\n\r\n取消私人办公室的另一个可能的原因是，也许公司并不知道它的员工们的喜好。但是这个问题是可测试的——我们不带任何倾向性的暗示，来询问一下大家希望办公室是什么样子的，看看大家的回应如何。\r\n\r\n> 你曾经或现在拥有的办公室里的最好的特点是什么？\r\n>\r\n> Anil Dash (@anildash)  \r\n> 2:47 AM - Jul 19, 2017\r\n\r\n[Twitter Link](https://medium.com/media/1e30d93e0c22e81d448111d4f478fa20?postId=fc19f5f4487)\r\n\r\n在数百则回复中，你会发现许多人在谈论他们多么高兴自己有一个，或希望自己有一个可以把门关上的私人办公室。\r\n\r\n毫无疑问如果苹果和他们自己的团队交流过后，能够得到相同的回复。所以唯一剩下的可能就是在这个行业里，没有足够的人真正相信程序员值得拥有一个私人办公室。所以我们会继续大声呼吁这件事情。\r\n\r\n### 近距离看看\r\n\r\n来参观一下 Fog Creek 在纽约的总部\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2017/08/1791376931.jpg)\r\n\r\n[Google Map Link](https://www.google.com/maps/@40.706976,-74.0132501,0a,29.2y,273.42h,100.56t/data=!3m4!1e1!3m2!1su6fRkLZ36IAAAAQIt5lP8A!2e0?source=apiv3)\r\n\r\n将近二十年前，我记得自己在 Joel 的博客上看到了有关 Fog Creek 新办公室的构造，后来当它完工的时候，我记得看到纽约时报[热切的报道](http://www.nytimes.com/2009/02/08/realestate/commercial/08sqft.html)它的创新。在那时，我从未想象过我有一天会在那里工作。我看着那篇文章，脑海里幻想着自己在那里的样子，带有一点怀疑的问这些努力是否值得。\r\n\r\n现在我得承认，当开始想象自己在 Fog Creek 拥有一间新办公室的时候，我一度被诱惑到了，我想知道通过像其它几乎每一家公司一样使用开放式办公室来省一些钱是否真的很好。这样做是很容易的。\r\n\r\n现在 Fog Creek 已经改变了很多——我们公司大约三分之二的工作是远程进行的，尽管几乎所有人都在家中的办公室办公，你猜到了，都是关门的。同时像销售和客服这样的团队从开放式的办公区域中获益。我们可以讨论到所有人的意见一致为止。\r\n\r\n不过即便是共享空间的团队也会因为我们在新办公室里提供了电话亭而兴奋，这会方便他们在一个私人空间里打电话。同时我们的技术人员仍然和以前一样拥有超高的工作效率，没有低效的时段，这可以归功于他们有适合他们工作的正确的环境。\r\n\r\n最重要的是，专注于创造一个非常棒的工作环境，甚至让我们考虑新的想法，来帮助人们同时拥有两个最好的世界，犹如一辆“安静的汽车”置身于一个大型的会议室。这样的地方能让人们坐在一起但同时仍然可以享受安静和平静，灵感来源于大家最喜欢的 [Amtrak amenity](https://www.amtrak.com/onboard-the-train-quiet-car)。\r\n\r\n### 结语\r\n\r\n如果一家公司想把产品做得像苹果一样成功，我们永远无法给出建议。尽管我们为 [Glitch](https://glitch.com/) 和 [FogBugz](https://fogbugz.com/) 而无比的自豪，我们仍然对苹果近几十年来所做的一切深表敬意。但是我们不希望对这个有机会避免的错误袖手旁观而让其继续下去，因为这是一个苹果 (同时也是每一家自己有程序员的公司！) 不费吹灰之力就可以解决的缺点。\r\n\r\n我们很高兴这么多公司知道在他们的雇员身上投资——从医疗保健到最新最棒的计算机硬件的一切东西。但是当他们需要集中精神的时候，也强求每个工作人员都要共享一个开放式的空间时，哪怕是最大最成功的公司也是时候 think different 了吧？\r\n"},"236":{"title":"Web 表单的未来","slug":"the-future-of-web-forms","created":1501858816,"modified":1501859156,"text":"译自：[https://blog.prototypr.io/the-future-of-web-forms-4578485e1461](https://blog.prototypr.io/the-future-of-web-forms-4578485e1461) Matt West 的 The Future of Web Forms\r\n\r\nlicense: [CC BY-SA 4.0](https://creativecommons.org/licenses/by-sa/4.0/)\r\n\r\n----\r\n\r\n如何通过会话式的界面让数据收集更加人性化。\r\n\r\nWeb 表单是从纸质媒介进化而来的。即设计一组标签和线框来限制输入，同时让数据处理变得跟容易。\r\n\r\n毕竟，表单的目的是收集数据，以便执行操作。为了执行该操作，我们需要把收集的数据统一汇总。我们在界面上设计了一些约束以便达到统一汇总的目的。表单旨在符合流程上的需求，而非用户本身。\r\n\r\n表单经常给人的感觉是冷冰冰的，没有人情味。因此，我们得到的回应往往也是冷酷和不人性的。我们不深入细节，如果一个朋友问你相同的问题，你可能会多一些回复，但这是一台电脑。他想要的只是数据，别的不在乎。就好像你在跟人说话但是人家并没有在听。为什么没人听的话说出来会让人觉得烦呢？\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2017/08/3710637212.jpg)\r\nImage by [Ken Teegardin](https://www.flickr.com/photos/teegardin/5512347305/in/photolist-9p7dNM-nfdbBe-cDphCL-9xSJ1E-4ygMXx-6jXLSo-9oAgas-nytcFV-aXPWKv-2rxaS-6jXZNW-oTkWEk-iYYsDH-pMeotq-5SLAGV-6jERwK-6jBcih-iq2oUj-9c36uA-6wAbW4-7vWrZv-dRsLkh-99N1pk-g1vCAm-g4P8w-eSo6V4-biaFTP-6jk9td-J9DyZ-cQay4s-6jXYcS-9PSLHY-iYKUVr-h5Eh26-6jBXaA-7vTL6V-pMfC4t-5u8Nod-7b3sfu-fdPdkW-7vVobi-5Tscj8-7vUV6p-bDw2PE-6jxKBi-5Tww8J-89GCkF-6jxKTi-6jBWUG-eiwixk).\r\n\r\n和许多数字化的东西一样，表单已经被之前的形态严重影响。我们之所以往线框里填东西是因为我们以前在纸上就是这么画的。\r\n\r\n<!--more-->\r\n\r\n我们在纸上主要的输入法是钢笔或铅笔。现在已经不一样了，我们被上百年的约束限制了自己。\r\n\r\n技术已经从这些约束中解放了我们。我们已经拥有了创建更人性化的人机交互的工具。\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2017/08/4181232011.jpg)\r\nSpike Jonze’s film “Her” provides an interesting prediction for how we might interact with computers in the future.\r\n\r\n我们已经很接近在语音识别、自然语言处理和人工智能等方面与人类进行有意义的对话了。甚至我们的工具已经在构建足够优秀的体验了。\r\n\r\n所以我们回到表单。我们该如何使用这些工具使得表单更人性化呢？\r\n\r\n我们需要摆脱之前对于表单界面的预设。聚焦在通过技术构建一个更佳自然的体验，而不是去除操作层面的约束。\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2017/08/2141635702.png)\r\nA conversation with Facebooks chat bot “Poncho”.\r\n\r\n在过去几年中，我们已经看到了一些新产品致力于通过科技让我们的交互更自然。Siri、Alexa、chat bots 都让我们朝着正确的方向发展，但是我们还没有看到这些创新以某种方式融入到浏览器界面中。\r\n\r\n我们有非常多的潜力在更加会话式的 web 界面上，当我们需要收集数据时，我们仍然从一堆输入框和下拉框中构建表单。\r\n\r\n有些人在推动这件事。保险服务 [Jack](https://withjack.co.uk/quote/) 最近发布了一个令人印象深刻的页面来收集保险报价所需的细节。\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2017/08/1469363781.png)\r\nThe “Get a Quote” page from [withjack.co.uk](https://withjack.co.uk/)\r\n\r\n虽然回复依然是被约束的，但是这个收集数据的设计流程已经创造出了更加愉悦和友善的体验。\r\n\r\n向用户展示一个标准的 web 表单因此而变得更加容易，但是这样的用户交互更像是一个会话的过程，Jack 已经创造出了更加自然的感受。\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2017/08/993446137.png)\r\nAdrian Zumbrunnen’s conversations website [azumbrunnen.me](http://azumbrunnen.me/)\r\n\r\nAdrian Zumbrunnen 在发布他的会话式的个人网站之后引起了互联网的关注。Adrian 设计了一个界面，通过一些回复选项来引导用户浏览他的 UI/UX 作品。Adrian 的网站巧妙的考虑到了用户如何到达他的网站并以此为信号来理解用户所处的情景。\r\n\r\n我们的方向是对的，但感觉还是少了什么。从技术角度看，构建一个真实的会话式界面需要理解用户的意图和语境，而不仅仅是一些回复选项和位置摆放很聪明的文本框。我们需要基于已经做好的 chat bot 且开发出能够让人们用自然语言与其交流的界面。\r\n\r\n界面甚至在开始之前就应该知道我们是谁。底层技术已经有现成的了，那就是浏览器的自动填表。你所有的细节都存在同一个地方，对于一个网站来说，一个简单的请求就可以访问。\r\n\r\n该界面应该能够适配当前所处的情境。会话是你是从网站的帮助支持页面开始的还是从营销站点的首页开始的？这些信号可以帮助我们理解用户的语境并为其定制适当的系统回复。这些事情 Adrian 的网站并没有做。\r\n\r\n让我们体验一下如何把用户注册流程变得更加会话式。\r\n\r\n![](http://jiongks-typecho.stor.sinaapp.com/usr/uploads/2017/08/68310827.png)\r\nWhat would the sign up flow look like if we moved beyond forms?\r\n\r\n我们今天拥有做这件事相应的数据，但是把所有的东西一起提供出来以创造这样一个自然的体验是真正难的地方。\r\n\r\n再考虑牵连到可访问性、隐私、多语言支持、赋予情绪和同理心的设计。如果我们打算通过技术引入一个全新的更有意义的交互设计，这些都是我们今天要去面临和克服的挑战。\r\n\r\n没想到我们已经走到这么远了，但是这里仍然有很多事情要做。未来就在不远处的转角，但我们要敢于去做才行。"},"243":{"title":"第四届 CSSConf CN 见闻","slug":"cssconf-cn-4","created":1522766966,"modified":1522767814,"text":"上周末作为一名分享者参加了 [CSSConf CN](https://css.w3ctech.com/)，在厦门。\r\n\r\n其实除了自己的分享内容，这次我是带着很明确的目的参会的，因为有两个主题我特别关注，就是：\r\n\r\n* 第一个：响应式的组件\r\n* 第三个：从 API 的角度看组件的 CSS\r\n\r\n(两个分享的标题都被我稍微“演绎”了一下)\r\n\r\n这两件事都是自己工作上正在特别关注的事情，一方面，我们很少从 API 的角度去理解一个组件的 CSS 该如何组织和管理，所以这个标题就特别吸引我，另一方面响应式组件的分享者是来自新加坡的前端工程师 Zell (我个人一直觉得国内的响应式都是在瞎搞，看了很多周围团队都没有认真做这件事，甚至不相信响应式的价值，从设计师到工程师)，因此非常珍惜这个机会能近距离学习一些国外的同行们是怎么看待和实践响应式的。\r\n\r\n所以尽管我们团队的差旅经费已经用完了，还是决定自费来厦门近距离交流一下。\r\n\r\n现在证明这次真的不虚此行。\r\n\r\n当然参加这种线下活动，“面基”的目的是一定有的……恩，这个不值一提。\r\n\r\n### 响应式组件\r\n\r\n在谈这次分享内容给我的收获之前，我想说，实际上我不只是从几十分钟的分享中学习了响应式组件的东西。我这次去厦门的行程特地提前了两天，周四就到厦门了，就是希望能多一些分享的准备和现场交流。正好 Zell 也到的比较早，于是乎我在周末的会议之前就跟 Zell 聊了很多。真的是很难得的机会。\r\n\r\n回到分享的内容，我听过 Zell 的分享之后简单整理了一些要点：\r\n\r\n1. Proportional scaling：让所有的组件成比例\r\n  * 注意字号：`font-size` 尽量使用 `em` 单位，而不是如 `px` 的绝对单位\r\n  * 注意视口/窗口大小 (viewport)：尽量使用 `vw`、`vh`、`vmin`、`vmax` 单位，必要的时候可以配合 `calc()`\r\n2. Responsive scaling：处理好响应式的断点\r\n  * 善用 media query\r\n  * 尽可能使用 `min-width`，以小屏幕为基础\r\n  * 必要的时候使用 `min-width` 和 `max-width` 的交集，避免样式间不必要的相互干扰\r\n3. Modular scaling：像乐高一样拼合模块时的注意事项\r\n  * 不要在子元素上直接设置外边距\r\n  * 取而代之的是在父元素上整体设置每个子元素的边距\r\n    * 巧用 `+` 选择器处理最后一个元素多余的边距\r\n  * 在需要对其的地方使用 `rem` 作为边距的单位以避免被组件的字号影响布局\r\n4. Morphable blocks：尽可能透过不同的表象提炼相同结构的组件，以达到尽可能的复用和组件数最小化\r\n  * 找出相同点和不同点\r\n  * 得出最佳的 HTML 结构\r\n  * 通过设置不同的样式展示出不同的效果\r\n  * 让 modifier (BEM 中的 M) 的数量尽可能的少\r\n5. 额外的小贴士：命名规范和约定、避免在选择器上使用 ID 从而使得选择器的权重失控\r\n\r\n实际上每一条都不是很难，也不是没有见到过，但是总结的非常有系统性，给了大家一些很好开始的着手点。\r\n\r\n另外 Zell 在聊天过程中也提到了很多我非常认同的观点和细节，想分享给大家：\r\n\r\n* 前端工程师是真正用户体验的“最后一道门”，身为前端工程师一定要有意识捍卫用户体验 (这句话后来跟 裕波 聊天的时候他说了一模一样的话，可见大家都十分认同)。\r\n* 前端工程师一定要跟设计师“坐在一起”工作，一定要强沟通，才能把工作做好。\r\n* 跟 Zell 聊到响应式在自己的工作中遇到很多困难的时候，Zell 出乎意料的大方对我说“你找我就对了”，即大方又自信。看得出来响应式在 Zell 看来已经是吃饭喝水一样了，我们自己包括周围的人却连一步都还没走出来，真是觉得惭愧。\r\n\r\n### 从 API 的角度看组件的 CSS\r\n\r\n我记录了一些要点和自己的理解：\r\n\r\n* 首先，通过 CSS 的发展史来看，我们一直试图通过一种特定的语法 (CSS) 来描述网页的样式，但在 web page -> web app 的划时代趋势下，我们组织代码的方式也发生了变化，尤其是 CSS 的部分容易被人们忽视。\r\n* 分享者 E0 把今天的 CSS 设计问题，从 API 的角度划分成了三个层次：\r\n  1. 对于组件的维护者来说：要把一部分 CSS 样式封装起来，供自己维护，同时也要避免被组件的使用者误修改或滥修改，通常这些样式会被内联或编译为无语义不可编辑的 CSS class\r\n  2. 对于组件的使用者来说：要把一部分 CSS 用法暴露出来，供开发者灵活配置或修改，很多组件库会在文档中列出可以配置和修改的 CSS class，但除此之外，还有一些库做了很巧妙的不一样的封装，比如通过扩展的伪类或伪元素。这种方式我之前没有留意到过，有点开眼界\r\n  3. 对于浏览器插件作者：这个角度也是我之前没有认真思考过的，就是说还有这样一群开发者，希望通过浏览器插件处理一些不同用户的特定需求。如果我们的组件希望对这些人友好，那么就多了一层考量。这时我们就想到了一些更加通用或规范化的，和具体工具、库、编译方式无关的设计，比如 CSS 自定义属性、无权重的选择器等\r\n\r\n听过之后非常受启发。\r\n\r\n这两份 slides 我也第一时间分享给了我们团队组件库的同学们了解学习了：）\r\n\r\n### 关于自己分享的 CSS Houdini\r\n\r\n这些内容可能真的是有一点“超前”了，因为很多浏览器都还没实现，而且规范本身也没有稳定下来。但是我迫不及待的想分享出来，是因为我也听到了一些说法，说“CSS 很久没有什么新闻了”。那 CSS Houdini 绝对是一个可以让 CSS 更上一层楼的“重量级”的东西。希望可以通过分享 CSS Houdini 让大家对 CSS 更有信心和期待。\r\n\r\n同时很多技术的“风向”都是由最底层的东西决定的，我们从规范层面对 CSS 有更多的了解，一定会对我们的实际工作有很多指导和借鉴的价值。如果你同时还是一个有开源精神的人，那么你可以从今天开始就构思一些基于 CSS Houdini 的工具和库了对吧，用这些工具和库加速 CSS Houdini 的落地，同时也尽快把一些之前没有 CSS Houdini 的时候大家用起来很别扭很勉强的东西汰换掉，更在这个过程中体会 web 带给我们的乐趣：）\r\n\r\n### 其它\r\n\r\n另外几个分享也各有特色，总体上，我觉得这次 CSSConf CN 同时包含了 CSS 的规范、理念、工具、技巧、动画、八卦、吐槽各个方面，应该是尽可能照顾到了大家的兴趣和需求了。还是觉得这样的会议非常的棒。\r\n\r\n我觉得 CSS 和动画、SVG、字体设计、3D 图形学、可访问性、语义化的 web 等话题有着非常紧密的联系，有很多有意义的延伸，并且这些话题也很难有独立的 Conf 了吧我估计。再加上 CSSConf 的主办者们，尤其是 裕波，是非常懂前端开发者们的，他们经营 CSSConf 的理念和方式我一直非常认同和欣赏，所以也许未来有一天，CSSConf 会比 JSConf 更受人关注。\r\n\r\n以上"}}